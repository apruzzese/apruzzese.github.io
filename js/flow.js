/* @license
    All Rights Reserved.
    Copyright (c) 2016 by The Digital Gap OÚ
*/
(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
   typeof define === 'function' && define.amd ? define(['exports'], factory) :
   (factory((global.flow = global.flow || {})));
}(this, (function (exports) { 'use strict';

var babelHelpers = {};
babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

babelHelpers.classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

babelHelpers.createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

babelHelpers.extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

babelHelpers.inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

babelHelpers.possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

babelHelpers;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _isObject = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : babelHelpers.typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

var isObject = _isObject;
var _anObject = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

var isObject$1 = _isObject;
var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is$1 = isObject$1(document$1) && isObject$1(document$1.createElement);
var _domCreate = function (it) {
  return is$1 ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject$2 = _isObject;
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function (it, S) {
  if (!isObject$2(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject$2(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject$2(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject$2(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var anObject = _anObject;
var IE8_DOM_DEFINE = _ie8DomDefine;
var toPrimitive = _toPrimitive;
var dP$1 = Object.defineProperty;

var f$1 = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP$1(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f$1
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var dP = _objectDp;
var createDesc = _propertyDesc;
var _hide = _descriptors ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _redefine = createCommonjsModule(function (module) {
var global = _global;
var hide = _hide;
var has = _has;
var SRC = _uid('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

_core.inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
});

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding
var aFunction = _aFunction;
var _ctx = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

var global$1 = _global;
var core = _core;
var hide = _hide;
var redefine = _redefine;
var ctx = _ctx;
var PROTOTYPE = 'prototype';

var $export$1 = function $export$1(type, name, source) {
  var IS_FORCED = type & $export$1.F;
  var IS_GLOBAL = type & $export$1.G;
  var IS_STATIC = type & $export$1.S;
  var IS_PROTO = type & $export$1.P;
  var IS_BIND = type & $export$1.B;
  var target = IS_GLOBAL ? global$1 : IS_STATIC ? global$1[name] || (global$1[name] = {}) : (global$1[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global$1) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export$1.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global$1.core = core;
// type bitmap
$export$1.F = 1; // forced
$export$1.G = 2; // global
$export$1.S = 4; // static
$export$1.P = 8; // proto
$export$1.B = 16; // bind
$export$1.W = 32; // wrap
$export$1.U = 64; // safe
$export$1.R = 128; // real proto method for `library`
var _export = $export$1;

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

var _stringWs = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var $export = _export;
var defined = _defined;
var fails = _fails;
var spaces = _stringWs;
var space = '[' + spaces + ']';
var non = '\u200B\x85';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim$3) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim$3 = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

var _stringTrim = exporter;

// 21.1.3.25 String.prototype.trim()

_stringTrim('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.1.15 ToLength
var toInteger = _toInteger;
var min = Math.min;
var _toLength = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var toString$1 = {}.toString;

var _cof = function (it) {
  return toString$1.call(it).slice(8, -1);
};

var global$2 = _global;
var SHARED = '__core-js_shared__';
var store = global$2[SHARED] || (global$2[SHARED] = {});
var _shared = function (key) {
  return store[key] || (store[key] = {});
};

var _wks = createCommonjsModule(function (module) {
var store = _shared('wks');
var uid = _uid;
var _Symbol = _global.Symbol;
var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
});

// 7.2.8 IsRegExp(argument)
var isObject$3 = _isObject;
var cof = _cof;
var MATCH = _wks('match');
var _isRegexp = function (it) {
  var isRegExp;
  return isObject$3(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

// helper for String#{startsWith, endsWith, includes}
var isRegExp = _isRegexp;
var defined$1 = _defined;

var _stringContext = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined$1(that));
};

var MATCH$1 = _wks('match');
var _failsIsRegexp = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH$1] = false;
      return !'/./'[KEY](re);
    } catch (f) {/* empty */}
  }return true;
};

var $export$2 = _export;
var toLength = _toLength;
var context = _stringContext;
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export$2($export$2.P + $export$2.F * _failsIsRegexp(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

var $export$3 = _export;
var toLength$1 = _toLength;
var context$1 = _stringContext;
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export$3($export$3.P + $export$3.F * _failsIsRegexp(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context$1(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength$1(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength$1(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

var _meta = createCommonjsModule(function (module) {
var META = _uid('meta');
var isObject = _isObject;
var has = _has;
var setDesc = _objectDp.f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !_fails(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function setMeta(it) {
  setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {} // weak collections IDs
    } });
};
var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : babelHelpers.typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
    // return object ID
  }return it[META].i;
};
var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
    // return hash weak collections IDs
  }return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};
});

var def = _objectDp.f;
var has$1 = _has;
var TAG = _wks('toStringTag');

var _setToStringTag = function (it, tag, stat) {
  if (it && !has$1(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

var f$2 = _wks;

var _wksExt = {
	f: f$2
};

var _library = false;

var global$4 = _global;
var core$1 = _core;
var LIBRARY = _library;
var wksExt$1 = _wksExt;
var defineProperty$1 = _objectDp.f;
var _wksDefine = function (name) {
  var $Symbol = core$1.Symbol || (core$1.Symbol = LIBRARY ? {} : global$4.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$1($Symbol, name, { value: wksExt$1.f(name) });
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof$1 = _cof;
// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof$1(it) == 'String' ? it.split('') : Object(it);
};

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _iobject;
var defined$2 = _defined;
var _toIobject = function (it) {
  return IObject(defined$2(it));
};

var toInteger$1 = _toInteger;
var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function (index, length) {
  index = toInteger$1(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes
var toIObject$2 = _toIobject;
var toLength$2 = _toLength;
var toAbsoluteIndex = _toAbsoluteIndex;
var _arrayIncludes = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject$2($this);
    var length = toLength$2(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

var shared$1 = _shared('keys');
var uid$1 = _uid;
var _sharedKey = function (key) {
  return shared$1[key] || (shared$1[key] = uid$1(key));
};

var has$2 = _has;
var toIObject$1 = _toIobject;
var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO = _sharedKey('IE_PROTO');

var _objectKeysInternal = function (object, names) {
  var O = toIObject$1(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
    if (key != IE_PROTO) has$2(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (has$2(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys$1 = _objectKeysInternal;
var enumBugKeys = _enumBugKeys;

var _objectKeys = Object.keys || function keys(O) {
  return $keys$1(O, enumBugKeys);
};

var f$3 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$3
};

var f$4 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$4
};

// all enumerable object keys, includes symbols
var getKeys = _objectKeys;
var gOPS = _objectGops;
var pIE = _objectPie;
var _enumKeys = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }return result;
};

// 7.2.2 IsArray(argument)
var cof$2 = _cof;
var _isArray = Array.isArray || function isArray(arg) {
  return cof$2(arg) == 'Array';
};

var dP$3 = _objectDp;
var anObject$3 = _anObject;
var getKeys$1 = _objectKeys;

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$3(O);
  var keys = getKeys$1(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
    dP$3.f(O, P = keys[i++], Properties[P]);
  }return O;
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject$2 = _anObject;
var dPs = _objectDps;
var enumBugKeys$1 = _enumBugKeys;
var IE_PROTO$1 = _sharedKey('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE$2 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = enumBugKeys$1.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
    delete _createDict[PROTOTYPE$2][enumBugKeys$1[i]];
  }return _createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$2] = anObject$2(O);
    result = new Empty();
    Empty[PROTOTYPE$2] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = _createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys$2 = _objectKeysInternal;
var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

var f$6 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys$2(O, hiddenKeys);
};

var _objectGopn = {
	f: f$6
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject$3 = _toIobject;
var gOPN$1 = _objectGopn.f;
var toString$2 = {}.toString;

var windowNames = (typeof window === 'undefined' ? 'undefined' : babelHelpers.typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN$1(it);
  } catch (e) {
    return windowNames.slice();
  }
};

var f$5 = function getOwnPropertyNames(it) {
  return windowNames && toString$2.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(toIObject$3(it));
};

var _objectGopnExt = {
	f: f$5
};

var pIE$1 = _objectPie;
var createDesc$2 = _propertyDesc;
var toIObject$4 = _toIobject;
var toPrimitive$2 = _toPrimitive;
var has$3 = _has;
var IE8_DOM_DEFINE$1 = _ie8DomDefine;
var gOPD$1 = Object.getOwnPropertyDescriptor;

var f$7 = _descriptors ? gOPD$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIObject$4(O);
  P = toPrimitive$2(P, true);
  if (IE8_DOM_DEFINE$1) try {
    return gOPD$1(O, P);
  } catch (e) {/* empty */}
  if (has$3(O, P)) return createDesc$2(!pIE$1.f.call(O, P), O[P]);
};

var _objectGopd = {
	f: f$7
};

// ECMAScript 6 symbols shim

var global$3 = _global;
var has = _has;
var DESCRIPTORS = _descriptors;
var $export$4 = _export;
var redefine$1 = _redefine;
var META = _meta.KEY;
var $fails = _fails;
var shared = _shared;
var setToStringTag = _setToStringTag;
var uid = _uid;
var wks = _wks;
var wksExt = _wksExt;
var wksDefine = _wksDefine;
var enumKeys = _enumKeys;
var isArray$1 = _isArray;
var anObject$1 = _anObject;
var toIObject = _toIobject;
var toPrimitive$1 = _toPrimitive;
var createDesc$1 = _propertyDesc;
var _create = _objectCreate;
var gOPNExt = _objectGopnExt;
var $GOPD = _objectGopd;
var $DP = _objectDp;
var $keys = _objectKeys;
var gOPD = $GOPD.f;
var dP$2 = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global$3.Symbol;
var $JSON = global$3.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE$1 = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE$1];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global$3.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP$2({}, 'a', {
    get: function get() {
      return dP$2(this, 'a', { value: 7 }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP$2(it, key, D);
  if (protoDesc && it !== ObjectProto) dP$2(ObjectProto, key, protoDesc);
} : dP$2;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE$1]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && babelHelpers.typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return (typeof it === 'undefined' ? 'undefined' : babelHelpers.typeof(it)) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject$1(it);
  key = toPrimitive$1(key, true);
  anObject$1(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP$2(it, HIDDEN, createDesc$1(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc$1(0, false) });
    }return setSymbolDesc(it, key, D);
  }return dP$2(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject$1(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive$1(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive$1(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc$1(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine$1($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  _objectGopn.f = gOPNExt.f = $getOwnPropertyNames;
  _objectPie.f = $propertyIsEnumerable;
  _objectGops.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !_library) {
    redefine$1(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export$4($export$4.G + $export$4.W + $export$4.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols =
// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}$export$4($export$4.S + $export$4.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});

$export$4($export$4.S + $export$4.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export$4($export$4.S + $export$4.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray$1(replacer)) replacer = function replacer(key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE$1][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global$3.JSON, 'JSON', true);

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof$3 = _cof;
var TAG$1 = _wks('toStringTag');
// ES3 wrong here
var ARG = cof$3(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

var _classof = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
  // builtinTag case
  : ARG ? cof$3(O)
  // ES3 arguments fallback
  : (B = cof$3(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

// 19.1.3.6 Object.prototype.toString()

var classof = _classof;
var test = {};
test[_wks('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  _redefine(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

var toInteger$2 = _toInteger;
var defined$3 = _defined;
// true  -> String#at
// false -> String#codePointAt
var _stringAt = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined$3(that));
    var i = toInteger$2(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _iterators = {};

var create$1 = _objectCreate;
var descriptor = _propertyDesc;
var setToStringTag$2 = _setToStringTag;
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () {
  return this;
});

var _iterCreate = function (Constructor, NAME, next) {
  Constructor.prototype = create$1(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag$2(Constructor, NAME + ' Iterator');
};

// 7.1.13 ToObject(argument)
var defined$4 = _defined;
var _toObject = function (it) {
  return Object(defined$4(it));
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has$5 = _has;
var toObject = _toObject;
var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto$1 = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has$5(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto$1 : null;
};

var LIBRARY$1 = _library;
var $export$5 = _export;
var redefine$2 = _redefine;
var hide$1 = _hide;
var has$4 = _has;
var Iterators = _iterators;
var $iterCreate = _iterCreate;
var setToStringTag$1 = _setToStringTag;
var getPrototypeOf = _objectGpo;
var ITERATOR = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag$1(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY$1 && !has$4(IteratorPrototype, ITERATOR)) hide$1(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!LIBRARY$1 || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide$1(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine$2(proto, key, methods[key]);
    } else $export$5($export$5.P + $export$5.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

// call something on iterator step with safe closing on error
var anObject$4 = _anObject;
var _iterCall = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject$4(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject$4(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator
var Iterators$1 = _iterators;
var ITERATOR$1 = _wks('iterator');
var ArrayProto = Array.prototype;

var _isArrayIter = function (it) {
  return it !== undefined && (Iterators$1.Array === it || ArrayProto[ITERATOR$1] === it);
};

var $defineProperty$1 = _objectDp;
var createDesc$3 = _propertyDesc;

var _createProperty = function (object, index, value) {
  if (index in object) $defineProperty$1.f(object, index, createDesc$3(0, value));else object[index] = value;
};

var classof$1 = _classof;
var ITERATOR$2 = _wks('iterator');
var Iterators$2 = _iterators;
var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || Iterators$2[classof$1(it)];
};

var ITERATOR$3 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$3]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {/* empty */}

var _iterDetect = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$3]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR$3] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

var ctx$1 = _ctx;
var $export$6 = _export;
var toObject$1 = _toObject;
var call = _iterCall;
var isArrayIter = _isArrayIter;
var toLength$3 = _toLength;
var createProperty = _createProperty;
var getIterFn = core_getIteratorMethod;

$export$6($export$6.S + $export$6.F * !_iterDetect(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject$1(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx$1(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength$3(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var $export$7 = _export;
var createProperty$1 = _createProperty;

// WebKit Array.of isn't generic
$export$7($export$7.S + $export$7.F * _fails(function () {
  function F() {/* empty */}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of() /* ...args */{
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) {
      createProperty$1(result, index, arguments[index++]);
    }result.length = aLen;
    return result;
  }
});

var isObject$4 = _isObject;
var isArray$2 = _isArray;
var SPECIES = _wks('species');

var _arraySpeciesConstructor = function (original) {
  var C;
  if (isArray$2(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray$2(C.prototype))) C = undefined;
    if (isObject$4(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = _arraySpeciesConstructor;

var _arraySpeciesCreate = function (original, length) {
  return new (speciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx$2 = _ctx;
var IObject$1 = _iobject;
var toObject$2 = _toObject;
var toLength$4 = _toLength;
var asc = _arraySpeciesCreate;
var _arrayMethods = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject$2($this);
    var self = IObject$1(O);
    var f = ctx$2(callbackfn, that, 3);
    var length = toLength$4(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true; // some
              case 5:
                return val; // find
              case 6:
                return index; // findIndex
              case 2:
                result.push(val); // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _wks('unscopables');
var ArrayProto$1 = Array.prototype;
if (ArrayProto$1[UNSCOPABLES] == undefined) _hide(ArrayProto$1, UNSCOPABLES, {});
var _addToUnscopables = function (key) {
  ArrayProto$1[UNSCOPABLES][key] = true;
};

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export$8 = _export;
var $find = _arrayMethods(5);
var KEY$1 = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY$1 in []) Array(1)[KEY$1](function () {
  forced = false;
});
$export$8($export$8.P + $export$8.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_addToUnscopables(KEY$1);

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export$9 = _export;
var $find$1 = _arrayMethods(6);
var KEY$2 = 'findIndex';
var forced$1 = true;
// Shouldn't skip holes
if (KEY$2 in []) Array(1)[KEY$2](function () {
  forced$1 = false;
});
$export$9($export$9.P + $export$9.F * forced$1, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_addToUnscopables(KEY$2);

// 19.1.2.1 Object.assign(target, source, ...)

var getKeys$2 = _objectKeys;
var gOPS$1 = _objectGops;
var pIE$2 = _objectPie;
var toObject$3 = _toObject;
var IObject$2 = _iobject;
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject$3(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS$1.f;
  var isEnum = pIE$2.f;
  while (aLen > index) {
    var S = IObject$2(arguments[index++]);
    var keys = getSymbols ? getKeys$2(S).concat(getSymbols(S)) : getKeys$2(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }return T;
} : $assign;

// 19.1.3.1 Object.assign(target, source)
var $export$10 = _export;

$export$10($export$10.S + $export$10.F, 'Object', { assign: _objectAssign });

// 7.2.9 SameValue(x, y)
var _sameValue = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

// 19.1.3.10 Object.is(value1, value2)
var $export$11 = _export;
$export$11($export$11.S, 'Object', { is: _sameValue });

// element-closest | CC0-1.0 | github.com/jonathantneal/closest

(function (ElementProto) {
	if (typeof ElementProto.matches !== 'function') {
		ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
			var element = this;
			var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
			var index = 0;

			while (elements[index] && elements[index] !== element) {
				++index;
			}

			return Boolean(elements[index]);
		};
	}

	if (typeof ElementProto.closest !== 'function') {
		ElementProto.closest = function closest(selector) {
			var element = this;

			while (element && element.nodeType === 1) {
				if (element.matches(selector)) {
					return element;
				}

				element = element.parentNode;
			}

			return null;
		};
	}
})(window.Element.prototype);

// el.matches(selector) from MDN
if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s),
            i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;
    };
}

// el.closest(selector) from MDN
// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
if (window.Element && !Element.prototype.closest) {
    Element.prototype.closest = function (s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s),
            i,
            el = this;
        do {
            i = matches.length;
            while (--i >= 0 && matches.item(i) !== el) {}
        } while (i < 0 && (el = el.parentElement));
        return el;
    };
}

var Survey = function () {
    function Survey(name) {
        babelHelpers.classCallCheck(this, Survey);

        this.name = name;
        this.responses = [];
    }

    babelHelpers.createClass(Survey, [{
        key: "fileResponse",
        value: function fileResponse(name, text) {
            // var responses = this.responses[name] = this.responses[name] || [];
            //TODO mix in update removalID for when it was uploaded
            var entry = { survey: this.name, name: name, text: text, type: "response" };
            this.responses.push(entry);
            surveyUpdates.push(entry);
            sessionStorage.surveyUpdates = JSON.stringify(surveyUpdates);
        }
    }], [{
        key: "getSurvey",
        value: function getSurvey(name) {
            if (Survey.instances[name] === undefined) {
                var ConcreteSurvey = Survey.byName[name] || Survey.Default;
                Survey.instances[name] = new ConcreteSurvey(name);
            }
            return Survey.instances[name];
        }
    }]);
    return Survey;
}();

Survey.Default = function (_Survey) {
    babelHelpers.inherits(DefaultSurvey, _Survey);

    function DefaultSurvey() {
        babelHelpers.classCallCheck(this, DefaultSurvey);
        return babelHelpers.possibleConstructorReturn(this, (DefaultSurvey.__proto__ || Object.getPrototypeOf(DefaultSurvey)).apply(this, arguments));
    }

    return DefaultSurvey;
}(Survey);

Survey.byName = {};
Survey.instances = {};

var surveyUpdates = JSON.parse(sessionStorage.surveyUpdates || "[]");

// if no unique ID create one
var key = location.pathname;

var allPastConversation = JSON.parse(localStorage.allPastConversation || "{}");
var pastConversation = allPastConversation[key];

if (!pastConversation) {
    pastConversation = allPastConversation[key] = [];
}





/*

choice namespace + name
incomplete surveys
suggested resources
unsent complete surveys

*/

var customTags = {};
var customUpgraders = [];
var uniques = {};

var waitingFor = 1; // waiting for N ids to complete
var fireReady; // this is for resolving the upgraded promise

var upgradedFlag = Symbol('upgraded');
var UPGRADE_API = { 'upgradedCallback': true, 'upgradeCallback': true, identify: true };

var ID_NAME = 'templateId';

var incrementalTemplates = {
    get: get$1,
    set: set$1,
    unique: unique,
    define: define,
    upgradeDOM: upgradeDOM,
    upgradeElement: upgradeElement,
    upgradedElement: upgradedElement,
    ready: false,
    upgraded: new Promise(function (resolve, reject) {
        fireReady = function fireReady() {
            incrementalTemplates.ready = true;
            resolve();
        };
        //TODO if id fails, should this fail?
    })
};

function unique(tag) {
    if (!uniques[tag]) uniques[tag] = new WeakMap();
    return uniques[tag];
}

function get$1(id) {
    var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'template';

    return unique(tag)[id];
}

function set$1(id, el) {
    var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'template';

    unique(tag)[id] = el;
}

function define(tag, constructor) {
    if (typeof tag === 'string') {
        customTags[tag] = constructor;
        if (incrementalTemplates.ready) {
            Array.from(document.querySelectorAll('template')).forEach(function (template) {
                if (template[upgradedFlag]) template[tag] = constructor;
            });
        }
    } else if (typeof tag === 'function') {
        customUpgraders.push([tag, constructor]);
        //TODO if incrementalTemplates.upgraded
    }
}

function upgradeElement(el, constructor, template) {
    var callbackName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'upgradeCallback';

    var proto = constructor.prototype;
    var callback = proto[callbackName];
    var identify = proto.identify;

    Object.getOwnPropertyNames(proto).forEach(function (n) {
        if (!UPGRADE_API[n]) {
            var descr = Object.getOwnPropertyDescriptor(proto, n);
            if (descr.get || descr.set) Object.defineProperty(el, n, descr);else el[n] = proto[n];
        }
    });

    el.isFrom = constructor;
    if (callback) callback.call(el, template);

    //TODO consider what to do if there are multiple upgrades for element
    if (identify) {
        var id = identify.call(el, template);

        if (!id) {
            return;
        } // log that the template is ignored without id

        // if promise keep track on when it's done
        if (id && id.then) {
            id.then(lateSaveId);
            ++waitingFor;
        } else {
            saveId(id);
        }
    }

    function lateSaveId(id) {
        saveId(id);
        if (--waitingFor === 0) fireReady();
    }

    function saveId(id) {
        unique(el.localName)[id] = el;
        el[ID_NAME] = id;
    }
}

function upgradedElement(el, constructor, template) {
    var callbackName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'upgradedCallback';

    var callback = constructor.prototype[callbackName];

    if (callback) callback.call(el, template);
}

function upgradeDOM() {
    var dom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
    var nodeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'template[incremental]';

    Array.from(dom.querySelectorAll(nodeName)).forEach(function (template) {
        //TODO upgrade templates according to selectors starting with template template.matches(..)
        for (var tag in customTags) {
            if (tag.indexOf('template') === 0 && template.matches(tag)) {
                upgradeElement(template, customTags[tag], template);
            }
        }

        var _loop = function _loop(_tag) {
            (template.content || template).querySelectorAll(_tag).forEach(function (el) {
                return upgradeElement(el, customTags[_tag], template);
            });
        };

        for (var _tag in customTags) {
            _loop(_tag);
        }
        customUpgraders.forEach(function (upgrader) {
            var lister = upgrader[0],
                constructor = upgrader[1];

            var els = lister(template);
            els.forEach(function (el) {
                return upgradeElement(el, constructor, template);
            });
        });

        for (var _tag2 in customTags) {
            if (_tag2.indexOf('template') === 0 && template.matches(_tag2)) {
                upgradedElement(template, customTags[_tag2], template);
            }
        }

        template[upgradedFlag] = true;
    });

    if (dom === document) {
        if (--waitingFor === 0) fireReady();
    }
}

function attrs2props(attrs) {
    var rename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRename;
    var coerce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultCoerce;

    var props = {};

    //TODO use curryComputeProps to make general impl
    for (var i = 0, attr; attr = attrs[i]; i++) {
        var name = rename(attr.name);
        if (name) {
            props[name] = coerce(name, attr.value);
        }
    }

    return props;
}

function defaultCoerce(name, value) {
    return value;
}

function defaultRename(name) {
    return name !== 'children' ? name : null;
}

/*
 * Templates are based on JSONML
 *
 * The attributes object is split into `static`, `dynamic` and `timing` that describes the rendering plan.
 *
 the jsonml attributes are an array to advoid conversion for incremental-dom
 */

//TODO should templating of attributes be supported via coerce -> function -> renders with context

// TODO only skip blank text elements (w. only whitespace)
function fragment2jsonml(fragment) {
    var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { rename: null, coerce: null, baseProps: null };

    var rename = opts.rename || defaultRename;
    var coerce = opts.coerce || defaultCoerce;
    var baseProps = {};
    var base = [tagName, babelHelpers.extends({}, baseProps, attrs2props(attrs, rename, coerce))];
    //TODO assign keys

    fillInJSONML(base, fragment.childNodes, rename, coerce, skipText);

    function skipText(node) {
        return node.nodeType === 1;
    }

    return base;
}

function element2jsonml(el) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { rename: null, coerce: null, baseProps: null };

    var rename = opts.rename || defaultRename;
    var coerce = opts.coerce || defaultCoerce;
    var baseProps = {};
    var base = [el.localName, babelHelpers.extends({}, baseProps, attrs2props(el.attributes, rename, coerce, el.isFrom || el.constructor, el.localName))];
    //TODO assign keys

    fillInJSONML(base, el.childNodes, rename, coerce, defaultChildFilter);

    return base;
}

function defaultChildFilter(node) {
    return true;
}

function fillInJSONML(parent, childNodes, rename, coerce) {
    var filter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultChildFilter;

    for (var i = 0, c; c = childNodes[i]; ++i) {
        // TODO turn expressions into functions
        if (!filter(c)) continue;

        switch (c.nodeType) {
            case 1:
                var json = [c.localName, attrs2props(c.attributes, rename, coerce, c.isFrom || c.constructor, c.localName)];
                parent.push(json);
                fillInJSONML(json, c.childNodes, rename, coerce, defaultChildFilter);
                break;
            case 3:
                parent.push(c.nodeValue);
                break;
            // ignoreing CDATA & comments for now
        }
    }
}

var BlockTemplate = function () {
    function BlockTemplate() {
        babelHelpers.classCallCheck(this, BlockTemplate);
    }

    babelHelpers.createClass(BlockTemplate, [{
        key: 'upgradeCallback',
        value: function upgradeCallback() {
            //TODO shortcut keys (1..9)
            this.topic = this.getAttribute('topic');

            if (this.topic && this.id) {
                cleanBlock(this.content || this);
                // interpret comments for processing instructions
            }
        }
    }, {
        key: 'upgradedCallback',
        value: function upgradedCallback() {
            if (this.topic && this.id) {
                cleanBlock(this.content || this);
            }
            this.statements = Array.from((this.content || this).querySelectorAll('.statement'));
        }
    }, {
        key: 'renderJSONML',
        value: function renderJSONML(state) {
            return this.jsonml; //TODO renderTemplate(this.jsonml, state, meta)
        }
    }, {
        key: 'identify',
        value: function identify() {
            var id = this.id || this.getAttribute('content-id');
            this.removeAttribute('id');
            return id; // filed under this ID
        }
    }, {
        key: 'jsonml',
        get: function get() {
            //TODO interpret attributes to make the output attributes. class, id,
            var className = 'their left-thread';
            var baseProps = { className: className };

            function rename(name) {
                if (name === 'class') return 'className';
                return name;
            }
            function coerce(name, value) {
                if (name === 'className') return value + ' ' + className;
                return value;
            }
            return this._jsonml ? this._jsonml : this._jsonml = fragment2jsonml(this.content || this, 'conversation-block', this.attributes, { rename: rename, coerce: coerce, baseProps: baseProps });
        }
    }]);
    return BlockTemplate;
}();

function cleanBlock(elem) {

    // remove empty paragraphs
    Array.from(elem.querySelectorAll('p')).forEach(function (child) {
        var text = child.textContent.replace(/\s/g, '');
        if (!text && justWhitespace(child.children)) {
            if (child.localName === 'p') {
                child.parentNode.removeChild(child);
            }
        }
    });

    // might do something about HR, quotes, FIELDSET

    function justWhitespace(children) {
        for (var i = 0, l = children.length; i < l; ++i) {
            switch (children[i].localName) {
                case 'wbr':
                case 'br':
                    break;
                default:
                    return false; // non-whitespace child
            }
        }
        return true;
    }
}

// import recordVDom from '../dom/recordVDom';

/*
    Statement phases

    1. hidden + class=statement
    2. class=statement pending-statement
    3. class=statement shown-statement

 */
var Statement = function () {
    function Statement() {
        babelHelpers.classCallCheck(this, Statement);
    }

    babelHelpers.createClass(Statement, [{
        key: 'upgradeCallback',
        value: function upgradeCallback(template) {
            this.classList.add('statement');
            //TODO plan render with JSONML tree
            // this.recording = recordVDom(this, excludeThreadAction);
        }
    }]);
    return Statement;
}();

Statement.classesWhileShowing = ['showing-statement'];
Statement.classesWhilePending = ['pending-statement'];
Statement.timing = { delayBetween: 1.4, pendingPeriod: .6 };

/**
*
*  Secure Hash Algorithm (SHA1)

*  http://www.webtoolkit.info/

*

**/

function SHA1(msg) {

    function rotate_left(n, s) {

        var t4 = n << s | n >>> 32 - s;

        return t4;
    }

    function lsb_hex(val) {

        var str = "";

        var i;

        var vh;

        var vl;

        for (i = 0; i <= 6; i += 2) {

            vh = val >>> i * 4 + 4 & 0x0f;

            vl = val >>> i * 4 & 0x0f;

            str += vh.toString(16) + vl.toString(16);
        }

        return str;
    }

    function cvt_hex(val) {

        var str = "";

        var i;

        var v;

        for (i = 7; i >= 0; i--) {

            v = val >>> i * 4 & 0x0f;

            str += v.toString(16);
        }

        return str;
    }

    function Utf8Encode(string) {

        string = string.replace(/\r\n/g, "\n");

        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {

                utftext += String.fromCharCode(c);
            } else if (c > 127 && c < 2048) {

                utftext += String.fromCharCode(c >> 6 | 192);

                utftext += String.fromCharCode(c & 63 | 128);
            } else {

                utftext += String.fromCharCode(c >> 12 | 224);

                utftext += String.fromCharCode(c >> 6 & 63 | 128);

                utftext += String.fromCharCode(c & 63 | 128);
            }
        }

        return utftext;
    }

    var blockstart;

    var i, j;

    var W = new Array(80);

    var H0 = 0x67452301;

    var H1 = 0xEFCDAB89;

    var H2 = 0x98BADCFE;

    var H3 = 0x10325476;

    var H4 = 0xC3D2E1F0;

    var A, B, C, D, E;

    var temp;

    msg = Utf8Encode(msg);

    var msg_len = msg.length;

    var word_array = new Array();

    for (i = 0; i < msg_len - 3; i += 4) {

        j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 | msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);

        word_array.push(j);
    }

    switch (msg_len % 4) {

        case 0:

            i = 0x080000000;

            break;

        case 1:

            i = msg.charCodeAt(msg_len - 1) << 24 | 0x0800000;

            break;

        case 2:

            i = msg.charCodeAt(msg_len - 2) << 24 | msg.charCodeAt(msg_len - 1) << 16 | 0x08000;

            break;

        case 3:

            i = msg.charCodeAt(msg_len - 3) << 24 | msg.charCodeAt(msg_len - 2) << 16 | msg.charCodeAt(msg_len - 1) << 8 | 0x80;

            break;

    }

    word_array.push(i);

    while (word_array.length % 16 != 14) {
        word_array.push(0);
    }word_array.push(msg_len >>> 29);

    word_array.push(msg_len << 3 & 0x0ffffffff);

    for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {

        for (i = 0; i < 16; i++) {
            W[i] = word_array[blockstart + i];
        }for (i = 16; i <= 79; i++) {
            W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        }A = H0;

        B = H1;

        C = H2;

        D = H3;

        E = H4;

        for (i = 0; i <= 19; i++) {

            temp = rotate_left(A, 5) + (B & C | ~B & D) + E + W[i] + 0x5A827999 & 0x0ffffffff;

            E = D;

            D = C;

            C = rotate_left(B, 30);

            B = A;

            A = temp;
        }

        for (i = 20; i <= 39; i++) {

            temp = rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1 & 0x0ffffffff;

            E = D;

            D = C;

            C = rotate_left(B, 30);

            B = A;

            A = temp;
        }

        for (i = 40; i <= 59; i++) {

            temp = rotate_left(A, 5) + (B & C | B & D | C & D) + E + W[i] + 0x8F1BBCDC & 0x0ffffffff;

            E = D;

            D = C;

            C = rotate_left(B, 30);

            B = A;

            A = temp;
        }

        for (i = 60; i <= 79; i++) {

            temp = rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6 & 0x0ffffffff;

            E = D;

            D = C;

            C = rotate_left(B, 30);

            B = A;

            A = temp;
        }

        H0 = H0 + A & 0x0ffffffff;

        H1 = H1 + B & 0x0ffffffff;

        H2 = H2 + C & 0x0ffffffff;

        H3 = H3 + D & 0x0ffffffff;

        H4 = H4 + E & 0x0ffffffff;
    }

    var temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);

    return temp.toLowerCase();
}

function fieldList(action) {
    var fields = Array.from(action.querySelectorAll(Object.keys(FIELDS).join(',')));

    fields.forEach(function (field) {
        if (!field.name) {
            field.setAttribute('name', makeUniqueName());
        }
    });
    return fields;
}

var uniqueName = 1;

function makeUniqueName() {
    return uniqueName++;
}

var FIELDS = {
    'input': {},

    'select': {},

    'textarea': {}
};

// import hashString from '../data/hashString';
/*
 choiceRequired for elements `input`, `select`, `textarea`.
 */
function annotateMarkup(state) {

    // replaces elements filled in for the value.
    return function (elJSON) {

        // text node
        if (typeof elJSON === 'string') return elJSON.trim();

        // input/select/textarea
        if (FIELDS[elJSON[0]]) {
            var name = elJSON[1].name;
            if (name in state) return state[name];

            var trimmed = elJSON.map(trimEntry).filter(function (entry) {
                return entry;
            });
            //TODO set default value

            trimmed.choiceRequired = true;
            return trimmed;
        }

        // elements marked hint are not part of the resulting text.
        // TODO jsontml.hasAttribute(el) if (el.hasAttribute('hint')) return '';

        // other element
        return elJSON;
    };

    function trimEntry(entry) {
        // text node
        if (typeof entry === 'string') return entry.replace('\n', '').trim();
        return entry;
    }
}

function responsePartsToTemplate(part) {
    if (typeof part === 'string') return part;

    return '#' + part[1].name;
}

var ActionTemplate = function () {
    function ActionTemplate() {
        babelHelpers.classCallCheck(this, ActionTemplate);
    }

    babelHelpers.createClass(ActionTemplate, [{
        key: 'upgradeCallback',
        value: function upgradeCallback(template) {
            var _this = this;

            if (!this.hasAttribute('topic')) this.setAttribute('topic', template.topic);
            this.parentNode.removeChild(this);

            if (template.actions == undefined) template.actions = [];
            template.actions.push(this);

            this.fieldNames = [];
            var fields = {};
            fieldList(this).forEach(function (field) {
                _this.fieldNames.push(field.name);
                fields[field.name] = field;
                _this.fields = fields;

                var upgradeByType = _this['upgrade ' + field.localName];
                if (upgradeByType) upgradeByType.call(_this, field);
            });

            // the content can be rendered easily with recording
            // this.recording = recordIncrementalDom(this);

            // JSONML replaces recording
            this.partsList = element2jsonml(this).slice(2);
            this.responseTemplate = this.partsList.map(responsePartsToTemplate);
            this.responseTemplate.render = function (state) {
                return this.map(function (part) {
                    return part.charAt(0) === '#' ? state[part.substring(1)] : part;
                }).join('');
            };
        }
    }, {
        key: 'upgrade select',
        value: function upgradeSelect(select) {
            switch (select.getAttribute('type')) {
                case 'timeline':
                    return;
                default:
                    var blankOption = document.createElement('option');
                    blankOption.textContent = '';
                    blankOption.value = '';
                    select.insertBefore(blankOption, select.firstElementChild);
                    select.value = '';
                    return;
            }
        }

        /* @param state The conflux state for the block */

    }, {
        key: 'partiallyFilledContent',
        value: function partiallyFilledContent(state) {
            var content = this.partsList.map(annotateMarkup(state)).filter(function (part) {
                return part;
            });
            for (var i = 0, entry; entry = content[i]; ++i) {
                if (entry.choiceRequired) break;
            }
            content.staticLength = i;
            return content;
        }
    }, {
        key: 'identify',
        value: function identify(template) {
            var id = this.getAttribute('id');
            if (id) return template.templateId + ':' + id;else {
                // innerHTML + attributes
                // make sha hash
                return SHA1(this.innerHTML + this.getAttribute('type'), 'SHA-256');
            }
        }
    }, {
        key: 'getRenderProps',
        value: function getRenderProps(responseProps, block) {
            //TODO blend in State for the inputs by name (state[action input name])
            var inputs = this.partsList.map(describeInput(responseProps, block)).filter(function (part) {
                return part;
            });

            //TODO scan inputs to see if past the preroll inputs
            // const enableMessage = inputs.reduce((result, input) => input.type === 'message' ? { input, actionId: this.templateId } : false, false);
            var enableMessage = this.getAttribute('type') === 'message' ? {
                actionId: this.templateId
            } : false;

            return {
                templateId: this.templateId,
                beta: this.hasAttribute('beta'),
                type: this.getAttribute('type'),
                nextBlockId: this.getAttribute('block'),
                topic: this.getAttribute('topic') || responseProps ? responseProps.topic : '',
                enableMessage: enableMessage,
                inputs: inputs,
                full: responseProps.actionsId === block.templateId,
                text: this.innerText,

                logEvent: function logEvent(event) {
                    console.info('click', event);
                },
                changeEvent: function changeEvent(event) {
                    console.info('change', event);
                }
            };
        }
    }]);
    return ActionTemplate;
}();

function describeInput(props, state) {
    return function (input) {
        // text node
        if (typeof input === 'string') return trimEntry(input);

        // element
        if (FIELDS[input[0]]) {
            var name = input[1].name;

            return {
                state: state[name],
                tag: input[0],
                name: name,
                attrs: input[1],
                children: input.slice(2, 100).map(trimEntry).filter(function (input) {
                    return input;
                })
            };
        }

        return input;
    };

    function trimEntry(entry) {
        // text node
        if (typeof entry === 'string') return entry.replace('\n', '').trim();
        return entry;
    }
}

/**
 * @module Inferno-Shared
 */ /** TypeDoc Comment */
var NO_OP$1 = "$NO_OP";
var ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
// This should be boolean and not reference to window.document
var isBrowser = !!(typeof window !== "undefined" && window.document);
// this is MUCH faster than .constructor === Array and instanceof Array
// in Node 7 and the later versions of V8, slower in older versions though
var isArray$3 = Array.isArray;
function isStatefulComponent(o) {
    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);
}
function isStringOrNumber(o) {
    var type = typeof o === "undefined" ? "undefined" : babelHelpers.typeof(o);
    return type === "string" || type === "number";
}
function isNullOrUndef(o) {
    return isUndefined(o) || isNull(o);
}
function isInvalid(o) {
    return isNull(o) || o === false || isTrue(o) || isUndefined(o);
}
function isFunction(o) {
    return typeof o === "function";
}
function isString(o) {
    return typeof o === "string";
}
function isNumber(o) {
    return typeof o === "number";
}
function isNull(o) {
    return o === null;
}
function isTrue(o) {
    return o === true;
}
function isUndefined(o) {
    return o === void 0;
}
function isObject$5(o) {
    return (typeof o === "undefined" ? "undefined" : babelHelpers.typeof(o)) === "object";
}
function throwError(message) {
    if (!message) {
        message = ERROR_MSG;
    }
    throw new Error("Inferno Error: " + message);
}
function warning(message) {
    // tslint:disable-next-line:no-console
    console.warn(message);
}
function combineFrom(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}
function Lifecycle() {
    this.listeners = [];
}
Lifecycle.prototype.addListener = function addListener(callback) {
    this.listeners.push(callback);
};
Lifecycle.prototype.trigger = function trigger() {
    var listeners = this.listeners;
    var listener;
    // We need to remove current listener from array when calling it, because more listeners might be added
    while (listener = listeners.shift()) {
        listener();
    }
};

/**
 * @module Inferno
 */ /** TypeDoc Comment */
var options = {
    afterMount: null,
    afterRender: null,
    afterUpdate: null,
    beforeRender: null,
    beforeUnmount: null,
    createVNode: null,
    findDOMNodeEnabled: false,
    recyclingEnabled: false,
    roots: []
};

/**
 * @module Inferno
 */ /** TypeDoc Comment */
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var svgNS = "http://www.w3.org/2000/svg";
var strictProps = new Set();
strictProps.add("volume");
strictProps.add("defaultChecked");
var booleanProps = new Set();
booleanProps.add("muted");
booleanProps.add("scoped");
booleanProps.add("loop");
booleanProps.add("open");
booleanProps.add("checked");
booleanProps.add("default");
booleanProps.add("capture");
booleanProps.add("disabled");
booleanProps.add("readOnly");
booleanProps.add("required");
booleanProps.add("autoplay");
booleanProps.add("controls");
booleanProps.add("seamless");
booleanProps.add("reversed");
booleanProps.add("allowfullscreen");
booleanProps.add("novalidate");
booleanProps.add("hidden");
booleanProps.add("autoFocus");
booleanProps.add("selected");
booleanProps.add("indeterminate");
var namespaces = new Map();
namespaces.set("xlink:href", xlinkNS);
namespaces.set("xlink:arcrole", xlinkNS);
namespaces.set("xlink:actuate", xlinkNS);
namespaces.set("xlink:show", xlinkNS);
namespaces.set("xlink:role", xlinkNS);
namespaces.set("xlink:title", xlinkNS);
namespaces.set("xlink:type", xlinkNS);
namespaces.set("xml:base", xmlNS);
namespaces.set("xml:lang", xmlNS);
namespaces.set("xml:space", xmlNS);
var isUnitlessNumber = new Set();
isUnitlessNumber.add("animationIterationCount");
isUnitlessNumber.add("borderImageOutset");
isUnitlessNumber.add("borderImageSlice");
isUnitlessNumber.add("borderImageWidth");
isUnitlessNumber.add("boxFlex");
isUnitlessNumber.add("boxFlexGroup");
isUnitlessNumber.add("boxOrdinalGroup");
isUnitlessNumber.add("columnCount");
isUnitlessNumber.add("flex");
isUnitlessNumber.add("flexGrow");
isUnitlessNumber.add("flexPositive");
isUnitlessNumber.add("flexShrink");
isUnitlessNumber.add("flexNegative");
isUnitlessNumber.add("flexOrder");
isUnitlessNumber.add("gridRow");
isUnitlessNumber.add("gridColumn");
isUnitlessNumber.add("fontWeight");
isUnitlessNumber.add("lineClamp");
isUnitlessNumber.add("lineHeight");
isUnitlessNumber.add("opacity");
isUnitlessNumber.add("order");
isUnitlessNumber.add("orphans");
isUnitlessNumber.add("tabSize");
isUnitlessNumber.add("widows");
isUnitlessNumber.add("zIndex");
isUnitlessNumber.add("zoom");
isUnitlessNumber.add("fillOpacity");
isUnitlessNumber.add("floodOpacity");
isUnitlessNumber.add("stopOpacity");
isUnitlessNumber.add("strokeDasharray");
isUnitlessNumber.add("strokeDashoffset");
isUnitlessNumber.add("strokeMiterlimit");
isUnitlessNumber.add("strokeOpacity");
isUnitlessNumber.add("strokeWidth");
var skipProps = new Set();
skipProps.add("children");
skipProps.add("childrenType");
skipProps.add("defaultValue");
skipProps.add("ref");
skipProps.add("key");
skipProps.add("checked");
skipProps.add("multiple");
var delegatedEvents = new Set();
delegatedEvents.add("onClick");
delegatedEvents.add("onMouseDown");
delegatedEvents.add("onMouseUp");
delegatedEvents.add("onMouseMove");
delegatedEvents.add("onSubmit");
delegatedEvents.add("onDblClick");
delegatedEvents.add("onKeyDown");
delegatedEvents.add("onKeyUp");
delegatedEvents.add("onKeyPress");

/**
 * @module Inferno
 */ /** TypeDoc Comment */
var isiOS = isBrowser && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
var delegatedEvents$1 = new Map();
function handleEvent(name, lastEvent, nextEvent, dom) {
    var delegatedRoots = delegatedEvents$1.get(name);
    if (nextEvent) {
        if (!delegatedRoots) {
            delegatedRoots = { items: new Map(), docEvent: null };
            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);
            delegatedEvents$1.set(name, delegatedRoots);
        }
        if (!lastEvent) {
            if (isiOS && name === "onClick") {
                trapClickOnNonInteractiveElement(dom);
            }
        }
        delegatedRoots.items.set(dom, nextEvent);
    } else if (delegatedRoots) {
        var items = delegatedRoots.items;
        if (items.delete(dom)) {
            // If any items were deleted, check if listener need to be removed
            if (items.size === 0) {
                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);
                delegatedEvents$1.delete(name);
            }
        }
    }
}
function dispatchEvents(event, target, items, count, isClick, eventData) {
    var dom = target;
    while (count > 0) {
        var eventsToTrigger = items.get(dom);
        if (eventsToTrigger) {
            count--;
            // linkEvent object
            eventData.dom = dom;
            if (eventsToTrigger.event) {
                eventsToTrigger.event(eventsToTrigger.data, event);
            } else {
                eventsToTrigger(event);
            }
            if (event.cancelBubble) {
                return;
            }
        }
        dom = dom.parentNode;
        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
        // because the event listener is on document.body
        // Don't process clicks on disabled elements
        if (dom === null || isClick && dom.disabled) {
            return;
        }
    }
}
function normalizeEventName(name) {
    return name.substr(2).toLowerCase();
}
function stopPropagation() {
    this.cancelBubble = true;
    this.stopImmediatePropagation();
}
function attachEventToDocument(name, delegatedRoots) {
    var docEvent = function docEvent(event) {
        var count = delegatedRoots.items.size;
        if (count > 0) {
            event.stopPropagation = stopPropagation;
            // Event data needs to be object to save reference to currentTarget getter
            var eventData = {
                dom: document
            };
            try {
                Object.defineProperty(event, "currentTarget", {
                    configurable: true,
                    get: function get() {
                        return eventData.dom;
                    }
                });
            } catch (e) {
                /* safari7 and phantomJS will crash */
            }
            dispatchEvents(event, event.target, delegatedRoots.items, count, event.type === "click", eventData);
        }
    };
    document.addEventListener(normalizeEventName(name), docEvent);
    return docEvent;
}
// tslint:disable-next-line:no-empty
function emptyFn() {}
function trapClickOnNonInteractiveElement(dom) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    // Just set it using the onclick property so that we don't have to manage any
    // bookkeeping for it. Not sure if we need to clear it when the listener is
    // removed.
    // TODO: Only do this for the relevant Safaris maybe?
    dom.onclick = emptyFn;
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function isCheckedType(type) {
    return type === "checkbox" || type === "radio";
}
function onTextInputChange(e) {
    var vNode = this.vNode;
    var props = vNode.props || EMPTY_OBJ$1;
    var dom = vNode.dom;
    var previousValue = props.value;
    if (props.onInput) {
        var event = props.onInput;
        if (event.event) {
            event.event(event.data, e);
        } else {
            event(e);
        }
    } else if (props.oninput) {
        props.oninput(e);
    }
    // the user may have updated the vNode from the above onInput events syncronously
    // so we need to get it from the context of `this` again
    var newVNode = this.vNode;
    var newProps = newVNode.props || EMPTY_OBJ$1;
    // If render is going async there is no value change yet, it will come back to process input soon
    if (previousValue !== newProps.value) {
        // When this happens we need to store current cursor position and restore it, to avoid jumping
        applyValue(newProps, dom);
    }
}
function wrappedOnChange(e) {
    var props = this.vNode.props || EMPTY_OBJ$1;
    var event = props.onChange;
    if (event.event) {
        event.event(event.data, e);
    } else {
        event(e);
    }
}
function onCheckboxChange(e) {
    e.stopPropagation(); // This click should not propagate its for internal use
    var vNode = this.vNode;
    var props = vNode.props || EMPTY_OBJ$1;
    var dom = vNode.dom;
    if (props.onClick) {
        var event = props.onClick;
        if (event.event) {
            event.event(event.data, e);
        } else {
            event(e);
        }
    } else if (props.onclick) {
        props.onclick(e);
    }
    // the user may have updated the vNode from the above onInput events syncronously
    // so we need to get it from the context of `this` again
    var newVNode = this.vNode;
    var newProps = newVNode.props || EMPTY_OBJ$1;
    // If render is going async there is no value change yet, it will come back to process input soon
    applyValue(newProps, dom);
}
function processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    applyValue(nextPropsOrEmpty, dom);
    if (isControlled) {
        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's
        if (mounting) {
            if (isCheckedType(nextPropsOrEmpty.type)) {
                dom.onclick = onCheckboxChange;
                dom.onclick.wrapped = true;
            } else {
                dom.oninput = onTextInputChange;
                dom.oninput.wrapped = true;
            }
            if (nextPropsOrEmpty.onChange) {
                dom.onchange = wrappedOnChange;
                dom.onchange.wrapped = true;
            }
        }
    }
}
function applyValue(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef(value);
    if (type && type !== dom.type) {
        dom.setAttribute("type", type);
    }
    if (multiple && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!isNullOrUndef(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + "";
    }
    if (isCheckedType(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    } else {
        if (hasValue && dom.value !== value) {
            dom.defaultValue = value;
            dom.value = value;
        } else if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function updateChildOptionGroup(vNode, value) {
    var type = vNode.type;
    if (type === "optgroup") {
        var children = vNode.children;
        if (isArray$3(children)) {
            for (var i = 0, len = children.length; i < len; i++) {
                updateChildOption(children[i], value);
            }
        } else if (isVNode(children)) {
            updateChildOption(children, value);
        }
    } else {
        updateChildOption(vNode, value);
    }
}
function updateChildOption(vNode, value) {
    var props = vNode.props || EMPTY_OBJ$1;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (isArray$3(value) && value.indexOf(props.value) !== -1 || props.value === value) {
        dom.selected = true;
    } else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {
        dom.selected = props.selected || false;
    }
}
function onSelectChange(e) {
    var vNode = this.vNode;
    var props = vNode.props || EMPTY_OBJ$1;
    var dom = vNode.dom;
    var previousValue = props.value;
    if (props.onChange) {
        var event = props.onChange;
        if (event.event) {
            event.event(event.data, e);
        } else {
            event(e);
        }
    } else if (props.onchange) {
        props.onchange(e);
    }
    // the user may have updated the vNode from the above onInput events syncronously
    // so we need to get it from the context of `this` again
    var newVNode = this.vNode;
    var newProps = newVNode.props || EMPTY_OBJ$1;
    // If render is going async there is no value change yet, it will come back to process input soon
    if (previousValue !== newProps.value) {
        // When this happens we need to store current cursor position and restore it, to avoid jumping
        applyValue$1(newVNode, dom, newProps, false);
    }
}
function processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    applyValue$1(vNode, dom, nextPropsOrEmpty, mounting);
    if (isControlled) {
        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's
        if (mounting) {
            dom.onchange = onSelectChange;
            dom.onchange.wrapped = true;
        }
    }
}
function applyValue$1(vNode, dom, nextPropsOrEmpty, mounting) {
    if (nextPropsOrEmpty.multiple !== dom.multiple) {
        dom.multiple = nextPropsOrEmpty.multiple;
    }
    var children = vNode.children;
    if (!isInvalid(children)) {
        var value = nextPropsOrEmpty.value;
        if (mounting && isNullOrUndef(value)) {
            value = nextPropsOrEmpty.defaultValue;
        }
        if (isArray$3(children)) {
            for (var i = 0, len = children.length; i < len; i++) {
                updateChildOptionGroup(children[i], value);
            }
        } else if (isVNode(children)) {
            updateChildOptionGroup(children, value);
        }
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function wrappedOnChange$1(e) {
    var props = this.vNode.props || EMPTY_OBJ$1;
    var event = props.onChange;
    if (event.event) {
        event.event(event.data, e);
    } else {
        event(e);
    }
}
function onTextareaInputChange(e) {
    var vNode = this.vNode;
    var props = vNode.props || EMPTY_OBJ$1;
    var previousValue = props.value;
    if (props.onInput) {
        var event = props.onInput;
        if (event.event) {
            event.event(event.data, e);
        } else {
            event(e);
        }
    } else if (props.oninput) {
        props.oninput(e);
    }
    // the user may have updated the vNode from the above onInput events syncronously
    // so we need to get it from the context of `this` again
    var newVNode = this.vNode;
    var newProps = newVNode.props || EMPTY_OBJ$1;
    // If render is going async there is no value change yet, it will come back to process input soon
    if (previousValue !== newProps.value) {
        // When this happens we need to store current cursor position and restore it, to avoid jumping
        applyValue$2(newVNode, vNode.dom, false);
    }
}
function processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    applyValue$2(nextPropsOrEmpty, dom, mounting);
    if (isControlled) {
        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's
        if (mounting) {
            dom.oninput = onTextareaInputChange;
            dom.oninput.wrapped = true;
            if (nextPropsOrEmpty.onChange) {
                dom.onchange = wrappedOnChange$1;
                dom.onchange.wrapped = true;
            }
        }
    }
}
function applyValue$2(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef(value)) {
        if (mounting) {
            var defaultValue = nextPropsOrEmpty.defaultValue;
            if (!isNullOrUndef(defaultValue)) {
                if (defaultValue !== domValue) {
                    dom.defaultValue = defaultValue;
                    dom.value = defaultValue;
                }
            } else if (domValue !== "") {
                dom.defaultValue = "";
                dom.value = "";
            }
        }
    } else {
        /* There is value so keep it controlled */
        if (domValue !== value) {
            dom.defaultValue = value;
            dom.value = value;
        }
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
/**
 * There is currently no support for switching same input between controlled and nonControlled
 * If that ever becomes a real issue, then re design controlled elements
 * Currently user must choose either controlled or non-controlled and stick with that
 */
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    if (flags & 512 /* InputElement */) {
            processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled);
        }
    if (flags & 2048 /* SelectElement */) {
            processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled);
        }
    if (flags & 1024 /* TextareaElement */) {
            processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled);
        }
}
function isControlledFormElement(nextPropsOrEmpty) {
    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function normalizeChildNodes(parentDom) {
    var dom = parentDom.firstChild;
    while (dom) {
        if (dom.nodeType === 8) {
            if (dom.data === "!") {
                var placeholder = document.createTextNode("");
                parentDom.replaceChild(placeholder, dom);
                dom = dom.nextSibling;
            } else {
                var lastDom = dom.previousSibling;
                parentDom.removeChild(dom);
                dom = lastDom || parentDom.firstChild;
            }
        } else {
            dom = dom.nextSibling;
        }
    }
}
function hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {
    var type = vNode.type;
    var ref = vNode.ref;
    var props = vNode.props || EMPTY_OBJ$1;
    if (isClass) {
        var _isSVG = dom.namespaceURI === svgNS;
        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG, lifecycle);
        var input = instance._lastInput;
        instance._vNode = vNode;
        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);
        vNode.dom = input.dom;
        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);
        instance._updating = false; // Mount finished allow going sync
        if (options.findDOMNodeEnabled) {
            componentToDOMNodeMap.set(instance, dom);
        }
    } else {
        var input$1 = createFunctionalComponentInput(vNode, type, props, context);
        hydrate(input$1, dom, lifecycle, context, isSVG);
        vNode.children = input$1;
        vNode.dom = input$1.dom;
        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);
    }
    return dom;
}
function hydrateElement(vNode, dom, lifecycle, context, isSVG) {
    var children = vNode.children;
    var props = vNode.props;
    var className = vNode.className;
    var flags = vNode.flags;
    var ref = vNode.ref;
    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;
    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {
        {
            warning("Inferno hydration: Server-side markup doesn't match client-side markup or Initial render target is not empty");
        }
        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);
        vNode.dom = newDom;
        replaceChild(dom.parentNode, newDom, dom);
        return newDom;
    }
    vNode.dom = dom;
    if (!isInvalid(children)) {
        hydrateChildren(children, dom, lifecycle, context, isSVG);
    } else if (dom.firstChild !== null && !isSamePropsInnerHTML(dom, props)) {
        dom.textContent = ""; // dom has content, but VNode has no children remove everything from DOM
    }
    if (props) {
        var hasControlledValue = false;
        var isFormElement = (flags & 3584 /* FormElement */) > 0;
        if (isFormElement) {
            hasControlledValue = isControlledFormElement(props);
        }
        for (var prop in props) {
            // do not add a hasOwnProperty check here, it affects performance
            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);
        }
        if (isFormElement) {
            processElement(flags, vNode, dom, props, true, hasControlledValue);
        }
    }
    if (!isNullOrUndef(className)) {
        if (isSVG) {
            dom.setAttribute("class", className);
        } else {
            dom.className = className;
        }
    } else {
        if (dom.className !== "") {
            dom.removeAttribute("class");
        }
    }
    if (ref) {
        mountRef(dom, ref, lifecycle);
    }
    return dom;
}
function hydrateChildren(children, parentDom, lifecycle, context, isSVG) {
    normalizeChildNodes(parentDom);
    var dom = parentDom.firstChild;
    if (isStringOrNumber(children)) {
        if (!isNull(dom) && dom.nodeType === 3) {
            if (dom.nodeValue !== children) {
                dom.nodeValue = children;
            }
        } else if (children === "") {
            parentDom.appendChild(document.createTextNode(""));
        } else {
            parentDom.textContent = children;
        }
        if (!isNull(dom)) {
            dom = dom.nextSibling;
        }
    } else if (isArray$3(children)) {
        for (var i = 0, len = children.length; i < len; i++) {
            var child = children[i];
            if (!isNull(child) && isObject$5(child)) {
                if (!isNull(dom)) {
                    var nextSibling = dom.nextSibling;
                    hydrate(child, dom, lifecycle, context, isSVG);
                    dom = nextSibling;
                } else {
                    mount(child, parentDom, lifecycle, context, isSVG);
                }
            }
        }
    } else {
        // It's VNode
        if (!isNull(dom)) {
            hydrate(children, dom, lifecycle, context, isSVG);
            dom = dom.nextSibling;
        } else {
            mount(children, parentDom, lifecycle, context, isSVG);
        }
    }
    // clear any other DOM nodes, there should be only a single entry for the root
    while (dom) {
        var nextSibling$1 = dom.nextSibling;
        parentDom.removeChild(dom);
        dom = nextSibling$1;
    }
}
function hydrateText(vNode, dom) {
    if (dom.nodeType !== 3) {
        var newDom = mountText(vNode, null);
        vNode.dom = newDom;
        replaceChild(dom.parentNode, newDom, dom);
        return newDom;
    }
    var text = vNode.children;
    if (dom.nodeValue !== text) {
        dom.nodeValue = text;
    }
    vNode.dom = dom;
    return dom;
}
function hydrateVoid(vNode, dom) {
    vNode.dom = dom;
    return dom;
}
function hydrate(vNode, dom, lifecycle, context, isSVG) {
    var flags = vNode.flags;
    if (flags & 28 /* Component */) {
            hydrateComponent(vNode, dom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);
        } else if (flags & 3970 /* Element */) {
            hydrateElement(vNode, dom, lifecycle, context, isSVG);
        } else if (flags & 1 /* Text */) {
            hydrateText(vNode, dom);
        } else if (flags & 4096 /* Void */) {
            hydrateVoid(vNode, dom);
        } else {
        {
            throwError("hydrate() expects a valid VNode, instead it received an object with the type \"" + (typeof vNode === "undefined" ? "undefined" : babelHelpers.typeof(vNode)) + "\".");
        }
        throwError();
    }
}
function hydrateRoot(input, parentDom, lifecycle) {
    if (!isNull(parentDom)) {
        var dom = parentDom.firstChild;
        if (!isNull(dom)) {
            hydrate(input, dom, lifecycle, EMPTY_OBJ$1, false);
            dom = parentDom.firstChild;
            // clear any other DOM nodes, there should be only a single entry for the root
            while (dom = dom.nextSibling) {
                parentDom.removeChild(dom);
            }
            return true;
        }
    }
    return false;
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
var componentPools = new Map();
var elementPools = new Map();
function recycleElement(vNode, lifecycle, context, isSVG) {
    var tag = vNode.type;
    var pools = elementPools.get(tag);
    if (!isUndefined(pools)) {
        var key = vNode.key;
        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);
        if (!isUndefined(pool)) {
            var recycledVNode = pool.pop();
            if (!isUndefined(recycledVNode)) {
                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);
                return vNode.dom;
            }
        }
    }
    return null;
}
function poolElement(vNode) {
    var tag = vNode.type;
    var key = vNode.key;
    var pools = elementPools.get(tag);
    if (isUndefined(pools)) {
        pools = {
            keyed: new Map(),
            nonKeyed: []
        };
        elementPools.set(tag, pools);
    }
    if (isNull(key)) {
        pools.nonKeyed.push(vNode);
    } else {
        var pool = pools.keyed.get(key);
        if (isUndefined(pool)) {
            pool = [];
            pools.keyed.set(key, pool);
        }
        pool.push(vNode);
    }
}
function recycleComponent(vNode, lifecycle, context, isSVG) {
    var type = vNode.type;
    var pools = componentPools.get(type);
    if (!isUndefined(pools)) {
        var key = vNode.key;
        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);
        if (!isUndefined(pool)) {
            var recycledVNode = pool.pop();
            if (!isUndefined(recycledVNode)) {
                var flags = vNode.flags;
                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0, true);
                if (!failed) {
                    return vNode.dom;
                }
            }
        }
    }
    return null;
}
function poolComponent(vNode) {
    var hooks = vNode.ref;
    var nonRecycleHooks = hooks && (hooks.onComponentWillMount || hooks.onComponentWillUnmount || hooks.onComponentDidMount || hooks.onComponentWillUpdate || hooks.onComponentDidUpdate);
    if (nonRecycleHooks) {
        return;
    }
    var type = vNode.type;
    var key = vNode.key;
    var pools = componentPools.get(type);
    if (isUndefined(pools)) {
        pools = {
            keyed: new Map(),
            nonKeyed: []
        };
        componentPools.set(type, pools);
    }
    if (isNull(key)) {
        pools.nonKeyed.push(vNode);
    } else {
        var pool = pools.keyed.get(key);
        if (isUndefined(pool)) {
            pool = [];
            pools.keyed.set(key, pool);
        }
        pool.push(vNode);
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {
    var flags = vNode.flags;
    var dom = vNode.dom;
    if (flags & 28 /* Component */) {
            var instance = vNode.children;
            var isStatefulComponent$$1 = (flags & 4 /* ComponentClass */) > 0;
            var props = vNode.props || EMPTY_OBJ$1;
            var ref = vNode.ref;
            if (!isRecycling) {
                if (isStatefulComponent$$1) {
                    if (!instance._unmounted) {
                        if (!isNull(options.beforeUnmount)) {
                            options.beforeUnmount(vNode);
                        }
                        if (!isUndefined(instance.componentWillUnmount)) {
                            instance.componentWillUnmount();
                        }
                        if (ref && !isRecycling) {
                            ref(null);
                        }
                        instance._unmounted = true;
                        if (options.findDOMNodeEnabled) {
                            componentToDOMNodeMap.delete(instance);
                        }
                        unmount(instance._lastInput, null, instance._lifecycle, false, isRecycling);
                    }
                } else {
                    if (!isNullOrUndef(ref)) {
                        if (!isNullOrUndef(ref.onComponentWillUnmount)) {
                            ref.onComponentWillUnmount(dom, props);
                        }
                    }
                    unmount(instance, null, lifecycle, false, isRecycling);
                }
            }
            if (options.recyclingEnabled && !isStatefulComponent$$1 && (parentDom || canRecycle)) {
                poolComponent(vNode);
            }
        } else if (flags & 3970 /* Element */) {
            var ref$1 = vNode.ref;
            var props$1 = vNode.props;
            if (!isRecycling && isFunction(ref$1)) {
                ref$1(null);
            }
            var children = vNode.children;
            if (!isNullOrUndef(children)) {
                if (isArray$3(children)) {
                    for (var i = 0, len = children.length; i < len; i++) {
                        var child = children[i];
                        if (!isInvalid(child) && isObject$5(child)) {
                            unmount(child, null, lifecycle, false, isRecycling);
                        }
                    }
                } else if (isObject$5(children)) {
                    unmount(children, null, lifecycle, false, isRecycling);
                }
            }
            if (!isNull(props$1)) {
                for (var name in props$1) {
                    // do not add a hasOwnProperty check here, it affects performance
                    if (props$1[name] !== null && isAttrAnEvent(name)) {
                        patchEvent(name, props$1[name], null, dom);
                        // We need to set this null, because same props otherwise come back if SCU returns false and we are recyling
                        props$1[name] = null;
                    }
                }
            }
            if (options.recyclingEnabled && (parentDom || canRecycle)) {
                poolElement(vNode);
            }
        }
    if (!isNull(parentDom)) {
        removeChild(parentDom, dom);
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
// rather than use a Map, like we did before, we can use an array here
// given there shouldn't be THAT many roots on the page, the difference
// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da
var componentToDOMNodeMap = new Map();
var roots = options.roots;
/**
 * When inferno.options.findDOMNOdeEnabled is true, this function will return DOM Node by component instance
 * @param ref Component instance
 * @returns {*|null} returns dom node
 */
function findDOMNode$1(ref) {
    if (!options.findDOMNodeEnabled) {
        {
            throwError("findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!");
        }
        throwError();
    }
    var dom = ref && ref.nodeType ? ref : null;
    return componentToDOMNodeMap.get(ref) || dom;
}
function getRoot(dom) {
    for (var i = 0, len = roots.length; i < len; i++) {
        var root = roots[i];
        if (root.dom === dom) {
            return root;
        }
    }
    return null;
}
function setRoot(dom, input, lifecycle) {
    var root = {
        dom: dom,
        input: input,
        lifecycle: lifecycle
    };
    roots.push(root);
    return root;
}
function removeRoot(root) {
    for (var i = 0, len = roots.length; i < len; i++) {
        if (roots[i] === root) {
            roots.splice(i, 1);
            return;
        }
    }
}
{
    if (isBrowser && document.body === null) {
        warning('Inferno warning: you cannot initialize inferno without "document.body". Wait on "DOMContentLoaded" event, add script to bottom of body, or use async/defer attributes on script tag.');
    }
}
var documentBody = isBrowser ? document.body : null;
/**
 * Renders virtual node tree into parent node.
 * @param {VNode | null | string | number} input vNode to be rendered
 * @param parentDom DOM node which content will be replaced by virtual node
 * @returns {InfernoChildren} rendered virtual node
 */
function render$2(input, parentDom) {
    if (documentBody === parentDom) {
        {
            throwError('you cannot render() to the "document.body". Use an empty element as a container instead.');
        }
        throwError();
    }
    if (input === NO_OP$1) {
        return;
    }
    var root = getRoot(parentDom);
    if (isNull(root)) {
        var lifecycle = new Lifecycle();
        if (!isInvalid(input)) {
            if (input.dom) {
                input = directClone(input);
            }
            if (!hydrateRoot(input, parentDom, lifecycle)) {
                mount(input, parentDom, lifecycle, EMPTY_OBJ$1, false);
            }
            root = setRoot(parentDom, input, lifecycle);
            lifecycle.trigger();
        }
    } else {
        var lifecycle$1 = root.lifecycle;
        lifecycle$1.listeners = [];
        if (isNullOrUndef(input)) {
            unmount(root.input, parentDom, lifecycle$1, false, false);
            removeRoot(root);
        } else {
            if (input.dom) {
                input = directClone(input);
            }
            patch(root.input, input, parentDom, lifecycle$1, EMPTY_OBJ$1, false, false);
        }
        root.input = input;
        lifecycle$1.trigger();
    }
    if (root) {
        var rootInput = root.input;
        if (rootInput && rootInput.flags & 28 /* Component */) {
                return rootInput.children;
            }
    }
}
function createRenderer(parentDom) {
    return function renderer(lastInput, nextInput) {
        if (!parentDom) {
            parentDom = lastInput;
        }
        render$2(nextInput, parentDom);
    };
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {
    if (lastVNode !== nextVNode) {
        var lastFlags = lastVNode.flags;
        var nextFlags = nextVNode.flags;
        if (nextFlags & 28 /* Component */) {
                var isClass = (nextFlags & 4 /* ComponentClass */) > 0;
                if (lastFlags & 28 /* Component */) {
                        patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling);
                    } else {
                    replaceVNode(parentDom, mountComponent$1(nextVNode, null, lifecycle, context, isSVG, isClass), lastVNode, lifecycle, isRecycling);
                }
            } else if (nextFlags & 3970 /* Element */) {
                if (lastFlags & 3970 /* Element */) {
                        patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);
                    } else {
                    replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);
                }
            } else if (nextFlags & 1 /* Text */) {
                if (lastFlags & 1 /* Text */) {
                        patchText(lastVNode, nextVNode);
                    } else {
                    replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);
                }
            } else if (nextFlags & 4096 /* Void */) {
                if (lastFlags & 4096 /* Void */) {
                        patchVoid(lastVNode, nextVNode);
                    } else {
                    replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);
                }
            } else {
            // Error case: mount new one replacing old one
            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);
        }
    }
}
function unmountChildren(children, dom, lifecycle, isRecycling) {
    if (isVNode(children)) {
        unmount(children, dom, lifecycle, true, isRecycling);
    } else if (isArray$3(children)) {
        removeAllChildren(dom, children, lifecycle, isRecycling);
    } else {
        dom.textContent = "";
    }
}
function patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {
    var nextTag = nextVNode.type;
    var lastTag = lastVNode.type;
    if (lastTag !== nextTag) {
        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);
    } else {
        var dom = lastVNode.dom;
        var lastProps = lastVNode.props;
        var nextProps = nextVNode.props;
        var lastChildren = lastVNode.children;
        var nextChildren = nextVNode.children;
        var lastFlags = lastVNode.flags;
        var nextFlags = nextVNode.flags;
        var nextRef = nextVNode.ref;
        var lastClassName = lastVNode.className;
        var nextClassName = nextVNode.className;
        nextVNode.dom = dom;
        isSVG = isSVG || (nextFlags & 128 /* SvgElement */) > 0;
        if (lastChildren !== nextChildren) {
            var childrenIsSVG = isSVG === true && nextVNode.type !== "foreignObject";
            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, childrenIsSVG, isRecycling);
        }
        // inlined patchProps  -- starts --
        if (lastProps !== nextProps) {
            var lastPropsOrEmpty = lastProps || EMPTY_OBJ$1;
            var nextPropsOrEmpty = nextProps || EMPTY_OBJ$1;
            var hasControlledValue = false;
            if (nextPropsOrEmpty !== EMPTY_OBJ$1) {
                var isFormElement = (nextFlags & 3584 /* FormElement */) > 0;
                if (isFormElement) {
                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
                }
                for (var prop in nextPropsOrEmpty) {
                    // do not add a hasOwnProperty check here, it affects performance
                    var nextValue = nextPropsOrEmpty[prop];
                    var lastValue = lastPropsOrEmpty[prop];
                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);
                }
                if (isFormElement) {
                    // When inferno is recycling form element, we need to process it like it would be mounting
                    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, isRecycling, hasControlledValue);
                }
            }
            if (lastPropsOrEmpty !== EMPTY_OBJ$1) {
                for (var prop$1 in lastPropsOrEmpty) {
                    // do not add a hasOwnProperty check here, it affects performance
                    if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
                        removeProp(prop$1, lastPropsOrEmpty[prop$1], dom, nextFlags);
                    }
                }
            }
        }
        // inlined patchProps  -- ends --
        if (lastClassName !== nextClassName) {
            if (isNullOrUndef(nextClassName)) {
                dom.removeAttribute("class");
            } else {
                if (isSVG) {
                    dom.setAttribute("class", nextClassName);
                } else {
                    dom.className = nextClassName;
                }
            }
        }
        if (nextRef) {
            if (lastVNode.ref !== nextRef || isRecycling) {
                mountRef(dom, nextRef, lifecycle);
            }
        }
    }
}
function patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {
    var patchArray = false;
    var patchKeyed = false;
    if (nextFlags & 64 /* HasNonKeyedChildren */) {
            patchArray = true;
        } else if ((lastFlags & 32 /* HasKeyedChildren */) > 0 && (nextFlags & 32 /* HasKeyedChildren */) > 0) {
        patchKeyed = true;
        patchArray = true;
    } else if (isInvalid(nextChildren)) {
        unmountChildren(lastChildren, dom, lifecycle, isRecycling);
    } else if (isInvalid(lastChildren)) {
        if (isStringOrNumber(nextChildren)) {
            setTextContent(dom, nextChildren);
        } else {
            if (isArray$3(nextChildren)) {
                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);
            } else {
                mount(nextChildren, dom, lifecycle, context, isSVG);
            }
        }
    } else if (isStringOrNumber(nextChildren)) {
        if (isStringOrNumber(lastChildren)) {
            updateTextContent(dom, nextChildren);
        } else {
            unmountChildren(lastChildren, dom, lifecycle, isRecycling);
            setTextContent(dom, nextChildren);
        }
    } else if (isArray$3(nextChildren)) {
        if (isArray$3(lastChildren)) {
            patchArray = true;
            if (isKeyed(lastChildren, nextChildren)) {
                patchKeyed = true;
            }
        } else {
            unmountChildren(lastChildren, dom, lifecycle, isRecycling);
            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);
        }
    } else if (isArray$3(lastChildren)) {
        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);
        mount(nextChildren, dom, lifecycle, context, isSVG);
    } else if (isVNode(nextChildren)) {
        if (isVNode(lastChildren)) {
            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);
        } else {
            unmountChildren(lastChildren, dom, lifecycle, isRecycling);
            mount(nextChildren, dom, lifecycle, context, isSVG);
        }
    }
    if (patchArray) {
        var lastLength = lastChildren.length;
        var nextLength = nextChildren.length;
        // Fast path's for both algorithms
        if (lastLength === 0) {
            if (nextLength > 0) {
                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);
            }
        } else if (nextLength === 0) {
            removeAllChildren(dom, lastChildren, lifecycle, isRecycling);
        } else if (patchKeyed) {
            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling, lastLength, nextLength);
        } else {
            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling, lastLength, nextLength);
        }
    }
}
function patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {
    var lastType = lastVNode.type;
    var nextType = nextVNode.type;
    var lastKey = lastVNode.key;
    var nextKey = nextVNode.key;
    if (lastType !== nextType || lastKey !== nextKey) {
        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);
        return false;
    } else {
        var nextProps = nextVNode.props || EMPTY_OBJ$1;
        if (isClass) {
            var instance = lastVNode.children;
            instance._updating = true;
            if (instance._unmounted) {
                if (isNull(parentDom)) {
                    return true;
                }
                replaceChild(parentDom, mountComponent$1(nextVNode, null, lifecycle, context, isSVG, (nextVNode.flags & 4 /* ComponentClass */) > 0), lastVNode.dom);
            } else {
                var hasComponentDidUpdate = !isUndefined(instance.componentDidUpdate);
                var nextState = instance.state;
                // When component has componentDidUpdate hook, we need to clone lastState or will be modified by reference during update
                var lastState = hasComponentDidUpdate ? combineFrom(nextState, null) : nextState;
                var lastProps = instance.props;
                nextVNode.children = instance;
                instance._isSVG = isSVG;
                var lastInput = instance._lastInput;
                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);
                // If this component was destroyed by its parent do nothing, this is no-op
                // It can happen by using external callback etc during render / update
                if (instance._unmounted) {
                    return false;
                }
                var didUpdate = true;
                // Update component before getting child context
                var childContext;
                if (!isNullOrUndef(instance.getChildContext)) {
                    childContext = instance.getChildContext();
                }
                if (isNullOrUndef(childContext)) {
                    childContext = context;
                } else {
                    childContext = combineFrom(context, childContext);
                }
                instance._childContext = childContext;
                if (isInvalid(nextInput)) {
                    nextInput = createVoidVNode();
                } else if (nextInput === NO_OP$1) {
                    nextInput = lastInput;
                    didUpdate = false;
                } else if (isStringOrNumber(nextInput)) {
                    nextInput = createTextVNode(nextInput, null);
                } else if (isArray$3(nextInput)) {
                    {
                        throwError("a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.");
                    }
                    throwError();
                } else if (isObject$5(nextInput)) {
                    if (!isNull(nextInput.dom)) {
                        nextInput = directClone(nextInput);
                    }
                }
                if (nextInput.flags & 28 /* Component */) {
                        nextInput.parentVNode = nextVNode;
                    } else if (lastInput.flags & 28 /* Component */) {
                        lastInput.parentVNode = nextVNode;
                    }
                instance._lastInput = nextInput;
                instance._vNode = nextVNode;
                if (didUpdate) {
                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);
                    if (hasComponentDidUpdate && instance.componentDidUpdate) {
                        instance.componentDidUpdate(lastProps, lastState);
                    }
                    if (!isNull(options.afterUpdate)) {
                        options.afterUpdate(nextVNode);
                    }
                    if (options.findDOMNodeEnabled) {
                        componentToDOMNodeMap.set(instance, nextInput.dom);
                    }
                }
                nextVNode.dom = nextInput.dom;
            }
            instance._updating = false;
        } else {
            var shouldUpdate = true;
            var lastProps$1 = lastVNode.props;
            var nextHooks = nextVNode.ref;
            var nextHooksDefined = !isNullOrUndef(nextHooks);
            var lastInput$1 = lastVNode.children;
            var nextInput$1 = lastInput$1;
            nextVNode.dom = lastVNode.dom;
            nextVNode.children = lastInput$1;
            if (lastKey !== nextKey) {
                shouldUpdate = true;
            } else {
                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {
                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);
                }
            }
            if (shouldUpdate !== false) {
                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentWillUpdate)) {
                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);
                }
                nextInput$1 = nextType(nextProps, context);
                if (isInvalid(nextInput$1)) {
                    nextInput$1 = createVoidVNode();
                } else if (isStringOrNumber(nextInput$1) && nextInput$1 !== NO_OP$1) {
                    nextInput$1 = createTextVNode(nextInput$1, null);
                } else if (isArray$3(nextInput$1)) {
                    {
                        throwError("a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.");
                    }
                    throwError();
                } else if (isObject$5(nextInput$1)) {
                    if (!isNull(nextInput$1.dom)) {
                        nextInput$1 = directClone(nextInput$1);
                    }
                }
                if (nextInput$1 !== NO_OP$1) {
                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, context, isSVG, isRecycling);
                    nextVNode.children = nextInput$1;
                    if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentDidUpdate)) {
                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);
                    }
                    nextVNode.dom = nextInput$1.dom;
                }
            }
            if (nextInput$1.flags & 28 /* Component */) {
                    nextInput$1.parentVNode = nextVNode;
                } else if (lastInput$1.flags & 28 /* Component */) {
                    lastInput$1.parentVNode = nextVNode;
                }
        }
    }
    return false;
}
function patchText(lastVNode, nextVNode) {
    var nextText = nextVNode.children;
    var dom = lastVNode.dom;
    nextVNode.dom = dom;
    if (lastVNode.children !== nextText) {
        dom.nodeValue = nextText;
    }
}
function patchVoid(lastVNode, nextVNode) {
    nextVNode.dom = lastVNode.dom;
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling, lastChildrenLength, nextChildrenLength) {
    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
    var i = 0;
    for (; i < commonLength; i++) {
        var nextChild = nextChildren[i];
        if (nextChild.dom) {
            nextChild = nextChildren[i] = directClone(nextChild);
        }
        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);
    }
    if (lastChildrenLength < nextChildrenLength) {
        for (i = commonLength; i < nextChildrenLength; i++) {
            var nextChild$1 = nextChildren[i];
            if (nextChild$1.dom) {
                nextChild$1 = nextChildren[i] = directClone(nextChild$1);
            }
            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));
        }
    } else if (lastChildrenLength > nextChildrenLength) {
        for (i = commonLength; i < lastChildrenLength; i++) {
            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);
        }
    }
}
function patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling, aLength, bLength) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var aStart = 0;
    var bStart = 0;
    var i;
    var j;
    var aNode;
    var bNode;
    var nextNode;
    var nextPos;
    var node;
    var aStartNode = a[aStart];
    var bStartNode = b[bStart];
    var aEndNode = a[aEnd];
    var bEndNode = b[bEnd];
    if (bStartNode.dom) {
        b[bStart] = bStartNode = directClone(bStartNode);
    }
    if (bEndNode.dom) {
        b[bEnd] = bEndNode = directClone(bEndNode);
    }
    // Step 1
    // tslint:disable-next-line
    outer: {
        // Sync nodes with the same key at the beginning.
        while (aStartNode.key === bStartNode.key) {
            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);
            aStart++;
            bStart++;
            if (aStart > aEnd || bStart > bEnd) {
                break outer;
            }
            aStartNode = a[aStart];
            bStartNode = b[bStart];
            if (bStartNode.dom) {
                b[bStart] = bStartNode = directClone(bStartNode);
            }
        }
        // Sync nodes with the same key at the end.
        while (aEndNode.key === bEndNode.key) {
            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);
            aEnd--;
            bEnd--;
            if (aStart > aEnd || bStart > bEnd) {
                break outer;
            }
            aEndNode = a[aEnd];
            bEndNode = b[bEnd];
            if (bEndNode.dom) {
                b[bEnd] = bEndNode = directClone(bEndNode);
            }
        }
    }
    if (aStart > aEnd) {
        if (bStart <= bEnd) {
            nextPos = bEnd + 1;
            nextNode = nextPos < bLength ? b[nextPos].dom : null;
            while (bStart <= bEnd) {
                node = b[bStart];
                if (node.dom) {
                    b[bStart] = node = directClone(node);
                }
                bStart++;
                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);
            }
        }
    } else if (bStart > bEnd) {
        while (aStart <= aEnd) {
            unmount(a[aStart++], dom, lifecycle, false, isRecycling);
        }
    } else {
        var aLeft = aEnd - aStart + 1;
        var bLeft = bEnd - bStart + 1;
        var sources = new Array(bLeft);
        // Mark all nodes as inserted.
        for (i = 0; i < bLeft; i++) {
            sources[i] = -1;
        }
        var moved = false;
        var pos = 0;
        var patched = 0;
        // When sizes are small, just loop them through
        if (bLeft <= 4 || aLeft * bLeft <= 16) {
            for (i = aStart; i <= aEnd; i++) {
                aNode = a[i];
                if (patched < bLeft) {
                    for (j = bStart; j <= bEnd; j++) {
                        bNode = b[j];
                        if (aNode.key === bNode.key) {
                            sources[j - bStart] = i;
                            if (pos > j) {
                                moved = true;
                            } else {
                                pos = j;
                            }
                            if (bNode.dom) {
                                b[j] = bNode = directClone(bNode);
                            }
                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);
                            patched++;
                            a[i] = null;
                            break;
                        }
                    }
                }
            }
        } else {
            var keyIndex = new Map();
            // Map keys by their index in array
            for (i = bStart; i <= bEnd; i++) {
                keyIndex.set(b[i].key, i);
            }
            // Try to patch same keys
            for (i = aStart; i <= aEnd; i++) {
                aNode = a[i];
                if (patched < bLeft) {
                    j = keyIndex.get(aNode.key);
                    if (!isUndefined(j)) {
                        bNode = b[j];
                        sources[j - bStart] = i;
                        if (pos > j) {
                            moved = true;
                        } else {
                            pos = j;
                        }
                        if (bNode.dom) {
                            b[j] = bNode = directClone(bNode);
                        }
                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);
                        patched++;
                        a[i] = null;
                    }
                }
            }
        }
        // fast-path: if nothing patched remove all old and add all new
        if (aLeft === aLength && patched === 0) {
            removeAllChildren(dom, a, lifecycle, isRecycling);
            while (bStart < bLeft) {
                node = b[bStart];
                if (node.dom) {
                    b[bStart] = node = directClone(node);
                }
                bStart++;
                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);
            }
        } else {
            i = aLeft - patched;
            while (i > 0) {
                aNode = a[aStart++];
                if (!isNull(aNode)) {
                    unmount(aNode, dom, lifecycle, true, isRecycling);
                    i--;
                }
            }
            if (moved) {
                var seq = lis_algorithm(sources);
                j = seq.length - 1;
                for (i = bLeft - 1; i >= 0; i--) {
                    if (sources[i] === -1) {
                        pos = i + bStart;
                        node = b[pos];
                        if (node.dom) {
                            b[pos] = node = directClone(node);
                        }
                        nextPos = pos + 1;
                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);
                    } else {
                        if (j < 0 || i !== seq[j]) {
                            pos = i + bStart;
                            node = b[pos];
                            nextPos = pos + 1;
                            insertOrAppend(dom, node.dom, nextPos < bLength ? b[nextPos].dom : null);
                        } else {
                            j--;
                        }
                    }
                }
            } else if (patched !== bLeft) {
                // when patched count doesn't match b length we need to insert those new ones
                // loop backwards so we can use insertBefore
                for (i = bLeft - 1; i >= 0; i--) {
                    if (sources[i] === -1) {
                        pos = i + bStart;
                        node = b[pos];
                        if (node.dom) {
                            b[pos] = node = directClone(node);
                        }
                        nextPos = pos + 1;
                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);
                    }
                }
            }
        }
    }
}
// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function lis_algorithm(arr) {
    var p = arr.slice(0);
    var result = [0];
    var i;
    var j;
    var u;
    var v;
    var c;
    var len = arr.length;
    for (i = 0; i < len; i++) {
        var arrI = arr[i];
        if (arrI !== -1) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = (u + v) / 2 | 0;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                } else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}
function isAttrAnEvent(attr) {
    return attr[0] === "o" && attr[1] === "n";
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {
    if (lastValue !== nextValue) {
        if (skipProps.has(prop) || hasControlledValue && prop === "value") {
            return;
        } else if (booleanProps.has(prop)) {
            prop = prop === "autoFocus" ? prop.toLowerCase() : prop;
            dom[prop] = !!nextValue;
        } else if (strictProps.has(prop)) {
            var value = isNullOrUndef(nextValue) ? "" : nextValue;
            if (dom[prop] !== value) {
                dom[prop] = value;
            }
        } else if (isAttrAnEvent(prop)) {
            patchEvent(prop, lastValue, nextValue, dom);
        } else if (isNullOrUndef(nextValue)) {
            dom.removeAttribute(prop);
        } else if (prop === "style") {
            patchStyle(lastValue, nextValue, dom);
        } else if (prop === "dangerouslySetInnerHTML") {
            var lastHtml = lastValue && lastValue.__html;
            var nextHtml = nextValue && nextValue.__html;
            if (lastHtml !== nextHtml) {
                if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
                    dom.innerHTML = nextHtml;
                }
            }
        } else {
            // We optimize for NS being boolean. Its 99.9% time false
            if (isSVG && namespaces.has(prop)) {
                // If we end up in this path we can read property again
                dom.setAttributeNS(namespaces.get(prop), prop, nextValue);
            } else {
                dom.setAttribute(prop, nextValue);
            }
        }
    }
}
function patchEvent(name, lastValue, nextValue, dom) {
    if (lastValue !== nextValue) {
        if (delegatedEvents.has(name)) {
            handleEvent(name, lastValue, nextValue, dom);
        } else {
            var nameLowerCase = name.toLowerCase();
            var domEvent = dom[nameLowerCase];
            // if the function is wrapped, that means it's been controlled by a wrapper
            if (domEvent && domEvent.wrapped) {
                return;
            }
            if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {
                var linkEvent = nextValue.event;
                if (linkEvent && isFunction(linkEvent)) {
                    dom[nameLowerCase] = function (e) {
                        linkEvent(nextValue.data, e);
                    };
                } else {
                    {
                        throwError("an event on a VNode \"" + name + "\". was not a function or a valid linkEvent.");
                    }
                    throwError();
                }
            } else {
                dom[nameLowerCase] = nextValue;
            }
        }
    }
}
// We are assuming here that we come from patchProp routine
// -nextAttrValue cannot be null or undefined
function patchStyle(lastAttrValue, nextAttrValue, dom) {
    var domStyle = dom.style;
    var style;
    var value;
    if (isString(nextAttrValue)) {
        domStyle.cssText = nextAttrValue;
        return;
    }
    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {
        for (style in nextAttrValue) {
            // do not add a hasOwnProperty check here, it affects performance
            value = nextAttrValue[style];
            if (value !== lastAttrValue[style]) {
                domStyle[style] = !isNumber(value) || isUnitlessNumber.has(style) ? value : value + "px";
            }
        }
        for (style in lastAttrValue) {
            if (isNullOrUndef(nextAttrValue[style])) {
                domStyle[style] = "";
            }
        }
    } else {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            domStyle[style] = !isNumber(value) || isUnitlessNumber.has(style) ? value : value + "px";
        }
    }
}
function removeProp(prop, lastValue, dom, nextFlags) {
    if (prop === "value") {
        // When removing value of select element, it needs to be set to null instead empty string, because empty string is valid value for option which makes that option selected
        // MS IE/Edge don't follow html spec for textArea and input elements and we need to set empty string to value in those cases to avoid "null" and "undefined" texts
        dom.value = nextFlags & 2048 /* SelectElement */ ? null : "";
    } else if (prop === "style") {
        dom.removeAttribute("style");
    } else if (isAttrAnEvent(prop)) {
        handleEvent(prop, lastValue, null, dom);
    } else {
        dom.removeAttribute(prop);
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function mount(vNode, parentDom, lifecycle, context, isSVG) {
    var flags = vNode.flags;
    if (flags & 3970 /* Element */) {
            return mountElement(vNode, parentDom, lifecycle, context, isSVG);
        } else if (flags & 28 /* Component */) {
            return mountComponent$1(vNode, parentDom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);
        } else if (flags & 4096 /* Void */) {
            return mountVoid(vNode, parentDom);
        } else if (flags & 1 /* Text */) {
            return mountText(vNode, parentDom);
        } else {
        {
            if ((typeof vNode === "undefined" ? "undefined" : babelHelpers.typeof(vNode)) === "object") {
                throwError("mount() received an object that's not a valid VNode, you should stringify it first. Object: \"" + JSON.stringify(vNode) + "\".");
            } else {
                throwError("mount() expects a valid VNode, instead it received an object with the type \"" + (typeof vNode === "undefined" ? "undefined" : babelHelpers.typeof(vNode)) + "\".");
            }
        }
        throwError();
    }
}
function mountText(vNode, parentDom) {
    var dom = document.createTextNode(vNode.children);
    vNode.dom = dom;
    if (!isNull(parentDom)) {
        appendChild(parentDom, dom);
    }
    return dom;
}
function mountVoid(vNode, parentDom) {
    var dom = document.createTextNode("");
    vNode.dom = dom;
    if (!isNull(parentDom)) {
        appendChild(parentDom, dom);
    }
    return dom;
}
function mountElement(vNode, parentDom, lifecycle, context, isSVG) {
    var dom;
    if (options.recyclingEnabled) {
        dom = recycleElement(vNode, lifecycle, context, isSVG);
        if (!isNull(dom)) {
            if (!isNull(parentDom)) {
                appendChild(parentDom, dom);
            }
            return dom;
        }
    }
    var flags = vNode.flags;
    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;
    dom = documentCreateElement(vNode.type, isSVG);
    var children = vNode.children;
    var props = vNode.props;
    var className = vNode.className;
    var ref = vNode.ref;
    vNode.dom = dom;
    if (!isInvalid(children)) {
        if (isStringOrNumber(children)) {
            setTextContent(dom, children);
        } else {
            var childrenIsSVG = isSVG === true && vNode.type !== "foreignObject";
            if (isArray$3(children)) {
                mountArrayChildren(children, dom, lifecycle, context, childrenIsSVG);
            } else if (isVNode(children)) {
                mount(children, dom, lifecycle, context, childrenIsSVG);
            }
        }
    }
    if (!isNull(props)) {
        var hasControlledValue = false;
        var isFormElement = (flags & 3584 /* FormElement */) > 0;
        if (isFormElement) {
            hasControlledValue = isControlledFormElement(props);
        }
        for (var prop in props) {
            // do not add a hasOwnProperty check here, it affects performance
            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);
        }
        if (isFormElement) {
            processElement(flags, vNode, dom, props, true, hasControlledValue);
        }
    }
    if (className !== null) {
        if (isSVG) {
            dom.setAttribute("class", className);
        } else {
            dom.className = className;
        }
    }
    if (!isNull(ref)) {
        mountRef(dom, ref, lifecycle);
    }
    if (!isNull(parentDom)) {
        appendChild(parentDom, dom);
    }
    return dom;
}
function mountArrayChildren(children, dom, lifecycle, context, isSVG) {
    for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i];
        // Verify can string/number be here. might cause de-opt. - Normalization takes care of it.
        if (!isInvalid(child)) {
            if (child.dom) {
                children[i] = child = directClone(child);
            }
            mount(children[i], dom, lifecycle, context, isSVG);
        }
    }
}
function mountComponent$1(vNode, parentDom, lifecycle, context, isSVG, isClass) {
    var dom;
    if (options.recyclingEnabled) {
        dom = recycleComponent(vNode, lifecycle, context, isSVG);
        if (!isNull(dom)) {
            if (!isNull(parentDom)) {
                appendChild(parentDom, dom);
            }
            return dom;
        }
    }
    var type = vNode.type;
    var props = vNode.props || EMPTY_OBJ$1;
    var ref = vNode.ref;
    if (isClass) {
        var instance = createClassComponentInstance(vNode, type, props, context, isSVG, lifecycle);
        var input = instance._lastInput;
        instance._vNode = vNode;
        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);
        if (!isNull(parentDom)) {
            appendChild(parentDom, dom);
        }
        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);
        instance._updating = false;
        if (options.findDOMNodeEnabled) {
            componentToDOMNodeMap.set(instance, dom);
        }
    } else {
        var input$1 = createFunctionalComponentInput(vNode, type, props, context);
        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);
        vNode.children = input$1;
        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);
        if (!isNull(parentDom)) {
            appendChild(parentDom, dom);
        }
    }
    return dom;
}
function mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {
    if (ref) {
        if (isFunction(ref)) {
            ref(instance);
        } else {
            {
                if (isStringOrNumber(ref)) {
                    throwError('string "refs" are not supported in Inferno 1.0. Use callback "refs" instead.');
                } else if (isObject$5(ref) && vNode.flags & 4 /* ComponentClass */) {
                        throwError("functional component lifecycle events are not supported on ES2015 class components.");
                    } else {
                    throwError("a bad value for \"ref\" was used on component: \"" + JSON.stringify(ref) + "\"");
                }
            }
            throwError();
        }
    }
    var hasDidMount = !isUndefined(instance.componentDidMount);
    var afterMount = options.afterMount;
    if (hasDidMount || !isNull(afterMount)) {
        lifecycle.addListener(function () {
            instance._updating = true;
            if (afterMount) {
                afterMount(vNode);
            }
            if (hasDidMount) {
                instance.componentDidMount();
            }
            instance._updating = false;
        });
    }
}
function mountFunctionalComponentCallbacks(props, ref, dom, lifecycle) {
    if (ref) {
        if (!isNullOrUndef(ref.onComponentWillMount)) {
            ref.onComponentWillMount(props);
        }
        if (!isNullOrUndef(ref.onComponentDidMount)) {
            lifecycle.addListener(function () {
                return ref.onComponentDidMount(dom, props);
            });
        }
    }
}
function mountRef(dom, value, lifecycle) {
    if (isFunction(value)) {
        lifecycle.addListener(function () {
            return value(dom);
        });
    } else {
        if (isInvalid(value)) {
            return;
        }
        {
            throwError('string "refs" are not supported in Inferno 1.0. Use callback "refs" instead.');
        }
        throwError();
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
// We need EMPTY_OBJ defined in one place.
// Its used for comparison so we cant inline it into shared
var EMPTY_OBJ$1 = {};
{
    Object.freeze(EMPTY_OBJ$1);
}
function createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {
    if (isUndefined(context)) {
        context = EMPTY_OBJ$1; // Context should not be mutable
    }
    var instance = new Component(props, context);
    vNode.children = instance;
    instance._blockSetState = false;
    instance.context = context;
    if (instance.props === EMPTY_OBJ$1) {
        instance.props = props;
    }
    // setState callbacks must fire after render is done when called from componentWillReceiveProps or componentWillMount
    instance._lifecycle = lifecycle;
    instance._unmounted = false;
    instance._isSVG = isSVG;
    if (!isNullOrUndef(instance.componentWillMount)) {
        instance._blockRender = true;
        instance.componentWillMount();
        if (instance._pendingSetState) {
            var state = instance.state;
            var pending = instance._pendingState;
            if (state === null) {
                instance.state = pending;
            } else {
                for (var key in pending) {
                    state[key] = pending[key];
                }
            }
            instance._pendingSetState = false;
            instance._pendingState = null;
        }
        instance._blockRender = false;
    }
    var childContext;
    if (!isNullOrUndef(instance.getChildContext)) {
        childContext = instance.getChildContext();
    }
    if (isNullOrUndef(childContext)) {
        instance._childContext = context;
    } else {
        instance._childContext = combineFrom(context, childContext);
    }
    if (!isNull(options.beforeRender)) {
        options.beforeRender(instance);
    }
    var input = instance.render(props, instance.state, context);
    if (!isNull(options.afterRender)) {
        options.afterRender(instance);
    }
    if (isArray$3(input)) {
        {
            throwError("a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.");
        }
        throwError();
    } else if (isInvalid(input)) {
        input = createVoidVNode();
    } else if (isStringOrNumber(input)) {
        input = createTextVNode(input, null);
    } else {
        if (input.dom) {
            input = directClone(input);
        }
        if (input.flags & 28 /* Component */) {
                // if we have an input that is also a component, we run into a tricky situation
                // where the root vNode needs to always have the correct DOM entry
                // so we break monomorphism on our input and supply it our vNode as parentVNode
                // we can optimise this in the future, but this gets us out of a lot of issues
                input.parentVNode = vNode;
            }
    }
    instance._lastInput = input;
    return instance;
}
function replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {
    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);
}
function replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {
    unmount(vNode, null, lifecycle, false, isRecycling);
    replaceChild(parentDom, dom, vNode.dom);
}
function createFunctionalComponentInput(vNode, component, props, context) {
    var input = component(props, context);
    if (isArray$3(input)) {
        {
            throwError("a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.");
        }
        throwError();
    } else if (isInvalid(input)) {
        input = createVoidVNode();
    } else if (isStringOrNumber(input)) {
        input = createTextVNode(input, null);
    } else {
        if (input.dom) {
            input = directClone(input);
        }
        if (input.flags & 28 /* Component */) {
                // if we have an input that is also a component, we run into a tricky situation
                // where the root vNode needs to always have the correct DOM entry
                // so we break monomorphism on our input and supply it our vNode as parentVNode
                // we can optimise this in the future, but this gets us out of a lot of issues
                input.parentVNode = vNode;
            }
    }
    return input;
}
function setTextContent(dom, text) {
    if (text !== "") {
        dom.textContent = text;
    } else {
        dom.appendChild(document.createTextNode(""));
    }
}
function updateTextContent(dom, text) {
    dom.firstChild.nodeValue = text;
}
function appendChild(parentDom, dom) {
    parentDom.appendChild(dom);
}
function insertOrAppend(parentDom, newNode, nextNode) {
    if (isNullOrUndef(nextNode)) {
        appendChild(parentDom, newNode);
    } else {
        parentDom.insertBefore(newNode, nextNode);
    }
}
function documentCreateElement(tag, isSVG) {
    if (isSVG === true) {
        return document.createElementNS(svgNS, tag);
    } else {
        return document.createElement(tag);
    }
}
function replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {
    unmount(lastNode, null, lifecycle, false, isRecycling);
    var dom = mount(nextNode, null, lifecycle, context, isSVG);
    nextNode.dom = dom;
    replaceChild(parentDom, dom, lastNode.dom);
}
function replaceChild(parentDom, newDom, lastDom) {
    if (!parentDom) {
        parentDom = lastDom.parentNode;
    }
    parentDom.replaceChild(newDom, lastDom);
}
function removeChild(parentDom, dom) {
    parentDom.removeChild(dom);
}
function removeAllChildren(dom, children, lifecycle, isRecycling) {
    if (!options.recyclingEnabled || options.recyclingEnabled && !isRecycling) {
        removeChildren(null, children, lifecycle, isRecycling);
    }
    dom.textContent = "";
}
function removeChildren(dom, children, lifecycle, isRecycling) {
    for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i];
        if (!isInvalid(child)) {
            unmount(child, dom, lifecycle, true, isRecycling);
        }
    }
}
function isKeyed(lastChildren, nextChildren) {
    return nextChildren.length > 0 && !isNullOrUndef(nextChildren[0]) && !isNullOrUndef(nextChildren[0].key) && lastChildren.length > 0 && !isNullOrUndef(lastChildren[0]) && !isNullOrUndef(lastChildren[0].key);
}
function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement("i");
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}
function isSamePropsInnerHTML(dom, props) {
    return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML(dom, props.dangerouslySetInnerHTML.__html));
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
/**
 * Creates virtual node
 * @param {number} flags
 * @param {string|Function|null} type
 * @param {string|null=} className
 * @param {object=} children
 * @param {object=} props
 * @param {*=} key
 * @param {object|Function=} ref
 * @param {boolean=} noNormalise
 * @returns {VNode} returns new virtual node
 */
function createVNode$1(flags, type, className, children, props, key, ref, noNormalise) {
    if (flags & 16 /* ComponentUnknown */) {
            flags = isStatefulComponent(type) ? 4 /* ComponentClass */
            : 8 /* ComponentFunction */;
        }
    var vNode = {
        children: children === void 0 ? null : children,
        className: className === void 0 ? null : className,
        dom: null,
        flags: flags,
        key: key === void 0 ? null : key,
        props: props === void 0 ? null : props,
        ref: ref === void 0 ? null : ref,
        type: type
    };
    if (noNormalise !== true) {
        normalize(vNode);
    }
    if (options.createVNode !== null) {
        options.createVNode(vNode);
    }
    return vNode;
}
function directClone(vNodeToClone) {
    var newVNode;
    var flags = vNodeToClone.flags;
    if (flags & 28 /* Component */) {
            var props;
            var propsToClone = vNodeToClone.props;
            if (isNull(propsToClone)) {
                props = EMPTY_OBJ$1;
            } else {
                props = {};
                for (var key in propsToClone) {
                    props[key] = propsToClone[key];
                }
            }
            newVNode = createVNode$1(flags, vNodeToClone.type, null, null, props, vNodeToClone.key, vNodeToClone.ref, true);
            var newProps = newVNode.props;
            var newChildren = newProps.children;
            // we need to also clone component children that are in props
            // as the children may also have been hoisted
            if (newChildren) {
                if (isArray$3(newChildren)) {
                    var len = newChildren.length;
                    if (len > 0) {
                        var tmpArray = [];
                        for (var i = 0; i < len; i++) {
                            var child = newChildren[i];
                            if (isStringOrNumber(child)) {
                                tmpArray.push(child);
                            } else if (!isInvalid(child) && isVNode(child)) {
                                tmpArray.push(directClone(child));
                            }
                        }
                        newProps.children = tmpArray;
                    }
                } else if (isVNode(newChildren)) {
                    newProps.children = directClone(newChildren);
                }
            }
            newVNode.children = null;
        } else if (flags & 3970 /* Element */) {
            var children = vNodeToClone.children;
            var props$1;
            var propsToClone$1 = vNodeToClone.props;
            if (propsToClone$1 === null) {
                props$1 = EMPTY_OBJ$1;
            } else {
                props$1 = {};
                for (var key$1 in propsToClone$1) {
                    props$1[key$1] = propsToClone$1[key$1];
                }
            }
            newVNode = createVNode$1(flags, vNodeToClone.type, vNodeToClone.className, children, props$1, vNodeToClone.key, vNodeToClone.ref, !children);
        } else if (flags & 1 /* Text */) {
            newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);
        }
    return newVNode;
}
/*
 directClone is preferred over cloneVNode and used internally also.
 This function makes Inferno backwards compatible.
 And can be tree-shaked by modern bundlers

 Would be nice to combine this with directClone but could not do it without breaking change
 */
/**
 * Clones given virtual node by creating new instance of it
 * @param {VNode} vNodeToClone virtual node to be cloned
 * @param {Props=} props additional props for new virtual node
 * @param {...*} _children new children for new virtual node
 * @returns {VNode} new virtual node
 */
function cloneVNode$1(vNodeToClone, props) {
    var _children = [],
        len$2 = arguments.length - 2;
    while (len$2-- > 0) {
        _children[len$2] = arguments[len$2 + 2];
    }var children = _children;
    var childrenLen = _children.length;
    if (childrenLen > 0 && !isUndefined(_children[0])) {
        if (!props) {
            props = {};
        }
        if (childrenLen === 1) {
            children = _children[0];
        }
        if (!isUndefined(children)) {
            props.children = children;
        }
    }
    var newVNode;
    if (isArray$3(vNodeToClone)) {
        var tmpArray = [];
        for (var i = 0, len = vNodeToClone.length; i < len; i++) {
            tmpArray.push(directClone(vNodeToClone[i]));
        }
        newVNode = tmpArray;
    } else {
        var flags = vNodeToClone.flags;
        var className = vNodeToClone.className;
        var key = vNodeToClone.key;
        var ref = vNodeToClone.ref;
        if (props) {
            if (props.hasOwnProperty("className")) {
                className = props.className;
            }
            if (props.hasOwnProperty("ref")) {
                ref = props.ref;
            }
            if (props.hasOwnProperty("key")) {
                key = props.key;
            }
        }
        if (flags & 28 /* Component */) {
                newVNode = createVNode$1(flags, vNodeToClone.type, className, null, !vNodeToClone.props && !props ? EMPTY_OBJ$1 : combineFrom(vNodeToClone.props, props), key, ref, true);
                var newProps = newVNode.props;
                if (newProps) {
                    var newChildren = newProps.children;
                    // we need to also clone component children that are in props
                    // as the children may also have been hoisted
                    if (newChildren) {
                        if (isArray$3(newChildren)) {
                            var len$1 = newChildren.length;
                            if (len$1 > 0) {
                                var tmpArray$1 = [];
                                for (var i$1 = 0; i$1 < len$1; i$1++) {
                                    var child = newChildren[i$1];
                                    if (isStringOrNumber(child)) {
                                        tmpArray$1.push(child);
                                    } else if (!isInvalid(child) && isVNode(child)) {
                                        tmpArray$1.push(directClone(child));
                                    }
                                }
                                newProps.children = tmpArray$1;
                            }
                        } else if (isVNode(newChildren)) {
                            newProps.children = directClone(newChildren);
                        }
                    }
                }
                newVNode.children = null;
            } else if (flags & 3970 /* Element */) {
                children = props && !isUndefined(props.children) ? props.children : vNodeToClone.children;
                newVNode = createVNode$1(flags, vNodeToClone.type, className, children, !vNodeToClone.props && !props ? EMPTY_OBJ$1 : combineFrom(vNodeToClone.props, props), key, ref, false);
            } else if (flags & 1 /* Text */) {
                newVNode = createTextVNode(vNodeToClone.children, key);
            }
    }
    return newVNode;
}
function createVoidVNode() {
    return createVNode$1(4096 /* Void */, null);
}
function createTextVNode(text, key) {
    return createVNode$1(1 /* Text */, null, null, text, null, key);
}
function isVNode(o) {
    return !!o.flags;
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
function applyKey(key, vNode) {
    vNode.key = key;
    return vNode;
}
function applyKeyIfMissing(key, vNode) {
    if (isNumber(key)) {
        key = "." + key;
    }
    if (isNull(vNode.key) || vNode.key[0] === ".") {
        return applyKey(key, vNode);
    }
    return vNode;
}
function applyKeyPrefix(key, vNode) {
    vNode.key = key + vNode.key;
    return vNode;
}
function _normalizeVNodes(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
        var n = nodes[index];
        var key = currentKey + "." + index;
        if (!isInvalid(n)) {
            if (isArray$3(n)) {
                _normalizeVNodes(n, result, 0, key);
            } else {
                if (isStringOrNumber(n)) {
                    n = createTextVNode(n, null);
                } else if (isVNode(n) && n.dom || n.key && n.key[0] === ".") {
                    n = directClone(n);
                }
                if (isNull(n.key) || n.key[0] === ".") {
                    n = applyKey(key, n);
                } else {
                    n = applyKeyPrefix(currentKey, n);
                }
                result.push(n);
            }
        }
    }
}
function normalizeVNodes(nodes) {
    var newNodes;
    // we assign $ which basically means we've flagged this array for future note
    // if it comes back again, we need to clone it, as people are using it
    // in an immutable way
    // tslint:disable
    if (nodes["$"] === true) {
        nodes = nodes.slice();
    } else {
        nodes["$"] = true;
    }
    // tslint:enable
    for (var i = 0, len = nodes.length; i < len; i++) {
        var n = nodes[i];
        if (isInvalid(n) || isArray$3(n)) {
            var result = (newNodes || nodes).slice(0, i);
            _normalizeVNodes(nodes, result, i, "");
            return result;
        } else if (isStringOrNumber(n)) {
            if (!newNodes) {
                newNodes = nodes.slice(0, i);
            }
            newNodes.push(applyKeyIfMissing(i, createTextVNode(n, null)));
        } else if (isVNode(n) && n.dom !== null || isNull(n.key) && (n.flags & 64 /* HasNonKeyedChildren */) === 0) {
            if (!newNodes) {
                newNodes = nodes.slice(0, i);
            }
            newNodes.push(applyKeyIfMissing(i, directClone(n)));
        } else if (newNodes) {
            newNodes.push(applyKeyIfMissing(i, directClone(n)));
        }
    }
    return newNodes || nodes;
}
function normalizeChildren(children) {
    if (isArray$3(children)) {
        return normalizeVNodes(children);
    } else if (isVNode(children) && children.dom !== null) {
        return directClone(children);
    }
    return children;
}
function normalizeProps(vNode, props, children) {
    if (vNode.flags & 3970 /* Element */) {
            if (isNullOrUndef(children) && props.hasOwnProperty("children")) {
                vNode.children = props.children;
            }
            if (props.hasOwnProperty("className")) {
                vNode.className = props.className || null;
                delete props.className;
            }
        }
    if (props.hasOwnProperty("ref")) {
        vNode.ref = props.ref;
        delete props.ref;
    }
    if (props.hasOwnProperty("key")) {
        vNode.key = props.key;
        delete props.key;
    }
}
function getFlagsForElementVnode(type) {
    if (type === "svg") {
        return 128 /* SvgElement */;
    } else if (type === "input") {
        return 512 /* InputElement */;
    } else if (type === "select") {
        return 2048 /* SelectElement */;
    } else if (type === "textarea") {
        return 1024 /* TextareaElement */;
    } else if (type === "media") {
        return 256 /* MediaElement */;
    }
    return 2 /* HtmlElement */;
}
function normalize(vNode) {
    var props = vNode.props;
    var children = vNode.children;
    // convert a wrongly created type back to element
    // Primitive node doesn't have defaultProps, only Component
    if (vNode.flags & 28 /* Component */) {
            // set default props
            var type = vNode.type;
            var defaultProps = type.defaultProps;
            if (!isNullOrUndef(defaultProps)) {
                if (!props) {
                    props = vNode.props = defaultProps; // Create new object if only defaultProps given
                } else {
                    for (var prop in defaultProps) {
                        if (isUndefined(props[prop])) {
                            props[prop] = defaultProps[prop];
                        }
                    }
                }
            }
            if (isString(type)) {
                vNode.flags = getFlagsForElementVnode(type);
                if (props && props.children) {
                    vNode.children = props.children;
                    children = props.children;
                }
            }
        }
    if (props) {
        normalizeProps(vNode, props, children);
        if (!isInvalid(props.children)) {
            props.children = normalizeChildren(props.children);
        }
    }
    if (!isInvalid(children)) {
        vNode.children = normalizeChildren(children);
    }
    {
        // This code will be stripped out from production CODE
        // It helps users to track errors in their applications.
        var verifyKeys = function verifyKeys(vNodes) {
            var keyValues = vNodes.map(function (vnode) {
                return vnode.key;
            });
            keyValues.some(function (item, idx) {
                var hasDuplicate = keyValues.indexOf(item) !== idx;
                if (hasDuplicate) {
                    warning("Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:" + item);
                }
                return hasDuplicate;
            });
        };
        if (vNode.children && Array.isArray(vNode.children)) {
            verifyKeys(vNode.children);
        }
    }
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
/**
 * Links given data to event as first parameter
 * @param {*} data data to be linked, it will be available in function as first parameter
 * @param {Function} event Function to be called when event occurs
 * @returns {{data: *, event: Function}}
 */
function linkEvent(data, event) {
    if (isFunction(event)) {
        return { data: data, event: event };
    }
    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers
}

/**
 * @module Inferno
 */ /** TypeDoc Comment */
/* tslint:disable:object-literal-sort-keys */
{
    /* tslint:disable-next-line:no-empty */
    var testFunc = function testFn() {};
    if ((testFunc.name || testFunc.toString()).indexOf("testFn") === -1) {
        warning("It looks like you're using a minified copy of the development build " + "of Inferno. When deploying Inferno apps to production, make sure to use " + "the production build which skips development warnings and is faster. " + "See http://infernojs.org for more details.");
    }
}
var version$2 = "3.9.0";
// we duplicate it so it plays nicely with different module loading systems
var index$3 = {
    EMPTY_OBJ: EMPTY_OBJ$1,
    NO_OP: NO_OP$1,
    cloneVNode: cloneVNode$1,
    createRenderer: createRenderer,
    createVNode: createVNode$1,
    findDOMNode: findDOMNode$1,
    getFlagsForElementVnode: getFlagsForElementVnode,
    internal_DOMNodeMap: componentToDOMNodeMap,
    internal_isUnitlessNumber: isUnitlessNumber,
    internal_normalize: normalize,
    internal_patch: patch,
    linkEvent: linkEvent,
    options: options,
    render: render$2,
    version: version$2
};



var index_es = Object.freeze({
	EMPTY_OBJ: EMPTY_OBJ$1,
	NO_OP: NO_OP$1,
	cloneVNode: cloneVNode$1,
	createRenderer: createRenderer,
	createVNode: createVNode$1,
	findDOMNode: findDOMNode$1,
	getFlagsForElementVnode: getFlagsForElementVnode,
	internal_DOMNodeMap: componentToDOMNodeMap,
	internal_isUnitlessNumber: isUnitlessNumber,
	internal_normalize: normalize,
	internal_patch: patch,
	linkEvent: linkEvent,
	options: options,
	render: render$2,
	version: version$2,
	default: index$3
});

/**
 * @module Inferno-Shared
 */ /** TypeDoc Comment */
var NO_OP$2 = "$NO_OP";
var ERROR_MSG$1 = "a runtime error occured! Use Inferno in development environment to find the error.";
// this is MUCH faster than .constructor === Array and instanceof Array
// in Node 7 and the later versions of V8, slower in older versions though
var isArray$4 = Array.isArray;
function isStringOrNumber$1(o) {
    var type = typeof o === "undefined" ? "undefined" : babelHelpers.typeof(o);
    return type === "string" || type === "number";
}
function isNullOrUndef$1(o) {
    return isUndefined$1(o) || isNull$1(o);
}
function isInvalid$1(o) {
    return isNull$1(o) || o === false || isTrue$1(o) || isUndefined$1(o);
}
function isFunction$1(o) {
    return typeof o === "function";
}
function isNull$1(o) {
    return o === null;
}
function isTrue$1(o) {
    return o === true;
}
function isUndefined$1(o) {
    return o === void 0;
}
function throwError$1(message) {
    if (!message) {
        message = ERROR_MSG$1;
    }
    throw new Error("Inferno Error: " + message);
}
function combineFrom$1(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}

/**
 * @module Inferno-Component
 */ /** TypeDoc Comment */
// Make sure u use EMPTY_OBJ from 'inferno', otherwise it'll be a different reference
var noOp = ERROR_MSG$1;
{
    noOp = "Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.";
}
var componentCallbackQueue = new Map();
// when a components root VNode is also a component, we can run into issues
// this will recursively look for vNode.parentNode if the VNode is a component
function updateParentComponentVNodes(vNode, dom) {
    if (vNode.flags & 28 /* Component */) {
            var parentVNode = vNode.parentVNode;
            if (parentVNode) {
                parentVNode.dom = dom;
                updateParentComponentVNodes(parentVNode, dom);
            }
        }
}
var resolvedPromise = Promise.resolve();
function addToQueue(component, force, callback) {
    var queue = componentCallbackQueue.get(component);
    if (queue === void 0) {
        queue = [];
        componentCallbackQueue.set(component, queue);
        resolvedPromise.then(function () {
            componentCallbackQueue.delete(component);
            component._updating = true;
            applyState(component, force, function () {
                for (var i = 0, len = queue.length; i < len; i++) {
                    queue[i].call(component);
                }
            });
            component._updating = false;
        });
    }
    if (!isNullOrUndef$1(callback)) {
        queue.push(callback);
    }
}
function queueStateChanges(component, newState, callback) {
    if (isFunction$1(newState)) {
        newState = newState(component.state, component.props, component.context);
    }
    var pending = component._pendingState;
    if (isNullOrUndef$1(pending)) {
        component._pendingState = newState;
    } else {
        for (var stateKey in newState) {
            pending[stateKey] = newState[stateKey];
        }
    }
    if (!component._pendingSetState && !component._blockRender) {
        if (!component._updating) {
            component._pendingSetState = true;
            component._updating = true;
            applyState(component, false, callback);
            component._updating = false;
        } else {
            addToQueue(component, false, callback);
        }
    } else {
        component._pendingSetState = true;
        if (!isNullOrUndef$1(callback) && component._blockRender) {
            component._lifecycle.addListener(callback.bind(component));
        }
    }
}
function applyState(component, force, callback) {
    if (component._unmounted) {
        return;
    }
    if (force || !component._blockRender) {
        component._pendingSetState = false;
        var pendingState = component._pendingState;
        var prevState = component.state;
        var nextState = combineFrom$1(prevState, pendingState);
        var props = component.props;
        var context = component.context;
        component._pendingState = null;
        var nextInput;
        var renderOutput = component._updateComponent(prevState, nextState, props, props, context, force, true);
        var didUpdate = true;
        if (isInvalid$1(renderOutput)) {
            nextInput = createVNode$1(4096 /* Void */, null);
        } else if (renderOutput === NO_OP$2) {
            nextInput = component._lastInput;
            didUpdate = false;
        } else if (isStringOrNumber$1(renderOutput)) {
            nextInput = createVNode$1(1 /* Text */, null, null, renderOutput);
        } else if (isArray$4(renderOutput)) {
            {
                throwError$1("a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.");
            }
            return throwError$1();
        } else {
            nextInput = renderOutput;
        }
        var lastInput = component._lastInput;
        var vNode = component._vNode;
        var parentDom = lastInput.dom && lastInput.dom.parentNode || (lastInput.dom = vNode.dom);
        if (nextInput.flags & 28 /* Component */) {
                nextInput.parentVNode = vNode;
            }
        component._lastInput = nextInput;
        if (didUpdate) {
            var childContext;
            if (!isNullOrUndef$1(component.getChildContext)) {
                childContext = component.getChildContext();
            }
            if (isNullOrUndef$1(childContext)) {
                childContext = component._childContext;
            } else {
                childContext = combineFrom$1(context, childContext);
            }
            var lifeCycle = component._lifecycle;
            patch(lastInput, nextInput, parentDom, lifeCycle, childContext, component._isSVG, false);
            // If this component was unmounted by its parent, do nothing. This is no-op
            if (component._unmounted) {
                return;
            }
            lifeCycle.trigger();
            if (!isNullOrUndef$1(component.componentDidUpdate)) {
                component.componentDidUpdate(props, prevState, context);
            }
            if (!isNull$1(options.afterUpdate)) {
                options.afterUpdate(vNode);
            }
        }
        var dom = vNode.dom = nextInput.dom;
        if (options.findDOMNodeEnabled) {
            componentToDOMNodeMap.set(component, nextInput.dom);
        }
        updateParentComponentVNodes(vNode, dom);
    } else {
        component.state = component._pendingState;
        component._pendingState = null;
    }
    if (!isNullOrUndef$1(callback)) {
        callback.call(component);
    }
}
var Component$1 = function Component$1(props, context) {
    this.state = null;
    this._blockRender = false;
    this._blockSetState = true;
    this._pendingSetState = false;
    this._pendingState = null;
    this._lastInput = null;
    this._vNode = null;
    this._unmounted = false;
    this._lifecycle = null;
    this._childContext = null;
    this._isSVG = false;
    this._updating = true;
    /** @type {object} */
    this.props = props || EMPTY_OBJ$1;
    /** @type {object} */
    this.context = context || EMPTY_OBJ$1; // context should not be mutable
};
Component$1.prototype.forceUpdate = function forceUpdate(callback) {
    if (this._unmounted) {
        return;
    }
    applyState(this, true, callback);
};
Component$1.prototype.setState = function setState(newState, callback) {
    if (this._unmounted) {
        return;
    }
    if (!this._blockSetState) {
        queueStateChanges(this, newState, callback);
    } else {
        {
            throwError$1("cannot update state via setState() in componentWillUpdate() or constructor.");
        }
        throwError$1();
    }
};
Component$1.prototype._updateComponent = function _updateComponent(prevState, nextState, prevProps, nextProps, context, force, fromSetState) {
    if (this._unmounted === true) {
        {
            throwError$1(noOp);
        }
        throwError$1();
    }
    if (prevProps !== nextProps || nextProps === EMPTY_OBJ$1 || prevState !== nextState || force) {
        if (prevProps !== nextProps || nextProps === EMPTY_OBJ$1) {
            if (!isNullOrUndef$1(this.componentWillReceiveProps) && !fromSetState) {
                this._blockRender = true;
                this.componentWillReceiveProps(nextProps, context);
                // If this component was removed during its own update do nothing...
                if (this._unmounted) {
                    return NO_OP$2;
                }
                this._blockRender = false;
            }
            if (this._pendingSetState) {
                nextState = combineFrom$1(nextState, this._pendingState);
                this._pendingSetState = false;
                this._pendingState = null;
            }
        }
        /* Update if scu is not defined, or it returns truthy value or force */
        if (force || isNullOrUndef$1(this.shouldComponentUpdate) || this.shouldComponentUpdate && this.shouldComponentUpdate(nextProps, nextState, context)) {
            if (!isNullOrUndef$1(this.componentWillUpdate)) {
                this._blockSetState = true;
                this.componentWillUpdate(nextProps, nextState, context);
                this._blockSetState = false;
            }
            this.props = nextProps;
            this.state = nextState;
            this.context = context;
            if (options.beforeRender) {
                options.beforeRender(this);
            }
            var render$$1 = this.render(nextProps, nextState, context);
            if (options.afterRender) {
                options.afterRender(this);
            }
            return render$$1;
        } else {
            this.props = nextProps;
            this.state = nextState;
            this.context = context;
        }
    }
    return NO_OP$2;
};
// tslint:disable-next-line:no-empty
Component$1.prototype.render = function render(nextProps, nextState, nextContext) {};



var index_es$1 = Object.freeze({
	default: Component$1
});

var require$$1$22 = ( index_es && index_es['default'] ) || index_es;

var require$$0$25 = ( index_es$1 && index_es$1['default'] ) || index_es$1;

var index_1 = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault(ex) {
    return ex && (typeof ex === 'undefined' ? 'undefined' : babelHelpers.typeof(ex)) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var inferno = require$$1$22;
var Component = _interopDefault(require$$0$25);

/**
 * @module Inferno-Shared
 */ /** TypeDoc Comment */
var ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
function isNullOrUndef(o) {
    return isUndefined(o) || isNull(o);
}
function isFunction(o) {
    return typeof o === "function";
}
function isNull(o) {
    return o === null;
}
function isUndefined(o) {
    return o === void 0;
}
function isObject(o) {
    return (typeof o === 'undefined' ? 'undefined' : babelHelpers.typeof(o)) === "object";
}
function throwError(message) {
    if (!message) {
        message = ERROR_MSG;
    }
    throw new Error("Inferno Error: " + message);
}

/**
 * @module Inferno-Create-Class
 */ /** TypeDoc Comment */
// don't autobind these methods since they already have guaranteed context.
var AUTOBIND_BLACKLIST = new Set();
AUTOBIND_BLACKLIST.add("constructor");
AUTOBIND_BLACKLIST.add("render");
AUTOBIND_BLACKLIST.add("shouldComponentUpdate");
AUTOBIND_BLACKLIST.add("componentWillReceiveProps");
AUTOBIND_BLACKLIST.add("componentWillUpdate");
AUTOBIND_BLACKLIST.add("componentDidUpdate");
AUTOBIND_BLACKLIST.add("componentWillMount");
AUTOBIND_BLACKLIST.add("componentDidMount");
AUTOBIND_BLACKLIST.add("componentWillUnmount");
AUTOBIND_BLACKLIST.add("componentDidUnmount");
function extend(base, props) {
    for (var key in props) {
        if (!isNullOrUndef(props[key])) {
            base[key] = props[key];
        }
    }
    return base;
}
function bindAll(ctx) {
    for (var i in ctx) {
        var v = ctx[i];
        if (typeof v === "function" && !v.__bound && !AUTOBIND_BLACKLIST.has(i)) {
            (ctx[i] = v.bind(ctx)).__bound = true;
        }
    }
}
function collateMixins(mixins, keyed) {
    if (keyed === void 0) {
        keyed = {};
    }

    for (var i = 0, len = mixins.length; i < len; i++) {
        var mixin = mixins[i];
        // Surprise: Mixins can have mixins
        if (mixin.mixins) {
            // Recursively collate sub-mixins
            collateMixins(mixin.mixins, keyed);
        }
        for (var key in mixin) {
            if (mixin.hasOwnProperty(key) && typeof mixin[key] === "function") {
                (keyed[key] || (keyed[key] = [])).push(mixin[key]);
            }
        }
    }
    return keyed;
}
function multihook(hooks, mergeFn) {
    return function () {
        var arguments$1 = arguments;
        var this$1 = this;

        var ret;
        for (var i = 0, len = hooks.length; i < len; i++) {
            var hook = hooks[i];
            var r = hook.apply(this$1, arguments$1);
            if (mergeFn) {
                ret = mergeFn(ret, r);
            } else if (!isUndefined(r)) {
                ret = r;
            }
        }
        return ret;
    };
}
function mergeNoDupes(previous, current) {
    if (!isUndefined(current)) {
        if (!isObject(current)) {
            throwError("Expected Mixin to return value to be an object or null.");
        }
        if (!previous) {
            previous = {};
        }
        for (var key in current) {
            if (current.hasOwnProperty(key)) {
                if (previous.hasOwnProperty(key)) {
                    throwError("Mixins return duplicate key " + key + " in their return values");
                }
                previous[key] = current[key];
            }
        }
    }
    return previous;
}
function applyMixin(key, inst, mixin) {
    var hooks = isUndefined(inst[key]) ? mixin : mixin.concat(inst[key]);
    if (key === "getDefaultProps" || key === "getInitialState" || key === "getChildContext") {
        inst[key] = multihook(hooks, mergeNoDupes);
    } else {
        inst[key] = multihook(hooks);
    }
}
function applyMixins(Cl, mixins) {
    for (var key in mixins) {
        if (mixins.hasOwnProperty(key)) {
            var mixin = mixins[key];
            var inst = void 0;
            if (key === "getDefaultProps") {
                inst = Cl;
            } else {
                inst = Cl.prototype;
            }
            if (isFunction(mixin[0])) {
                applyMixin(key, inst, mixin);
            } else {
                inst[key] = mixin;
            }
        }
    }
}
function createClass(obj) {
    var Cl = function (Component$$1) {
        function Cl(props, context) {
            Component$$1.call(this, props, context);
            bindAll(this);
            if (this.getInitialState) {
                this.state = this.getInitialState();
            }
        }

        if (Component$$1) {
            Cl.__proto__ = Component$$1;
        }
        Cl.prototype = Object.create(Component$$1 && Component$$1.prototype);
        Cl.prototype.constructor = Cl;
        Cl.prototype.replaceState = function replaceState(nextState, callback) {
            this.setState(nextState, callback);
        };
        Cl.prototype.isMounted = function isMounted() {
            return !this._unmounted;
        };

        return Cl;
    }(Component);
    Cl.displayName = obj.displayName || "Component";
    Cl.propTypes = obj.propTypes;
    Cl.mixins = obj.mixins && collateMixins(obj.mixins);
    Cl.getDefaultProps = obj.getDefaultProps;
    extend(Cl.prototype, obj);
    if (obj.statics) {
        extend(Cl, obj.statics);
    }
    if (obj.mixins) {
        applyMixins(Cl, collateMixins(obj.mixins));
    }
    Cl.defaultProps = isUndefined(Cl.getDefaultProps) ? undefined : Cl.getDefaultProps();
    return Cl;
}

/**
 * @module Inferno-Shared
 */ /** TypeDoc Comment */
function isNullOrUndef$1(o) {
    return isUndefined$1(o) || isNull$1(o);
}
function isInvalid(o) {
    return isNull$1(o) || o === false || isTrue(o) || isUndefined$1(o);
}
function isString(o) {
    return typeof o === "string";
}
function isNull$1(o) {
    return o === null;
}
function isTrue(o) {
    return o === true;
}
function isUndefined$1(o) {
    return o === void 0;
}
function isObject$1(o) {
    return (typeof o === 'undefined' ? 'undefined' : babelHelpers.typeof(o)) === "object";
}

/**
 * @module Inferno-Create-Element
 */ /** TypeDoc Comment */
var componentHooks = new Set();
componentHooks.add("onComponentWillMount");
componentHooks.add("onComponentDidMount");
componentHooks.add("onComponentWillUnmount");
componentHooks.add("onComponentShouldUpdate");
componentHooks.add("onComponentWillUpdate");
componentHooks.add("onComponentDidUpdate");
/**
 * Creates virtual node
 * @param {string|Function|Component<any, any>} type Type of node
 * @param {object=} props Optional props for virtual node
 * @param {...{object}=} _children Optional children for virtual node
 * @returns {VNode} new virtual ndoe
 */
function createElement$1(type, props) {
    var arguments$1 = arguments;

    var _children = [],
        len = arguments.length - 2;
    while (len-- > 0) {
        _children[len] = arguments$1[len + 2];
    }

    if (isInvalid(type) || isObject$1(type)) {
        throw new Error("Inferno Error: createElement() name parameter cannot be undefined, null, false or true, It must be a string, class or function.");
    }
    var children = _children;
    var ref = null;
    var key = null;
    var className = null;
    var flags = 0;
    var newProps;
    if (_children) {
        if (_children.length === 1) {
            children = _children[0];
        } else if (_children.length === 0) {
            children = void 0;
        }
    }
    if (isString(type)) {
        flags = inferno.getFlagsForElementVnode(type);
        if (!isNullOrUndef$1(props)) {
            newProps = {};
            for (var prop in props) {
                if (prop === "className" || prop === "class") {
                    className = props[prop];
                } else if (prop === "key") {
                    key = props.key;
                } else if (prop === "children" && isUndefined$1(children)) {
                    children = props.children; // always favour children args, default to props
                } else if (prop === "ref") {
                    ref = props.ref;
                } else {
                    newProps[prop] = props[prop];
                }
            }
        }
    } else {
        flags = 16 /* ComponentUnknown */;
        if (!isUndefined$1(children)) {
            if (!props) {
                props = {};
            }
            props.children = children;
            children = null;
        }
        if (!isNullOrUndef$1(props)) {
            newProps = {};
            for (var prop$1 in props) {
                if (componentHooks.has(prop$1)) {
                    if (!ref) {
                        ref = {};
                    }
                    ref[prop$1] = props[prop$1];
                } else if (prop$1 === "key") {
                    key = props.key;
                } else {
                    newProps[prop$1] = props[prop$1];
                }
            }
        }
    }
    return inferno.createVNode(flags, type, className, children, newProps, key, ref);
}

/**
 * @module Inferno-Shared
 */ /** TypeDoc Comment */
var NO_OP = "$NO_OP";
// This should be boolean and not reference to window.document
var isBrowser = !!(typeof window !== "undefined" && window.document);
// this is MUCH faster than .constructor === Array and instanceof Array
// in Node 7 and the later versions of V8, slower in older versions though
var isArray = Array.isArray;
function isNullOrUndef$2(o) {
    return isUndefined$2(o) || isNull$2(o);
}
function isFunction$1(o) {
    return typeof o === "function";
}
function isString$1(o) {
    return typeof o === "string";
}
function isNull$2(o) {
    return o === null;
}
function isUndefined$2(o) {
    return o === void 0;
}
function isObject$2(o) {
    return (typeof o === 'undefined' ? 'undefined' : babelHelpers.typeof(o)) === "object";
}

/**
 * @module Inferno-Compat
 */ /** TypeDoc Comment */
function isValidElement(obj) {
    var isNotANullObject = isObject$2(obj) && isNull$2(obj) === false;
    if (isNotANullObject === false) {
        return false;
    }
    var flags = obj.flags;
    return (flags & (28 /* Component */ | 3970 /* Element */)) > 0;
}

/**
 * @module Inferno-Compat
 */
/**
 * Inlined PropTypes, there is propType checking ATM.
 */
// tslint:disable-next-line:no-empty
function proptype() {}
proptype.isRequired = proptype;
var getProptype = function getProptype() {
    return proptype;
};
var PropTypes = {
    any: getProptype,
    array: proptype,
    arrayOf: getProptype,
    bool: proptype,
    checkPropTypes: function checkPropTypes() {
        return null;
    },
    element: getProptype,
    func: proptype,
    instanceOf: getProptype,
    node: getProptype,
    number: proptype,
    object: proptype,
    objectOf: getProptype,
    oneOf: getProptype,
    oneOfType: getProptype,
    shape: getProptype,
    string: proptype,
    symbol: proptype
};

/**
 * @module Inferno-Compat
 */ /** TypeDoc Comment */
/**
 * borrowed React SVGDOMPropertyConfig
 * @link https://github.com/facebook/react/blob/c78464f8ea9a5b00ec80252d20a71a1482210e57/src/renderers/dom/shared/SVGDOMPropertyConfig.js
 */
var SVGDOMPropertyConfig = {
    accentHeight: "accent-height",
    accumulate: 0,
    additive: 0,
    alignmentBaseline: "alignment-baseline",
    allowReorder: "allowReorder",
    alphabetic: 0,
    amplitude: 0,
    arabicForm: "arabic-form",
    ascent: 0,
    attributeName: "attributeName",
    attributeType: "attributeType",
    autoReverse: "autoReverse",
    azimuth: 0,
    baseFrequency: "baseFrequency",
    baseProfile: "baseProfile",
    baselineShift: "baseline-shift",
    bbox: 0,
    begin: 0,
    bias: 0,
    by: 0,
    calcMode: "calcMode",
    capHeight: "cap-height",
    clip: 0,
    clipPath: "clip-path",
    clipPathUnits: "clipPathUnits",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    contentScriptType: "contentScriptType",
    contentStyleType: "contentStyleType",
    cursor: 0,
    cx: 0,
    cy: 0,
    d: 0,
    decelerate: 0,
    descent: 0,
    diffuseConstant: "diffuseConstant",
    direction: 0,
    display: 0,
    divisor: 0,
    dominantBaseline: "dominant-baseline",
    dur: 0,
    dx: 0,
    dy: 0,
    edgeMode: "edgeMode",
    elevation: 0,
    enableBackground: "enable-background",
    end: 0,
    exponent: 0,
    externalResourcesRequired: "externalResourcesRequired",
    fill: 0,
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    filter: 0,
    filterRes: "filterRes",
    filterUnits: "filterUnits",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    focusable: 0,
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    format: 0,
    from: 0,
    fx: 0,
    fy: 0,
    g1: 0,
    g2: 0,
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    glyphRef: "glyphRef",
    gradientTransform: "gradientTransform",
    gradientUnits: "gradientUnits",
    hanging: 0,
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    ideographic: 0,
    imageRendering: "image-rendering",
    in: 0,
    in2: 0,
    intercept: 0,
    k: 0,
    k1: 0,
    k2: 0,
    k3: 0,
    k4: 0,
    kernelMatrix: "kernelMatrix",
    kernelUnitLength: "kernelUnitLength",
    kerning: 0,
    keyPoints: "keyPoints",
    keySplines: "keySplines",
    keyTimes: "keyTimes",
    lengthAdjust: "lengthAdjust",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    limitingConeAngle: "limitingConeAngle",
    local: 0,
    markerEnd: "marker-end",
    markerHeight: "markerHeight",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    markerUnits: "markerUnits",
    markerWidth: "markerWidth",
    mask: 0,
    maskContentUnits: "maskContentUnits",
    maskUnits: "maskUnits",
    mathematical: 0,
    mode: 0,
    numOctaves: "numOctaves",
    offset: 0,
    opacity: 0,
    operator: 0,
    order: 0,
    orient: 0,
    orientation: 0,
    origin: 0,
    overflow: 0,
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pathLength: "pathLength",
    patternContentUnits: "patternContentUnits",
    patternTransform: "patternTransform",
    patternUnits: "patternUnits",
    pointerEvents: "pointer-events",
    points: 0,
    pointsAtX: "pointsAtX",
    pointsAtY: "pointsAtY",
    pointsAtZ: "pointsAtZ",
    preserveAlpha: "preserveAlpha",
    preserveAspectRatio: "preserveAspectRatio",
    primitiveUnits: "primitiveUnits",
    r: 0,
    radius: 0,
    refX: "refX",
    refY: "refY",
    renderingIntent: "rendering-intent",
    repeatCount: "repeatCount",
    repeatDur: "repeatDur",
    requiredExtensions: "requiredExtensions",
    requiredFeatures: "requiredFeatures",
    restart: 0,
    result: 0,
    rotate: 0,
    rx: 0,
    ry: 0,
    scale: 0,
    seed: 0,
    shapeRendering: "shape-rendering",
    slope: 0,
    spacing: 0,
    specularConstant: "specularConstant",
    specularExponent: "specularExponent",
    speed: 0,
    spreadMethod: "spreadMethod",
    startOffset: "startOffset",
    stdDeviation: "stdDeviation",
    stemh: 0,
    stemv: 0,
    stitchTiles: "stitchTiles",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    string: 0,
    stroke: 0,
    strokeDasharray: "stroke-dasharray",
    strokeDashoffset: "stroke-dashoffset",
    strokeLinecap: "stroke-linecap",
    strokeLinejoin: "stroke-linejoin",
    strokeMiterlimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    surfaceScale: "surfaceScale",
    systemLanguage: "systemLanguage",
    tableValues: "tableValues",
    targetX: "targetX",
    targetY: "targetY",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textLength: "textLength",
    textRendering: "text-rendering",
    to: 0,
    transform: 0,
    u1: 0,
    u2: 0,
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicode: 0,
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    values: 0,
    vectorEffect: "vector-effect",
    version: 0,
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    viewBox: "viewBox",
    viewTarget: "viewTarget",
    visibility: 0,
    widths: 0,
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    x: 0,
    x1: 0,
    x2: 0,
    xChannelSelector: "xChannelSelector",
    xHeight: "x-height",
    xlinkActuate: "xlink:actuate",
    xlinkArcrole: "xlink:arcrole",
    xlinkHref: "xlink:href",
    xlinkRole: "xlink:role",
    xlinkShow: "xlink:show",
    xlinkTitle: "xlink:title",
    xlinkType: "xlink:type",
    xmlBase: "xml:base",
    // xmlns: 0,
    xmlLang: "xml:lang",
    xmlSpace: "xml:space",
    xmlnsXlink: "xmlns:xlink",
    y: 0,
    y1: 0,
    y2: 0,
    yChannelSelector: "yChannelSelector",
    z: 0,
    zoomAndPan: "zoomAndPan"
};

/**
 * @module Inferno-Compat
 */ /** TypeDoc Comment */
inferno.options.findDOMNodeEnabled = true;
function unmountComponentAtNode(container) {
    inferno.render(null, container);
    return true;
}
var ARR = [];
var Children = {
    map: function map(children, fn, ctx) {
        if (isNullOrUndef$2(children)) {
            return children;
        }
        children = Children.toArray(children);
        if (ctx && ctx !== children) {
            fn = fn.bind(ctx);
        }
        return children.map(fn);
    },
    forEach: function forEach(children, fn, ctx) {
        if (isNullOrUndef$2(children)) {
            return;
        }
        children = Children.toArray(children);
        if (ctx && ctx !== children) {
            fn = fn.bind(ctx);
        }
        for (var i = 0, len = children.length; i < len; i++) {
            fn(children[i], i, children);
        }
    },
    count: function count(children) {
        children = Children.toArray(children);
        return children.length;
    },
    only: function only(children) {
        children = Children.toArray(children);
        if (children.length !== 1) {
            throw new Error("Children.only() expects only one child.");
        }
        return children[0];
    },
    toArray: function toArray$$1(children) {
        if (isNullOrUndef$2(children)) {
            return [];
        }
        return isArray(children) ? children : ARR.concat(children);
    }
};
Component.prototype.isReactComponent = {};
var currentComponent = null;
inferno.options.beforeRender = function (component) {
    currentComponent = component;
};
inferno.options.afterRender = function () {
    currentComponent = null;
};
var version = "15.4.2";
function normalizeProps(name, props) {
    if ((name === "input" || name === "textarea") && props.type !== "radio" && props.onChange) {
        var type = props.type;
        var eventName;
        if (type === "checkbox") {
            eventName = "onclick";
        } else if (type === "file") {
            eventName = "onchange";
        } else {
            eventName = "oninput";
        }
        if (!props[eventName]) {
            props[eventName] = props.onChange;
            delete props.onChange;
        }
    }
    for (var prop in props) {
        if (prop === "onDoubleClick") {
            props.onDblClick = props[prop];
            delete props[prop];
        }
        if (prop === "htmlFor") {
            props.for = props[prop];
            delete props[prop];
        }
        var mappedProp = SVGDOMPropertyConfig[prop];
        if (mappedProp && mappedProp !== prop) {
            props[mappedProp] = props[prop];
            delete props[prop];
        }
    }
}
// we need to add persist() to Event (as React has it for synthetic events)
// this is a hack and we really shouldn't be modifying a global object this way,
// but there isn't a performant way of doing this apart from trying to proxy
// every prop event that starts with "on", i.e. onClick or onKeyPress
// but in reality devs use onSomething for many things, not only for
// input events
if (typeof Event !== "undefined" && !Event.prototype.persist) {
    // tslint:disable-next-line:no-empty
    Event.prototype.persist = function () {};
}
function iterableToArray(iterable) {
    var iterStep;
    var tmpArr = [];
    do {
        iterStep = iterable.next();
        if (iterStep.value) {
            tmpArr.push(iterStep.value);
        }
    } while (!iterStep.done);
    return tmpArr;
}
var hasSymbolSupport = typeof Symbol !== "undefined";
var injectStringRefs = function injectStringRefs(originalFunction) {
    return function (name, _props) {
        var children = [],
            len$1 = arguments.length - 2;
        while (len$1-- > 0) {
            children[len$1] = arguments[len$1 + 2];
        }var props = _props || {};
        var ref = props.ref;
        if (typeof ref === "string" && !isNull$2(currentComponent)) {
            currentComponent.refs = currentComponent.refs || {};
            props.ref = function (val) {
                this.refs[ref] = val;
            }.bind(currentComponent);
        }
        if (typeof name === "string") {
            normalizeProps(name, props);
        }
        // React supports iterable children, in addition to Array-like
        if (hasSymbolSupport) {
            for (var i = 0, len = children.length; i < len; i++) {
                var child = children[i];
                if (child && !isArray(child) && !isString$1(child) && isFunction$1(child[Symbol.iterator])) {
                    children[i] = iterableToArray(child[Symbol.iterator]());
                }
            }
        }
        var vnode = originalFunction.apply(void 0, [name, props].concat(children));
        if (vnode.className) {
            vnode.props = vnode.props || {};
            vnode.props.className = vnode.className;
        }
        return vnode;
    };
};
var createElement = injectStringRefs(createElement$1);
var cloneElement = injectStringRefs(inferno.cloneVNode);
var oldCreateVNode = inferno.options.createVNode;
inferno.options.createVNode = function (vNode) {
    var children = vNode.children;
    var props = vNode.props;
    if (isNullOrUndef$2(props)) {
        props = vNode.props = {};
    }
    if (!isNullOrUndef$2(children) && isNullOrUndef$2(props.children)) {
        props.children = children;
    }
    if (oldCreateVNode) {
        oldCreateVNode(vNode);
    }
};
// Credit: preact-compat - https://github.com/developit/preact-compat :)
function shallowDiffers(a, b) {
    for (var i in a) {
        if (!(i in b)) {
            return true;
        }
    }
    for (var i$1 in b) {
        if (a[i$1] !== b[i$1]) {
            return true;
        }
    }
    return false;
}
function PureComponent(props, context) {
    Component.call(this, props, context);
}
PureComponent.prototype = new Component({}, {});
PureComponent.prototype.shouldComponentUpdate = function (props, state) {
    return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);
};
var WrapperComponent = function (Component$$1) {
    function WrapperComponent() {
        Component$$1.apply(this, arguments);
    }

    if (Component$$1) WrapperComponent.__proto__ = Component$$1;
    WrapperComponent.prototype = Object.create(Component$$1 && Component$$1.prototype);
    WrapperComponent.prototype.constructor = WrapperComponent;

    WrapperComponent.prototype.getChildContext = function getChildContext() {
        // tslint:disable-next-line
        return this.props["context"];
    };
    WrapperComponent.prototype.render = function render$$1(props) {
        return props.children;
    };

    return WrapperComponent;
}(Component);
function unstable_renderSubtreeIntoContainer(parentComponent, vNode, container, callback) {
    var wrapperVNode = inferno.createVNode(4, WrapperComponent, null, null, {
        children: vNode,
        context: parentComponent.context
    });
    var component = inferno.render(wrapperVNode, container);
    if (callback) {
        // callback gets the component as context, no other argument.
        callback.call(component);
    }
    return component;
}
// Credit: preact-compat - https://github.com/developit/preact-compat
var ELEMENTS = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr circle clipPath defs ellipse g image line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
function createFactory(type) {
    return createElement.bind(null, type);
}
var DOM = {};
for (var i = ELEMENTS.length; i--;) {
    DOM[ELEMENTS[i]] = createFactory(ELEMENTS[i]);
}
// Mask React global in browser enviornments when React is not used.
if (isBrowser && typeof window.React === "undefined") {
    var exports$1 = {
        Children: Children,
        Component: Component,
        DOM: DOM,
        EMPTY_OBJ: inferno.EMPTY_OBJ,
        NO_OP: NO_OP,
        PropTypes: PropTypes,
        PureComponent: PureComponent,
        cloneElement: cloneElement,
        cloneVNode: inferno.cloneVNode,
        createClass: createClass,
        createElement: createElement,
        createFactory: createFactory,
        createVNode: inferno.createVNode,
        findDOMNode: inferno.findDOMNode,
        isValidElement: isValidElement,
        render: inferno.render,
        unmountComponentAtNode: unmountComponentAtNode,
        unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainer,
        version: version
    };
    window.React = exports$1;
    window.ReactDOM = exports$1;
}
var index = {
    Children: Children,
    Component: Component,
    DOM: DOM,
    EMPTY_OBJ: inferno.EMPTY_OBJ,
    NO_OP: NO_OP,
    PropTypes: PropTypes,
    PureComponent: PureComponent,
    cloneElement: cloneElement,
    cloneVNode: inferno.cloneVNode,
    createClass: createClass,
    createElement: createElement,
    createFactory: createFactory,
    createVNode: inferno.createVNode,
    findDOMNode: inferno.findDOMNode,
    isValidElement: isValidElement,
    render: inferno.render,
    unmountComponentAtNode: unmountComponentAtNode,
    unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainer,
    version: version
};

exports.Children = Children;
exports.Component = Component;
exports.DOM = DOM;
exports.EMPTY_OBJ = inferno.EMPTY_OBJ;
exports.NO_OP = NO_OP;
exports.PropTypes = PropTypes;
exports.PureComponent = PureComponent;
exports.cloneElement = cloneElement;
exports.cloneVNode = inferno.cloneVNode;
exports.createClass = createClass;
exports.createElement = createElement;
exports.createFactory = createFactory;
exports.createVNode = inferno.createVNode;
exports.findDOMNode = inferno.findDOMNode;
exports.isValidElement = isValidElement;
exports.render = inferno.render;
exports.unmountComponentAtNode = unmountComponentAtNode;
exports.unstable_renderSubtreeIntoContainer = unstable_renderSubtreeIntoContainer;
exports.version = version;
exports['default'] = index;
});

var index$1 = createCommonjsModule(function (module) {
module.exports = index_1.default;
module.exports.default = module.exports;
});

/**
 * Test whether a string is camel-case.
 */

var hasSpace = /\s/;
var hasSeparator = /(_|-|\.|:)/;
var hasCamel = /([a-z][A-Z]|[A-Z][a-z])/;

function toSlugCase(string) {
  return toSpaceCase(string).replace(/\s/g, '-');
}

/**
 * Remove any starting case from a `string`, like camel or snake, but keep
 * spaces and punctuation that may be important otherwise.
 *
 * @param {String} string
 * @return {String}
 */

function toNoCase(string) {
  if (hasSpace.test(string)) return string.toLowerCase();
  if (hasSeparator.test(string)) return (unseparate(string) || string).toLowerCase();
  if (hasCamel.test(string)) return uncamelize(string).toLowerCase();
  return string.toLowerCase();
}

function toSpaceCase(string) {
  return toNoCase(string).replace(/[\W_]+(.|$)/g, function (matches, match) {
    return match ? ' ' + match : '';
  }).trim();
}

/**
 * Separator splitter.
 */

var separatorSplitter = /[\W_]+(.|$)/g;

/**
 * Un-separate a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function unseparate(string) {
  return string.replace(separatorSplitter, function (m, next) {
    return next ? ' ' + next : '';
  });
}

/**
 * Camelcase splitter.
 */

var camelSplitter = /(.)([A-Z]+)/g;

/**
 * Un-camelcase a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function uncamelize(string) {
  return string.replace(camelSplitter, function (m, previous, uppers) {
    return previous + ' ' + uppers.toLowerCase().split('').join(' ');
  });
}

var uniqueCallSymbol = Symbol('unique call');
var eStateSymbol = Symbol('extension state');

/* Enhancing a custom element class that extends HTMLElement */
function AsCustomElement(opts) {
    var _opts$treeRenderer = opts.treeRenderer,
        treeRenderer = _opts$treeRenderer === undefined ? defaultTreeRenderer : _opts$treeRenderer,
        _connectedCallback = opts.connectedCallback,
        _disconnectedCallback = opts.disconnectedCallback,
        state = opts.state,
        propsExtractorSelector = opts.propsExtractorSelector,
        propsExtractor = opts.propsExtractor,
        _opts$compute = opts.compute,
        compute = _opts$compute === undefined ? true : _opts$compute,
        tag = opts.tag;

    var _ref = state ? state(opts) : {},
        connect = _ref.connect,
        decorateComponent = _ref.decorateComponent;

    //TODO marking methods on component class as @ExposeOnElement()

    return function decorator(BaseComponent) {
        var _extendedProperties = extendedProperties(BaseComponent.properties || {}),
            properties = _extendedProperties.properties,
            defaults = _extendedProperties.defaults;

        var observedAttributes = Object.keys(properties);
        //TODO filter out non attribute properties

        /**
         * Render function to use in output of other components directly rather than using the tag.
         *
         function Bigger(props) {
            return <CustomElement.asComponent a={1} b="2"/>;
        }
          */
        function asComponent(props) {
            //TODO props 2 attributes
            // - call content renderer
            createElement(opts.tag, props);
        }

        var customElement = function (_HTMLElement) {
            babelHelpers.inherits(customElement, _HTMLElement);

            function customElement() {
                var _ref2;

                babelHelpers.classCallCheck(this, customElement);

                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                var _this = babelHelpers.possibleConstructorReturn(this, (_ref2 = customElement.__proto__ || Object.getPrototypeOf(customElement)).call.apply(_ref2, [this].concat(args)));

                _this[eStateSymbol] = treeRenderer(_this, BaseComponent, decorateComponent);
                _this.attributeChangedCallback = uniqueCall(_this, 'attributeChangedCallback');
                _this.seedProps = {};
                if (propsExtractor) {
                    var children = propsExtractorSelector ? _this.querySelectorAll(propsExtractorSelector) : _this.children;
                    // if made via sub-render it will be in vNode.children
                    Object.assign(_this.seedProps, propsExtractor(Array.from(children), _this));
                }

                return _this;
            }

            babelHelpers.createClass(customElement, [{
                key: 'connectedCallback',
                value: function connectedCallback() {
                    var internal = this[eStateSymbol];
                    var props = getProperties(this, properties, defaults);

                    // Chrome 54 has native custom elements and isn't DRE's issue. The spec says explicitly that this error will be thrown if you try and set attributes in the constructor. You can set properties, but attributes mist be deferred until connectedCallback.
                    this.setAttribute('defined', '');

                    if (connect) {
                        // consider this pattern of mixing into internal
                        Object.assign(internal, connect(this, props, internal));
                        Object.defineProperty(this, 'state', { get: internal.getState, set: function set(change) {
                                return internal.dispatch(actionForChange(change));
                            } });
                        if (internal.extractState) internal.extractState();
                    }
                    internal.connected = true;

                    if (_connectedCallback) _connectedCallback(this, internal.component, props);

                    internal.rootRender(props);
                    // component.componentWillMount is called during creation inferno/utils createClassComponentInstance
                }
            }, {
                key: 'attributeChangedCallback',
                value: function attributeChangedCallback(name, oldValue, newValue) {
                    var internal = this[eStateSymbol];
                    //TODO cache properties to make getProperties faster
                    // trigger render

                    var props = getProperties(this, properties, defaults);

                    //TODO trigger props update on component instead

                    internal.rootRender(props);
                }

                /**
                 * Changes are done by dispatching store actions. `actionForChange` can be seen as the reverse
                 * of the stateSelector.
                 */
                //TODO just go with dispatch

            }, {
                key: 'setState',
                value: function setState(change) {
                    internal.dispatch(actionForChange(change));
                }
            }, {
                key: 'disconnectedCallback',
                value: function disconnectedCallback() {
                    var internal = this[eStateSymbol];
                    if (_disconnectedCallback) _disconnectedCallback.call(this, internal.component);
                    //TODO unmount component
                    internal.destroy();
                    internal.connected = false;
                }
            }, {
                key: 'observedAttributes',
                get: function get() {
                    return observedAttributes;
                }
            }]);
            return customElement;
        }(HTMLElement);

        customElement.asComponent = asComponent;
        
        if (tag) {
            customElements.define(tag, customElement); // Web Components API, perhaps register and queue for ordered reg
        }
        return customElement;
    };
}

function defaultTreeRenderer() {
    return {
        create: function create() {},
        destroy: function destroy() {},
        setState: function setState() {},
        rootRender: function rootRender() {}
    };
}

function uniqueCall(instance, name) {
    var fn = typeof name === 'function' ? name : instance[name];

    instance[uniqueCallSymbol] = [];

    return function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        var pastArgs = instance[uniqueCallSymbol];
        instance[uniqueCallSymbol] = args;
        if (args.length !== pastArgs.length) return fn.apply(instance, args);
        for (var i = 0; i < args.length; ++i) {
            if (args[i] === pastArgs[i]) {
                return fn.apply(instance, args);
            }
        }return fn.apply(instance, args);
    };
}

/*
Interpret Polymer like properties
https://www.polymer-project.org/1.0/docs/devguide/properties

count: {
      type: Number,
      readOnly: true,
      notify: true
    }
*/

function extendedProperties(properties) {
    return Object.keys(properties).reduce(function (result, propName) {
        var prop = properties[propName];
        var slugName = toSlugCase(propName);
        if ((typeof prop === 'undefined' ? 'undefined' : babelHelpers.typeof(prop)) === 'object' && typeof prop.attribute === 'string') {
            slugName = prop.attribute;
        }
        if (prop.hasOwnProperty('default')) result.defaults[propName] = result.defaults[slugName] = prop.default;
        result.properties[propName] = result.properties[slugName] = makeProp(propName, slugName, prop);
        return result;
    }, { properties: {}, defaults: {} });

    function makeProp(codeName, slugName, prop) {
        //enhance from Class to Object
        //TODO coerce function
        return typeof prop === 'function' ? {
            type: prop,
            codeName: codeName,
            slugName: slugName,
            attribute: true,
            coerce: function coerce(value) {
                return value;
            }
        } : babelHelpers.extends({}, prop, {
            codeName: codeName,
            slugName: slugName,
            attribute: prop.attribute !== false,
            coerce: prop.coerce || function (value) {
                return value;
            }
        });
    }
}

//TODO build on attrs2props
//TODO coerce types from attributes
function getProperties(el, properties, defaults) {
    var attributes = Array.from(el.attributes);
    return attributes.reduce(function (result, attr) {
        var prop = properties[attr.name];
        /* prop API:
            coerce()
            attribute: string|boolean
            codeName
            slugName
            default
        */
        if (prop !== undefined) {
            var value = result[prop.codeName];
            if (prop.type === Array) {
                switch (typeof value === 'undefined' ? 'undefined' : babelHelpers.typeof(value)) {
                    case 'undefined':
                        result[prop.codeName] = prop.coerce(attr.value);
                        break;

                    case 'object':
                        if (value.length) {
                            value.push(prop.coerce(attr.value));
                            break;
                        }
                    default:
                        result[prop.codeName] = [value, prop.coerce(attr.value)];
                        break;
                }
            } else {
                result[prop.codeName] = prop.coerce(attr.value);
            }
        }
        return result;
    }, babelHelpers.extends({}, defaults, el.seedProps));
}



/*TODO learn from Skate JS

static get observedAttributes () {
    const attrsOnCtor = this.hasOwnProperty($ctorObservedAttributes) ? this[$ctorObservedAttributes] : [];
    const propDefs = getPropsMap(this);

    // Use Object.keys to skips symbol props since they have no linked attributes
    const attrsFromLinkedProps = Object.keys(propDefs).map(propName =>
      propDefs[propName].attrSource).filter(Boolean);

    const all = attrsFromLinkedProps.concat(attrsOnCtor).concat(super.observedAttributes);
    return all.filter((item, index) =>
      all.indexOf(item) === index);
  }

  static set observedAttributes (value) {
    value = Array.isArray(value) ? value : [];
    setCtorNativeProperty(this, 'observedAttributes', value);
  }

  // Returns superclass props overwritten with this Component props
  static get props () {
    return assign({}, super.props, this[$ctorProps]);
  }

  static set props (value) {
    setCtorNativeProperty(this, $ctorProps, value);
  }



  update:
  const propNameOrSymbol = data(this, 'attrSourceLinks')[name];
  if (propNameOrSymbol) {
    const changedExternally = getAttrMgr(this).onAttributeChanged(name, newValue);
    if (changedExternally) {
      // Sync up the property.
      const propDef = getPropsMap(this.constructor)[propNameOrSymbol];
      const newPropVal = newValue !== null && propDef.deserialize
        ? propDef.deserialize(newValue)
        : newValue;

      const propData = data(this, 'props')[propNameOrSymbol];
      propData.settingPropFromAttrSource = true;
      this[propNameOrSymbol] = newPropVal;
      propData.settingPropFromAttrSource = false;
    }
  }

  // DEPRECATED
  //
  // static attributeChanged()
  const { attributeChanged } = this.constructor;
  if (isFunction(attributeChanged)) {
    deprecated(this, 'static attributeChanged', 'attributeChangedCallback');
    attributeChanged(this, { name, newValue, oldValue });
  }



*/

/**
 * @module Inferno-Shared
 */ /** TypeDoc Comment */
function isNullOrUndef$2(o) {
    return isUndefined$2(o) || isNull$2(o);
}
function isInvalid$2(o) {
    return isNull$2(o) || o === false || isTrue$2(o) || isUndefined$2(o);
}
function isString$1(o) {
    return typeof o === "string";
}
function isNull$2(o) {
    return o === null;
}
function isTrue$2(o) {
    return o === true;
}
function isUndefined$2(o) {
    return o === void 0;
}
function isObject$6(o) {
    return (typeof o === "undefined" ? "undefined" : babelHelpers.typeof(o)) === "object";
}

/**
 * @module Inferno-Create-Element
 */ /** TypeDoc Comment */
var componentHooks = new Set();
componentHooks.add("onComponentWillMount");
componentHooks.add("onComponentDidMount");
componentHooks.add("onComponentWillUnmount");
componentHooks.add("onComponentShouldUpdate");
componentHooks.add("onComponentWillUpdate");
componentHooks.add("onComponentDidUpdate");
/**
 * Creates virtual node
 * @param {string|Function|Component<any, any>} type Type of node
 * @param {object=} props Optional props for virtual node
 * @param {...{object}=} _children Optional children for virtual node
 * @returns {VNode} new virtual ndoe
 */
function createElement$2(type, props) {
    var _children = [],
        len = arguments.length - 2;
    while (len-- > 0) {
        _children[len] = arguments[len + 2];
    }if (isInvalid$2(type) || isObject$6(type)) {
        throw new Error("Inferno Error: createElement() name parameter cannot be undefined, null, false or true, It must be a string, class or function.");
    }
    var children = _children;
    var ref = null;
    var key = null;
    var className = null;
    var flags = 0;
    var newProps;
    if (_children) {
        if (_children.length === 1) {
            children = _children[0];
        } else if (_children.length === 0) {
            children = void 0;
        }
    }
    if (isString$1(type)) {
        flags = getFlagsForElementVnode(type);
        if (!isNullOrUndef$2(props)) {
            newProps = {};
            for (var prop in props) {
                if (prop === "className" || prop === "class") {
                    className = props[prop];
                } else if (prop === "key") {
                    key = props.key;
                } else if (prop === "children" && isUndefined$2(children)) {
                    children = props.children; // always favour children args, default to props
                } else if (prop === "ref") {
                    ref = props.ref;
                } else {
                    newProps[prop] = props[prop];
                }
            }
        }
    } else {
        flags = 16 /* ComponentUnknown */;
        if (!isUndefined$2(children)) {
            if (!props) {
                props = {};
            }
            props.children = children;
            children = null;
        }
        if (!isNullOrUndef$2(props)) {
            newProps = {};
            for (var prop$1 in props) {
                if (componentHooks.has(prop$1)) {
                    if (!ref) {
                        ref = {};
                    }
                    ref[prop$1] = props[prop$1];
                } else if (prop$1 === "key") {
                    key = props.key;
                } else {
                    newProps[prop$1] = props[prop$1];
                }
            }
        }
    }
    return createVNode$1(flags, type, className, children, newProps, key, ref);
}

var index$5 = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @module Inferno-Vnode-Flags
 */ /** TypeDoc Comment */
var VNodeFlags;
(function (VNodeFlags) {
    VNodeFlags[VNodeFlags["Text"] = 1] = "Text";
    VNodeFlags[VNodeFlags["HtmlElement"] = 2] = "HtmlElement";
    VNodeFlags[VNodeFlags["ComponentClass"] = 4] = "ComponentClass";
    VNodeFlags[VNodeFlags["ComponentFunction"] = 8] = "ComponentFunction";
    VNodeFlags[VNodeFlags["ComponentUnknown"] = 16] = "ComponentUnknown";
    VNodeFlags[VNodeFlags["HasKeyedChildren"] = 32] = "HasKeyedChildren";
    VNodeFlags[VNodeFlags["HasNonKeyedChildren"] = 64] = "HasNonKeyedChildren";
    VNodeFlags[VNodeFlags["SvgElement"] = 128] = "SvgElement";
    VNodeFlags[VNodeFlags["MediaElement"] = 256] = "MediaElement";
    VNodeFlags[VNodeFlags["InputElement"] = 512] = "InputElement";
    VNodeFlags[VNodeFlags["TextareaElement"] = 1024] = "TextareaElement";
    VNodeFlags[VNodeFlags["SelectElement"] = 2048] = "SelectElement";
    VNodeFlags[VNodeFlags["Void"] = 4096] = "Void";
    VNodeFlags[VNodeFlags["FormElement"] = 3584] = "FormElement";
    VNodeFlags[VNodeFlags["Element"] = 3970] = "Element";
    VNodeFlags[VNodeFlags["Component"] = 28] = "Component";
})(VNodeFlags || (VNodeFlags = {}));
var VNodeFlags$1 = VNodeFlags;

exports['default'] = VNodeFlags$1;
});

var index$4 = createCommonjsModule(function (module) {
module.exports = index$5.default;
module.exports.default = module.exports;
});

/**
 * @module Inferno-Shared
 */ /** TypeDoc Comment */
// this is MUCH faster than .constructor === Array and instanceof Array
// in Node 7 and the later versions of V8, slower in older versions though
var isArray$5 = Array.isArray;
function isStatefulComponent$1(o) {
    return !isUndefined$3(o.prototype) && !isUndefined$3(o.prototype.render);
}
function isStringOrNumber$2(o) {
    var type = typeof o === 'undefined' ? 'undefined' : babelHelpers.typeof(o);
    return type === "string" || type === "number";
}
function isInvalid$3(o) {
    return isNull$3(o) || o === false || isTrue$3(o) || isUndefined$3(o);
}
function isNull$3(o) {
    return o === null;
}
function isTrue$3(o) {
    return o === true;
}
function isUndefined$3(o) {
    return o === void 0;
}
function isObject$7(o) {
    return (typeof o === 'undefined' ? 'undefined' : babelHelpers.typeof(o)) === "object";
}

/**
 * @module Inferno-Devtools
 */ /** TypeDoc Comment */
function findVNodeFromDom(vNode, dom) {
    if (!vNode) {
        var roots = options.roots;
        for (var i = 0, len = roots.length; i < len; i++) {
            var root = roots[i];
            var result = findVNodeFromDom(root.input, dom);
            if (result) {
                return result;
            }
        }
    } else {
        if (vNode.dom === dom) {
            return vNode;
        }
        var flags = vNode.flags;
        var children = vNode.children;
        if (flags & 28 /* Component */) {
                children = children._lastInput || children;
            }
        if (children) {
            if (isArray$5(children)) {
                for (var i$1 = 0, len$1 = children.length; i$1 < len$1; i$1++) {
                    var child = children[i$1];
                    if (child) {
                        var result$1 = findVNodeFromDom(child, dom);
                        if (result$1) {
                            return result$1;
                        }
                    }
                }
            } else if (isObject$7(children)) {
                var result$2 = findVNodeFromDom(children, dom);
                if (result$2) {
                    return result$2;
                }
            }
        }
    }
}
var instanceMap = new Map();
function getKeyForVNode(vNode) {
    var flags = vNode.flags;
    if (flags & 4 /* ComponentClass */) {
            return vNode.children;
        } else {
        return vNode.dom;
    }
}
function getInstanceFromVNode(vNode) {
    var key = getKeyForVNode(vNode);
    return instanceMap.get(key);
}
function createInstanceFromVNode(vNode, instance) {
    var key = getKeyForVNode(vNode);
    instanceMap.set(key, instance);
}
function deleteInstanceForVNode(vNode) {
    var key = getKeyForVNode(vNode);
    instanceMap.delete(key);
}
/**
 * Create a bridge for exposing Inferno's component tree to React DevTools.
 *
 * It creates implementations of the interfaces that ReactDOM passes to
 * devtools to enable it to query the component tree and hook into component
 * updates.
 *
 * See https://github.com/facebook/react/blob/59ff7749eda0cd858d5ee568315bcba1be75a1ca/src/renderers/dom/ReactDOM.js
 * for how ReactDOM exports its internals for use by the devtools and
 * the `attachRenderer()` function in
 * https://github.com/facebook/react-devtools/blob/e31ec5825342eda570acfc9bcb43a44258fceb28/backend/attachRenderer.js
 * for how the devtools consumes the resulting objects.
 */
function createDevToolsBridge() {
    var ComponentTree = {
        getNodeFromInstance: function getNodeFromInstance(instance) {
            return instance.node;
        },
        getClosestInstanceFromNode: function getClosestInstanceFromNode(dom) {
            var vNode = findVNodeFromDom(null, dom);
            return vNode ? updateReactComponent(vNode, null) : null;
        }
    };
    // Map of root ID (the ID is unimportant) to component instance.
    var roots = {};
    findRoots(roots);
    var Mount = {
        _instancesByReactRootID: roots,
        // tslint:disable-next-line:no-empty
        _renderNewRootComponent: function _renderNewRootComponent(instance) {}
    };
    var Reconciler = {
        // tslint:disable-next-line:no-empty
        mountComponent: function mountComponent(instance) {},
        // tslint:disable-next-line:no-empty
        performUpdateIfNecessary: function performUpdateIfNecessary(instance) {},
        // tslint:disable-next-line:no-empty
        receiveComponent: function receiveComponent(instance) {},
        // tslint:disable-next-line:no-empty
        unmountComponent: function unmountComponent(instance) {}
    };
    var queuedMountComponents = new Map();
    var queuedReceiveComponents = new Map();
    var queuedUnmountComponents = new Map();
    var queueUpdate = function queueUpdate(updater, map, component) {
        if (!map.has(component)) {
            map.set(component, true);
            requestAnimationFrame(function () {
                updater(component);
                map.delete(component);
            });
        }
    };
    var queueMountComponent = function queueMountComponent(component) {
        return queueUpdate(Reconciler.mountComponent, queuedMountComponents, component);
    };
    var queueReceiveComponent = function queueReceiveComponent(component) {
        return queueUpdate(Reconciler.receiveComponent, queuedReceiveComponents, component);
    };
    var queueUnmountComponent = function queueUnmountComponent(component) {
        return queueUpdate(Reconciler.unmountComponent, queuedUnmountComponents, component);
    };
    /** Notify devtools that a new component instance has been mounted into the DOM. */
    var componentAdded = function componentAdded(vNode) {
        var instance = updateReactComponent(vNode, null);
        if (isRootVNode(vNode)) {
            instance._rootID = nextRootKey(roots);
            roots[instance._rootID] = instance;
            Mount._renderNewRootComponent(instance);
        }
        visitNonCompositeChildren(instance, function (childInst) {
            if (childInst) {
                childInst._inDevTools = true;
                queueMountComponent(childInst);
            }
        });
        queueMountComponent(instance);
    };
    /** Notify devtools that a component has been updated with new props/state. */
    var componentUpdated = function componentUpdated(vNode) {
        var prevRenderedChildren = [];
        visitNonCompositeChildren(getInstanceFromVNode(vNode), function (childInst) {
            prevRenderedChildren.push(childInst);
        });
        // Notify devtools about updates to this component and any non-composite
        // children
        var instance = updateReactComponent(vNode, null);
        queueReceiveComponent(instance);
        visitNonCompositeChildren(instance, function (childInst) {
            if (!childInst._inDevTools) {
                // New DOM child component
                childInst._inDevTools = true;
                queueMountComponent(childInst);
            } else {
                // Updated DOM child component
                queueReceiveComponent(childInst);
            }
        });
        // For any non-composite children that were removed by the latest render,
        // remove the corresponding ReactDOMComponent-like instances and notify
        // the devtools
        prevRenderedChildren.forEach(function (childInst) {
            if (!document.body.contains(childInst.node)) {
                deleteInstanceForVNode(childInst.vNode);
                queueUnmountComponent(childInst);
            }
        });
    };
    /** Notify devtools that a component has been unmounted from the DOM. */
    var componentRemoved = function componentRemoved(vNode) {
        var instance = updateReactComponent(vNode, null);
        visitNonCompositeChildren(function (childInst) {
            deleteInstanceForVNode(childInst.vNode);
            queueUnmountComponent(childInst);
        });
        queueUnmountComponent(instance);
        deleteInstanceForVNode(vNode);
        if (instance._rootID) {
            delete roots[instance._rootID];
        }
    };
    return {
        ComponentTree: ComponentTree,
        Mount: Mount,
        Reconciler: Reconciler,
        componentAdded: componentAdded,
        componentRemoved: componentRemoved,
        componentUpdated: componentUpdated
    };
}
function isRootVNode(vNode) {
    for (var i = 0, len = options.roots.length; i < len; i++) {
        var root = options.roots[i];
        if (root.input === vNode) {
            return true;
        }
    }
}
/**
 * Update (and create if necessary) the ReactDOMComponent|ReactCompositeComponent-like
 * instance for a given Inferno component instance or DOM Node.
 */
function updateReactComponent(vNode, parentDom) {
    if (!vNode) {
        return null;
    }
    var flags = vNode.flags;
    var oldInstance = getInstanceFromVNode(vNode);
    var newInstance;
    if (flags & 28 /* Component */) {
            newInstance = createReactCompositeComponent(vNode, isUndefined$3(oldInstance));
        } else {
        newInstance = createReactDOMComponent(vNode, parentDom);
    }
    if (oldInstance) {
        for (var key in newInstance) {
            oldInstance[key] = newInstance[key];
        }
        return oldInstance;
    }
    createInstanceFromVNode(vNode, newInstance);
    return newInstance;
}
function isInvalidChild(child) {
    return isInvalid$3(child) || child === "";
}
function normalizeChildren$1(children, dom) {
    if (isArray$5(children)) {
        return children.filter(function (child) {
            return !isInvalidChild(child);
        }).map(function (child) {
            return updateReactComponent(child, dom);
        });
    } else {
        return !(isInvalidChild(children) || children === "") ? [updateReactComponent(children, dom)] : [];
    }
}
/**
 * Create a ReactDOMComponent-compatible object for a given DOM node rendered
 * by Inferno.
 *
 * This implements the subset of the ReactDOMComponent interface that
 * React DevTools requires in order to display DOM nodes in the inspector with
 * the correct type and properties.
 */
function createReactDOMComponent(vNode, parentDom) {
    var flags = vNode.flags;
    if (flags & 4096 /* Void */) {
            return null;
        }
    var type = vNode.type;
    var children = vNode.children === 0 ? vNode.children.toString() : vNode.children;
    var props = vNode.props;
    var dom = vNode.dom;
    var isText = flags & 1 /* Text */ || isStringOrNumber$2(vNode);
    return {
        _currentElement: isText ? children || vNode : {
            props: props,
            type: type
        },
        _inDevTools: false,
        _renderedChildren: !isText && normalizeChildren$1(children, dom),
        _stringText: isText ? (children || vNode).toString() : null,
        node: dom || parentDom,
        vNode: vNode
    };
}
function normalizeKey(key) {
    if (key && key[0] === ".") {
        return null;
    }
}
/**
 * Return a ReactCompositeComponent-compatible object for a given Inferno
 * component instance.
 *
 * This implements the subset of the ReactCompositeComponent interface that
 * the DevTools requires in order to walk the component tree and inspect the
 * component's properties.
 *
 * See https://github.com/facebook/react-devtools/blob/e31ec5825342eda570acfc9bcb43a44258fceb28/backend/getData.js
 */
function createReactCompositeComponent(vNode, isFirstCreation) {
    var type = vNode.type;
    var instance = vNode.children;
    var lastInput = instance._lastInput || instance;
    var dom = vNode.dom;
    var compositeComponent = {
        _currentElement: {
            key: normalizeKey(vNode.key),
            props: vNode.props,
            ref: null,
            type: type
        },
        _instance: instance,
        _renderedComponent: updateReactComponent(lastInput, dom),
        getName: function getName() {
            return typeName(type);
        },
        node: dom,
        props: instance.props,
        setState: instance.setState.bind(instance),
        state: instance.state,
        vNode: vNode
    };
    if (isFirstCreation) {
        var forceInstanceUpdate = instance.forceUpdate.bind(instance); // Save off for use below.
        instance.forceUpdate = function () {
            instance.props = vNode.props = Object.assign(
            // These are the regular Inferno props.
            instance.props,
            // This is what gets updated by the React devtools when props are edited.
            compositeComponent._currentElement.props);
            forceInstanceUpdate();
        };
    }
    return compositeComponent;
}
function nextRootKey(roots) {
    return "." + Object.keys(roots).length;
}
/**
 * Visit all child instances of a ReactCompositeComponent-like object that are
 * not composite components (ie. they represent DOM elements or text)
 */
function visitNonCompositeChildren(component, visitor) {
    if (component._renderedComponent) {
        if (!component._renderedComponent._component) {
            visitor(component._renderedComponent);
            visitNonCompositeChildren(component._renderedComponent, visitor);
        }
    } else if (component._renderedChildren) {
        component._renderedChildren.forEach(function (child) {
            if (child) {
                visitor(child);
                if (!child._component) {
                    visitNonCompositeChildren(child, visitor);
                }
            }
        });
    }
}
/**
 * Return the name of a component created by a `ReactElement`-like object.
 */
function typeName(type) {
    if (typeof type === "function") {
        return type.displayName || type.name;
    }
    return type;
}
/**
 * Find all root component instances rendered by Inferno in `node`'s children
 * and add them to the `roots` map.
 */
function findRoots(roots) {
    options.roots.forEach(function (root) {
        roots[nextRootKey(roots)] = updateReactComponent(root.input, null);
    });
}

/**
 * @module Inferno-Devtools
 */ /** TypeDoc Comment */
var functionalComponentWrappers = new Map();
function wrapFunctionalComponent(vNode) {
    var originalRender = vNode.type;
    var name = vNode.type.name || "Function (anonymous)";
    var wrappers = functionalComponentWrappers;
    if (!wrappers.has(originalRender)) {
        var wrapper = function (Component$$1) {
            function wrapper() {
                Component$$1.apply(this, arguments);
            }

            if (Component$$1) wrapper.__proto__ = Component$$1;
            wrapper.prototype = Object.create(Component$$1 && Component$$1.prototype);
            wrapper.prototype.constructor = wrapper;

            wrapper.prototype.render = function render(props, state, context) {
                return originalRender(props, context);
            };

            return wrapper;
        }(Component$1);
        // Expose the original component name. React Dev Tools will use
        // this property if it exists or fall back to Function.name
        // otherwise.
        /* tslint:disable */
        wrapper["displayName"] = name;
        /* tslint:enable */
        wrappers.set(originalRender, wrapper);
    }
    vNode.type = wrappers.get(originalRender);
    vNode.type.defaultProps = originalRender.defaultProps;
    vNode.ref = null;
    vNode.flags = 4 /* ComponentClass */;
}
// Credit: this based on on the great work done with Preact and its devtools
// https://github.com/developit/preact/blob/master/devtools/devtools.js
function initDevTools() {
    /* tslint:disable */
    if (typeof window["__REACT_DEVTOOLS_GLOBAL_HOOK__"] === "undefined") {
        /* tslint:enable */
        // React DevTools are not installed
        return;
    }
    var nextVNode = options.createVNode;
    options.createVNode = function (vNode) {
        var flags = vNode.flags;
        if (flags & 28 /* Component */ && !isStatefulComponent$1(vNode.type)) {
            wrapFunctionalComponent(vNode);
        }
        if (nextVNode) {
            return nextVNode(vNode);
        }
    };
    // Notify devtools when preact components are mounted, updated or unmounted
    var bridge = createDevToolsBridge();
    var nextAfterMount = options.afterMount;
    options.afterMount = function (vNode) {
        bridge.componentAdded(vNode);
        if (nextAfterMount) {
            nextAfterMount(vNode);
        }
    };
    var nextAfterUpdate = options.afterUpdate;
    options.afterUpdate = function (vNode) {
        bridge.componentUpdated(vNode);
        if (nextAfterUpdate) {
            nextAfterUpdate(vNode);
        }
    };
    var nextBeforeUnmount = options.beforeUnmount;
    options.beforeUnmount = function (vNode) {
        bridge.componentRemoved(vNode);
        if (nextBeforeUnmount) {
            nextBeforeUnmount(vNode);
        }
    };
    // Notify devtools about this instance of "React"
    /* tslint:disable */
    window["__REACT_DEVTOOLS_GLOBAL_HOOK__"].inject(bridge);
    /* tslint:enable */
    return function () {
        options.afterMount = nextAfterMount;
        options.afterUpdate = nextAfterUpdate;
        options.beforeUnmount = nextBeforeUnmount;
    };
}

/**
 * @module Inferno-Devtools
 */ /** TypeDoc Comment */
initDevTools();

/** @jsx createElement */
/*
 Everything under element must be implemented with compatible components
 that work in coherent rendering style
*/
function infernoTreeRenderer(el, BaseComponent, decorateComponent) {
    //TODO don't need a class per element, associate main element with Master
    var Master = function (_Component) {
        babelHelpers.inherits(Master, _Component);

        function Master() {
            babelHelpers.classCallCheck(this, Master);
            return babelHelpers.possibleConstructorReturn(this, (Master.__proto__ || Object.getPrototypeOf(Master)).apply(this, arguments));
        }

        babelHelpers.createClass(Master, [{
            key: 'getChildContext',
            // debugging the render function/class
            value: function getChildContext() {
                if (this.props.children == null || this.props.children && typeof this.props.children.length === 'number' && this.props.children.length != 1) {
                    throw Error("Inferno Error: Only one child is allowed within the `Provider` component");
                }
                return context; // { store: this.store, storeSubscription: null };
            }
        }, {
            key: 'render',
            value: function render() {
                return this.props.children;
            }
        }], [{
            key: 'name',
            get: function get() {
                return el.localName;
            }
        }]);
        return Master;
    }(Component$1);

    var Extended = function (_BaseComponent) {
        babelHelpers.inherits(Extended, _BaseComponent);
        babelHelpers.createClass(Extended, null, [{
            key: 'name',
            get: function get() {
                return BaseComponent.name;
            } // debugging the render function/class

        }]);

        function Extended(props, context) {
            babelHelpers.classCallCheck(this, Extended);

            var _this2 = babelHelpers.possibleConstructorReturn(this, (Extended.__proto__ || Object.getPrototypeOf(Extended)).call(this, props, context));

            if (typeof decorateComponent === 'function') decorateComponent(_this2, props, context);

            // remember component for now
            context.component = _this2;
            return _this2;
        }

        // render(props, state, context) {
        //     const useProps = props || this.renderProps();
        //     const children = this.renderContent(props, state, context);
        //     return Inferno.createVNode(VNodeFlags.HtmlElement, elName, useProps.className, children, useProps);
        // }


        return Extended;
    }(BaseComponent);

    // create wrapped component that supports update fiber


    var context = {
        connected: false,
        component: null, // is this even relevant?
        state: null,
        asComponent: Extended,

        destroy: function destroy() {
            this.component = null;
        },
        getState: function getState() {
            return this.component ? this.component.state : null;
        },
        setProps: function setProps(props) {
            //TODO how to do this?
        },
        setState: function setState(state) {
            //TODO how to do this?
            if (this.component) this.component.setState(state);
        },
        rootRender: function rootRender(props) {
            // if (this.component.renderAsync) {
            if (BaseComponent.prototype.renderAsync) {
                //TODO
            } else {
                if (BaseComponent.prototype.mixinProps) {
                    // this.component.props = props;
                    props = BaseComponent.prototype.mixinProps.call(this.component, props);
                    //TODO apply to element, not the component
                    // update when props, attrs, state changes
                }
                if (props.className !== undefined) {
                    el.className = props.className;
                }
                if (props.style) {
                    Object.assign(el.style, props.style);
                    // for(const n in props.style) {
                    //     el.style[n] = props.style[n];
                    // }
                }
                if (props.onClick) el.onclick = props.onclick; //??

                // const vNode = Inferno.createVNode(VNodeFlags.ComponentClass, Master, '',
                //     Inferno.createVNode(VNodeFlags.ComponentClass, Wrapped, '', [], props)
                // );
                // doesn't seem to work since instance is temporary
                // if (!this.component) this.component = vNode.children;

                return index$3.render(createElement$2(
                    Master,
                    null,
                    createElement$2(Extended, props)
                ), el);
            }
        }
    };

    return context;
}

function VNodeFromJSONML(jsonml, meta) {
    // console.warn('JSON', jsonml);
    return BY_TYPE.object(jsonml, meta);
}

function tag2flags(tag) {
    switch (tag) {
        //TODO svg media keyed children
        case 'svg':
            return index$4.SvgElement;
        case 'input':
            return index$4.InputElement;
        case 'textarea':
            return index$4.TextareaElement;
        case 'select':
            return index$4.SelectElement;
        default:
            return index$4.HtmlElement;
    }
}

function coerceProps(props) {
    // pseudo props from templated.js
    if (props instanceof NamedNodeMap) {
        return Array.from(props).reduce(function (result, node) {
            if (node.nodeType === 2 && node.nodeName !== 'children') result[node.nodeName] = node.nodeValue;
            return result;
        }, {});
    }
    return props;
}

var BY_TYPE = {
    'undefined': function undefined() {
        return index$3.createVNode(index$4.Void);
    },
    'string': function string(text) {
        // return Inferno.createVNode(VNodeFlags.Text, text); // transform function?
        return text;
    },
    'function': function _function(fn, meta) {
        var value = fn();
        BY_TYPE[typeof value === 'undefined' ? 'undefined' : babelHelpers.typeof(value)](value, meta);
    },
    'object': function object(jsonml, meta) {
        if (jsonml === null) return index$3.createVNode(index$4.Void);
        // TODO handle key, timing, data deps, timing callbacks
        //What about VNodeFlags.HasKeyedChildren
        var props = coerceProps(jsonml[1] || {});
        var key = props.key; //TODO true?
        //TODO identifying custom elements to convert to component rendering
        return index$3.createVNode(tag2flags(jsonml[0]), jsonml[0], props.className, jsonml.slice(2, jsonml.length).map(function (el) {
            return BY_TYPE[typeof el === 'undefined' ? 'undefined' : babelHelpers.typeof(el)](el, meta);
        }), props, key /* ref */
        );
    }
};

var zenObservable = createCommonjsModule(function (module, exports) {
'use strict';
(function (fn, name) {
  if (typeof exports !== 'undefined') fn(exports, module);else if (typeof self !== 'undefined') fn(name === '*' ? self : name ? self[name] = {} : {});
})(function (exports, module) {
  // === Symbol Support ===

  function hasSymbol(name) {
    return typeof Symbol === "function" && Boolean(Symbol[name]);
  }

  function getSymbol(name) {
    return hasSymbol(name) ? Symbol[name] : "@@" + name;
  }

  // Ponyfill Symbol.observable for interoperability with other libraries
  if (typeof Symbol === "function" && !Symbol.observable) {
    Symbol.observable = Symbol("observable");
  }

  // === Abstract Operations ===

  function getMethod(obj, key) {
    var value = obj[key];

    if (value == null) return undefined;

    if (typeof value !== "function") throw new TypeError(value + " is not a function");

    return value;
  }

  function getSpecies(obj) {
    var ctor = obj.constructor;
    if (ctor !== undefined) {
      ctor = ctor[getSymbol("species")];
      if (ctor === null) {
        ctor = undefined;
      }
    }
    return ctor !== undefined ? ctor : Observable;
  }

  function addMethods(target, methods) {
    Object.keys(methods).forEach(function (k) {
      var desc = Object.getOwnPropertyDescriptor(methods, k);
      desc.enumerable = false;
      Object.defineProperty(target, k, desc);
    });
  }

  function cleanupSubscription(subscription) {
    // Assert:  observer._observer is undefined

    var cleanup = subscription._cleanup;

    if (!cleanup) return;

    // Drop the reference to the cleanup function so that we won't call it
    // more than once
    subscription._cleanup = undefined;

    // Call the cleanup function
    cleanup();
  }

  function subscriptionClosed(subscription) {
    return subscription._observer === undefined;
  }

  function closeSubscription(subscription) {
    if (subscriptionClosed(subscription)) return;

    subscription._observer = undefined;
    cleanupSubscription(subscription);
  }

  function cleanupFromSubscription(subscription) {
    return function () {
      subscription.unsubscribe();
    };
  }

  function Subscription(observer, subscriber) {
    // Assert: subscriber is callable

    // The observer must be an object
    if (Object(observer) !== observer) throw new TypeError("Observer must be an object");

    this._cleanup = undefined;
    this._observer = observer;

    var start = getMethod(observer, "start");

    if (start) start.call(observer, this);

    if (subscriptionClosed(this)) return;

    observer = new SubscriptionObserver(this);

    try {
      // Call the subscriber function
      var cleanup$0 = subscriber.call(undefined, observer);

      // The return value must be undefined, null, a subscription object, or a function
      if (cleanup$0 != null) {
        if (typeof cleanup$0.unsubscribe === "function") cleanup$0 = cleanupFromSubscription(cleanup$0);else if (typeof cleanup$0 !== "function") throw new TypeError(cleanup$0 + " is not a function");

        this._cleanup = cleanup$0;
      }
    } catch (e) {
      // If an error occurs during startup, then attempt to send the error
      // to the observer
      observer.error(e);
      return;
    }

    // If the stream is already finished, then perform cleanup
    if (subscriptionClosed(this)) cleanupSubscription(this);
  }

  addMethods(Subscription.prototype = {}, {
    get closed() {
      return subscriptionClosed(this);
    },
    unsubscribe: function unsubscribe() {
      closeSubscription(this);
    }
  });

  function SubscriptionObserver(subscription) {
    this._subscription = subscription;
  }

  addMethods(SubscriptionObserver.prototype = {}, {

    get closed() {
      return subscriptionClosed(this._subscription);
    },

    next: function next(value) {
      var subscription = this._subscription;

      // If the stream is closed, then return undefined
      if (subscriptionClosed(subscription)) return undefined;

      var observer = subscription._observer;
      var m = getMethod(observer, "next");

      // If the observer doesn't support "next", then return undefined
      if (!m) return undefined;

      // Send the next value to the sink
      return m.call(observer, value);
    },

    error: function error(value) {
      var subscription = this._subscription;

      // If the stream is closed, throw the error to the caller
      if (subscriptionClosed(subscription)) throw value;

      var observer = subscription._observer;
      subscription._observer = undefined;

      try {
        var m$0 = getMethod(observer, "error");

        // If the sink does not support "error", then throw the error to the caller
        if (!m$0) throw value;

        value = m$0.call(observer, value);
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }

      cleanupSubscription(subscription);
      return value;
    },

    complete: function complete(value) {
      var subscription = this._subscription;

      // If the stream is closed, then return undefined
      if (subscriptionClosed(subscription)) return undefined;

      var observer = subscription._observer;
      subscription._observer = undefined;

      try {
        var m$1 = getMethod(observer, "complete");

        // If the sink does not support "complete", then return undefined
        value = m$1 ? m$1.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }

      cleanupSubscription(subscription);
      return value;
    }

  });

  function Observable(subscriber) {
    // The stream subscriber must be a function
    if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");

    this._subscriber = subscriber;
  }

  addMethods(Observable.prototype, {

    subscribe: function subscribe(observer) {
      for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) {
        args.push(arguments[__$0]);
      }if (typeof observer === 'function') {
        observer = {
          next: observer,
          error: args[0],
          complete: args[1]
        };
      }

      return new Subscription(observer, this._subscriber);
    },

    forEach: function forEach(fn) {
      var __this = this;
      return new Promise(function (resolve, reject) {
        if (typeof fn !== "function") return Promise.reject(new TypeError(fn + " is not a function"));

        __this.subscribe({
          _subscription: null,

          start: function start(subscription) {
            if (Object(subscription) !== subscription) throw new TypeError(subscription + " is not an object");

            this._subscription = subscription;
          },

          next: function next(value) {
            var subscription = this._subscription;

            if (subscription.closed) return;

            try {
              return fn(value);
            } catch (err) {
              reject(err);
              subscription.unsubscribe();
            }
          },

          error: reject,
          complete: resolve
        });
      });
    },

    map: function map(fn) {
      var __this = this;
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");

      var C = getSpecies(this);

      return new C(function (observer) {
        return __this.subscribe({
          next: function next(value) {
            if (observer.closed) return;

            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }

            return observer.next(value);
          },

          error: function error(e) {
            return observer.error(e);
          },
          complete: function complete(x) {
            return observer.complete(x);
          }
        });
      });
    },

    filter: function filter(fn) {
      var __this = this;
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");

      var C = getSpecies(this);

      return new C(function (observer) {
        return __this.subscribe({
          next: function next(value) {
            if (observer.closed) return;

            try {
              if (!fn(value)) return undefined;
            } catch (e) {
              return observer.error(e);
            }

            return observer.next(value);
          },

          error: function error(e) {
            return observer.error(e);
          },
          complete: function complete() {
            return observer.complete();
          }
        });
      });
    },

    reduce: function reduce(fn) {
      var __this = this;
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");

      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;

      return new C(function (observer) {
        return __this.subscribe({

          next: function next(value) {
            if (observer.closed) return;

            var first = !hasValue;
            hasValue = true;

            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },

          error: function error(e) {
            observer.error(e);
          },

          complete: function complete() {
            if (!hasValue && !hasSeed) {
              observer.error(new TypeError("Cannot reduce an empty sequence"));
              return;
            }

            observer.next(acc);
            observer.complete();
          }

        });
      });
    },

    flatMap: function flatMap(fn) {
      var __this = this;
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");

      var C = getSpecies(this);

      return new C(function (observer) {
        var completed = false;
        var subscriptions = [];

        // Subscribe to the outer Observable
        var outer = __this.subscribe({

          next: function next(value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (x) {
                observer.error(x);
                return;
              }
            }

            // Subscribe to the inner Observable
            Observable.from(value).subscribe({
              _subscription: null,

              start: function start(s) {
                subscriptions.push(this._subscription = s);
              },
              next: function next(value) {
                observer.next(value);
              },
              error: function error(e) {
                observer.error(e);
              },

              complete: function complete() {
                var i = subscriptions.indexOf(this._subscription);

                if (i >= 0) subscriptions.splice(i, 1);

                closeIfDone();
              }
            });
          },

          error: function error(e) {
            return observer.error(e);
          },

          complete: function complete() {
            completed = true;
            closeIfDone();
          }
        });

        function closeIfDone() {
          if (completed && subscriptions.length === 0) observer.complete();
        }

        return function () {
          subscriptions.forEach(function (s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    }

  });

  Object.defineProperty(Observable.prototype, getSymbol("observable"), {
    value: function value() {
      return this;
    },
    writable: true,
    configurable: true
  });

  addMethods(Observable, {

    from: function from(x) {
      var C = typeof this === "function" ? this : Observable;

      if (x == null) throw new TypeError(x + " is not an object");

      var method = getMethod(x, getSymbol("observable"));

      if (method) {
        var observable$0 = method.call(x);

        if (Object(observable$0) !== observable$0) throw new TypeError(observable$0 + " is not an object");

        if (observable$0.constructor === C) return observable$0;

        return new C(function (observer) {
          return observable$0.subscribe(observer);
        });
      }

      if (hasSymbol("iterator") && (method = getMethod(x, getSymbol("iterator")))) {
        return new C(function (observer) {
          for (var __$0 = method.call(x)[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;) {
            var item$0 = __$1.value;
            observer.next(item$0);
            if (observer.closed) return;
          }

          observer.complete();
        });
      }

      if (Array.isArray(x)) {
        return new C(function (observer) {
          for (var i$0 = 0; i$0 < x.length; ++i$0) {
            observer.next(x[i$0]);
            if (observer.closed) return;
          }

          observer.complete();
        });
      }

      throw new TypeError(x + " is not observable");
    },

    of: function of() {
      for (var items = [], __$0 = 0; __$0 < arguments.length; ++__$0) {
        items.push(arguments[__$0]);
      }var C = typeof this === "function" ? this : Observable;

      return new C(function (observer) {
        for (var i$1 = 0; i$1 < items.length; ++i$1) {
          observer.next(items[i$1]);
          if (observer.closed) return;
        }

        observer.complete();
      });
    }

  });

  Object.defineProperty(Observable, getSymbol("species"), {
    get: function get() {
      return this;
    },
    configurable: true
  });

  exports.Observable = Observable;
}, "*");
});

var index$7 = zenObservable.Observable;

function ResponseEntry(blockId) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var template = incrementalTemplates.get(blockId);
    var actionId = template && template.actions && template.actions.length === 1 ? template.actions[0].templateId : null;

    return babelHelpers.extends({
        type: 'response', templateId: blockId,
        actionId: actionId, hiddenResponse: false, response: null
    }, opts);
}

function ChallengeEntry(blockId) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return babelHelpers.extends({
        type: 'challenge', templateId: blockId }, opts);
}
/**
 * By default the state is a list of blocks with associated templates and responses
 */
function conversationReducer(state, action, context) {
    // context.topic context.startBlock

    if (!state) return state = seedConversation(context);

    switch (action.type) {
        case 'start response':
            // {type,templateId,actionId,hiddenResponse}
            return babelHelpers.extends({}, state, { thread: state.thread.map(function (block, index) {
                    return index === action.blockIndex ? mixBlockWithPayload(block) : block;
                }) });
        case 'set response':
            return babelHelpers.extends({}, state, { thread: state.thread.map(function (block, index) {
                    return index === action.blockIndex ? mixBlockWithPayload(block) : block;
                }) });
        case 'start topic':
            {
                // support an observable returned with time sequence thread additions
                return babelHelpers.extends({}, state, {
                    topic: action.payload,
                    thread: state.thread.concat(ChallengeEntry(action.payload.startBlock), ResponseEntry(action.payload.startBlock))
                });
            };

        default:
            return state;
    }

    function mixBlockWithPayload(block) {
        var payload = action.payload || {};
        if (payload.hiddenResponse !== undefined) payload.hiddenResponse = Boolean(payload.hiddenResponse);

        var result = Object.assign({}, block, payload);
        if (result.requiredFields) {
            var missingRequired = result.requiredFields.filter(function (name) {
                return result[name] == undefined;
            });
            result.response = missingRequired.length === 0 ? result.responseTemplate.render(result) : null;
            // TODO with a response the next block must be determined
        }

        return result;
    }
}

// function 0

function seedConversation(context) {
    var thread = [];

    if (thread.length === 0) {} else {
        //TODO convert the thread to incremental-dom el.idomChildren
    }

    return { thread: thread };
}

function contentReducer(state, _ref, context) {
    var type = _ref.type,
        payload = _ref.payload;

    switch (type) {
        default:
            return state;
    }
}

function showcaseReducer(state, _ref, context) {
    var type = _ref.type,
        payload = _ref.payload;

    switch (type) {
        case 'set showcase list':
            var showcaseState = payload.reduce(function (combined, entry) {
                combined[entry.href] = entry;
                return combined;
            }, {});
            return babelHelpers.extends({}, state, { showcase: payload, showcaseState: showcaseState });
        default:
            return state;
    }
}

/*
    Based on reselect
*/

var createSelector = createSelectorCreator(defaultMemoize);

function defaultEqualityCheck(a, b) {
  return a === b;
}

/* Similar to inferno-redux */
function statefulSelector(sourceSelector) {
  var stateRefiner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (state) {
    return state;
  };
  var store = arguments[2];
  var setComponentState = arguments[3];

  var selector = typeof sourceSelector === 'function' ? createSelector(sourceSelector, stateRefiner) : createSelector.apply(null, sourceSelector);

  selector.error = null;
  selector.state = {};
  selector.shouldComponentUpdate = false;
  selector.run = function (props) {
    try {
      var nextState = selector(store.getState(), props);
      if (nextState !== selector.state || selector.error) {
        selector.shouldComponentUpdate = true;
        selector.state = nextState;
        selector.error = null;
      }
    } catch (e) {
      console.warn('selector failed', e);
      selector.shouldComponentUpdate = true;
      selector.error = e;
    }
  };
  selector.subscribe = function () {
    selector.subscription = store.subscribe(setComponentState);
  };
  selector.unsubscribe = function () {
    if (selector.subscription) {
      selector.subscription();
    }

    // these are just to guard against extra memory leakage if a parent element doesn't
    // dereference this instance properly, such as an async callback that never finishes
    selector.subscription = null;
    selector.shouldComponentUpdate = false;
  };

  return selector;
}

function defaultMemoize(func) {
  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

  var lastArgs = null;
  var lastResult = null;
  var isEqualToLastArg = function isEqualToLastArg(value, index) {
    return equalityCheck(value, lastArgs[index]);
  };
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (lastArgs === null || lastArgs.length !== args.length || !args.every(isEqualToLastArg)) {
      lastResult = func.apply(undefined, args);
    }
    lastArgs = args;
    return lastResult;
  };
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep === 'undefined' ? 'undefined' : babelHelpers.typeof(dep);
    }).join(', ');
    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len2 = arguments.length, memoizeOptions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    memoizeOptions[_key2 - 1] = arguments[_key2];
  }

  return function () {
    for (var _len3 = arguments.length, funcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      funcs[_key3] = arguments[_key3];
    }

    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);

    var memoizedResultFunc = memoize.apply(undefined, [function () {
      recomputations++;
      return resultFunc.apply(undefined, arguments);
    }].concat(memoizeOptions));

    var selector = function selector(state, props) {
      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      var params = dependencies.map(function (dependency) {
        return dependency.apply(undefined, [state, props].concat(args));
      });
      params.push(props);
      return memoizedResultFunc.apply(undefined, params.concat(args));
    };

    selector.resultFunc = resultFunc;
    selector.recomputations = function () {
      return recomputations;
    };
    selector.resetRecomputations = function () {
      return recomputations = 0;
    };
    return selector;
  };
}

var LIFE_HOOKS = {
    componentDidMount: function componentDidMount() {
        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.selector.subscribe();
        this.selector.run(this.props);
        this.state = this.selector.state;
        if (this.selector.shouldComponentUpdate) {
            this.forceUpdate();
        }
    },
    componentWillUnmount: function componentWillUnmount() {
        this.selector.unsubscribe();
        this.selector = null;
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
    },
    shouldComponentUpdate: function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
    }
};

function mixinStateLifecycle(instance, HOOKS) {
    Object.keys(HOOKS).forEach(function (key) {
        var baseFn = instance[key];
        instance[key] = function () {
            if (baseFn) baseFn.apply(instance, arguments);
            return HOOKS[key].apply(instance, arguments);
        };
    });
}

/**
 * Used as `{state: ..}` extension for element
 */
function stateFromStore(_ref) {
    var _ref$storeFor = _ref.storeFor,
        storeFor = _ref$storeFor === undefined ? storeForByProp : _ref$storeFor,
        _ref$stateSelector = _ref.stateSelector,
        stateSelector = _ref$stateSelector === undefined ? returnParam : _ref$stateSelector,
        _ref$actionForChange = _ref.actionForChange,
        actionForChange = _ref$actionForChange === undefined ? returnParam : _ref$actionForChange,
        stateExtractor = _ref.stateExtractor,
        stateExtractorSelector = _ref.stateExtractorSelector,
        stateRefiner = _ref.stateRefiner,
        _ref$parentState = _ref.parentState,
        parentState = _ref$parentState === undefined ? defaultParentState : _ref$parentState,
        dispatchMethods = _ref.dispatchMethods,
        _ref$componentMethodN = _ref.componentMethodNames,
        componentMethodNames = _ref$componentMethodN === undefined ? {} : _ref$componentMethodN;

    var storeForContext = storeForContextCurry(storeFor);

    return {
        decorateComponent: function decorateComponent(instance, props, context) {
            var api = context.store ? context.store : context;
            if (dispatchMethods && api.dispatch) {
                var methods = dispatchMethods(function (action) {
                    return api.dispatch(action);
                });
                Object.assign(instance, methods);
            }
            instance.selector = statefulSelector(stateSelector, stateRefiner, context.store, function () {
                instance.selector.run(instance.props); //TODO place right location?
                instance.setState(instance.selector.state);
                instance.forceUpdate();
            });
            mixinStateLifecycle(instance, LIFE_HOOKS);
        },
        connect: function connect(el, props, internal) {
            var store = storeForContext(el); // could also use ensureStoreFor if createStore is defined
            if (!store && el.createStore) {
                el.createStore();
                store = storeForContext(el);
            }

            function extractState() {
                var children = stateExtractorSelector ? el.querySelectorAll(stateExtractorSelector) : el.children;
                var seedAction = stateExtractor(props, Array.from(children));
                if (seedAction) store.dispatch(seedAction);
            }

            return {
                store: store,
                extractState: stateExtractor ? extractState : null
            };
        }
    };
}

function returnParam(param) {
    return param;
}
function defaultParentState(el, store) {
    for (var p = el.parentNode; p; p = p.parentNode) {
        if ('state' in p) return p.state;
    }
}

function storeForByProp(el, newStore) {
    if (newStore) el.store = newStore;
    return el.store || el.confluxContext.store;
}

function storeForContextCurry(storeFor) {
    return function (el) {
        while (el) {
            var store = storeFor(el);
            if (store) return store;
            el = el.parentNode;
        }
        return null;
    };
}

// conflux - contextual flux
/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
    INIT: '@@redux/INIT'
};

var defaultContext = {
    // store: defaultStore
    preloadedState: {
        thread: [],
        showcase: [],
        showcaseState: {}
    }
};

var chained = chainReducers(conversationReducer, contentReducer, showcaseReducer);

var defaultStore = defaultContext.store = createStore(chained, defaultContext, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

// this may go away http://perfectionkills.com/whats-wrong-with-extending-the-dom/
HTMLElement.prototype.confluxContext = defaultContext;



function createStore(reducer, context, enhancer) {
    context = context || {};
    reducer = mixinContext(reducer);
    var preloadedState = context.preloadedState;
    var observable = void 0,
        queue = [],
        currentReducer = void 0,
        currentState = void 0,
        currentListeners = void 0,
        nextListeners = void 0,
        isDispatching = void 0;

    if (typeof enhancer !== 'undefined') {
        if (typeof enhancer !== 'function') {
            throw new Error('Expected the enhancer to be a function.');
        }

        return enhancer(_createStore)(reducer, preloadedState);
    } else {
        return _createStore(reducer, preloadedState);
    }

    function _createStore(reducer, preloadedState) {
        currentReducer = reducer;
        currentState = preloadedState;
        currentListeners = [];
        nextListeners = currentListeners;
        isDispatching = false;

        // When a store is created, an "INIT" action is dispatched so that every
        // reducer returns their initial state. This effectively populates
        // the initial state tree.
        dispatch({ type: ActionTypes.INIT });

        observable = new index$7(function (observer) {
            return subscribe(function () {
                observer.next(getState());
                // no observer.complete();
            });
        });

        setInterval(dispatchQueued, 250);

        return {
            dispatch: dispatch,
            queueDispatch: queueDispatch,
            dispatchQueued: dispatchQueued,
            subscribe: subscribe,
            getState: getState,
            replaceReducer: replaceReducer,
            observable: observable
            //   [$$observable]: observable
        };
    }

    function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
            nextListeners = currentListeners.slice();
        }
    }

    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */
    function getState() {
        return currentState;
    }

    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @param {Function} getRoot The root object for which to get notifications (TODO)
     * @returns {Function} A function to remove this change listener.
     */
    function subscribe(listener, getRoot) {
        var isSubscribed = true;

        ensureCanMutateNextListeners();
        nextListeners.push(listener);

        return function unsubscribe() {
            if (!isSubscribed) {
                return;
            }

            isSubscribed = false;

            ensureCanMutateNextListeners();
            var index = nextListeners.indexOf(listener);
            nextListeners.splice(index, 1);
        };
    }

    function queueDispatch(action) {
        queue.push(action);
    }

    function dispatchQueued() {
        queue.forEach(dispatch);
        queue.length = 0;
    }

    function dispatch(action) {
        if (isDispatching) {
            throw new Error('Reducers may not dispatch actions.');
        }

        try {
            isDispatching = true;
            currentState = currentReducer(currentState, action, context);
            //TODO identify points of state divergence ===
            //TODO compare with memory for selectors
        } finally {
            isDispatching = false;
        }

        // console.info('updated state', currentState);
        //TODO did state change?

        var listeners = currentListeners = nextListeners;
        currentListeners.forEach(function (listener) {
            return listener();
        });

        return action;
    }

    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */
    function replaceReducer(nextReducer) {
        if (typeof nextReducer !== 'function') {
            throw new Error('Expected the nextReducer to be a function.');
        }

        currentReducer = mixinContext(nextReducer);
        dispatch({ type: ActionTypes.INIT });
    }

    function mixinContext(reducer) {
        return function (state, action) {
            return reducer(state, action, context);
        };
    }
}

function chainReducers() {
    for (var _len = arguments.length, chain = Array(_len), _key = 0; _key < _len; _key++) {
        chain[_key] = arguments[_key];
    }

    return function (startState, action, context) {
        return chain.reduce(function (state, fn) {
            return fn(state, action, context);
        }, startState);
    };
}

function AsSubComponent(opts) {
    var state = opts.state,
        dispatchMethods = opts.dispatchMethods;

    var _ref = state ? state(opts) : {},
        decorateComponent = _ref.decorateComponent;

    //TODO marking methods on component class as @ExposeOnElement()

    return function decorator(BaseComponent) {

        return function (_BaseComponent) {
            babelHelpers.inherits(_class, _BaseComponent);
            babelHelpers.createClass(_class, null, [{
                key: "name",
                get: function get() {
                    return BaseComponent.name;
                }
            }]);

            function _class(props, context) {
                babelHelpers.classCallCheck(this, _class);

                var _this = babelHelpers.possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props, context));

                if (decorateComponent) decorateComponent(_this, props, context);
                return _this;
            }

            return _class;
        }(BaseComponent);
    };
}

var _dec$1;
var _class$1;

/** @jsx createElement */
var ConversationBlock = (_dec$1 = AsSubComponent({
    state: stateFromStore,
    dispatchMethods: function dispatchMethods(dispatch) {
        return {
            dispatch: dispatch,
            setResponse: function setResponse(blockIndex, payload) {
                dispatch({ type: 'set response', blockIndex: blockIndex, payload: payload });
            }
        };
    }
}), _dec$1(_class$1 = function (_Component) {
    babelHelpers.inherits(ConversationBlock, _Component);

    function ConversationBlock() {
        babelHelpers.classCallCheck(this, ConversationBlock);
        return babelHelpers.possibleConstructorReturn(this, (ConversationBlock.__proto__ || Object.getPrototypeOf(ConversationBlock)).apply(this, arguments));
    }

    babelHelpers.createClass(ConversationBlock, [{
        key: 'componentWillUpdate',
        value: function componentWillUpdate(nextProps) {
            // if (nextProps.templateId && !this.blockTemplate) {
            //     if (this.blockStats.newBlock && nextProps.templateId) {
            //         // this.
            //     }
            // }
        }
    }, {
        key: 'render',
        value: function render(props) {
            // return (<conversation-block title="Hello, We are" content-id="Hello" topic="conversation" class="their left-thread">
            //     <p class="statement" style="">Hi, we are a Digital Technology &amp; Design Advisory helping teams to kick off new products that are designed and engineered for a great experience from day one.</p><p class="statement">Have a look at our recent projects</p>
            //     <p class="statement">
            //         <x-portfolio-spread portfolio="showcase"><div class="spread-content">
            //             <div class="spread-item"><img src="/images/HenryLookingSq small.jpg"/><div class="titles"><h2>Henry</h2><h6 class="author">by H. Vendelbo</h6></div></div><div class="spread-item"><img src="/images/Katty-Henry 457.jpg"/><div class="titles"><h2>Henry</h2><h6 class="author">by H. Vendelbo</h6></div></div><div class="spread-item"><img src="/images/SplitShire-021.jpg"/><div class="titles"><h2>Henry</h2><h6 class="author">by H. Vendelbo</h6></div></div><button class="prev-btn">❮</button><button class="next-btn">❯</button></div>
            //         </x-portfolio-spread></p>
            //     <p class="statement"></p>
            //     </conversation-block>);
            //
            var blockTemplate = incrementalTemplates.get(props.templateId);
            if (blockTemplate) {
                var jsonML = blockTemplate.renderJSONML(this.state);
                jsonML[1].className = "their left-thread"; //TODO way to mixin the class
                var blockVNode = VNodeFromJSONML(jsonML);
                return blockVNode;
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(props) {
            //TODO delayed question
            // setTimeout(() => ,1000)
            // this.setResponse(props.blockIndex, { hiddenResponse:false });
        }
    }], [{
        key: 'properties',
        get: function get() {
            return {
                templateId: {
                    type: String,
                    attribute: 'template-id'
                },
                index: Number
            };
        }
    }, {
        key: 'computedProps',
        get: function get() {
            return {
                'class': function _class$1(base, _ref) {
                    var rendering = _ref.rendering;

                    return [].concat(base, ['their', this.blockStats.classes.leftThread, rendering && 'block-rendering']);
                }
            };
        }
    }]);
    return ConversationBlock;
}(Component$1)) || _class$1);

/** @jsx createElement */
function renderHtmlProps(props) {
    return {
        'type': props.type,
        'block-index': props.blockIndex,
        'template-id': props.templateId,
        'className': props.bubbleRight ? 'bubble bubble-right' : '',
        'editing': props.editing,
        'next-block-id': props.nextBlockId,
        'topic': props.topic
        // onclick: this.start.bind(this),
    };
}

function actionRenderer(type) {
    switch (type) {
        case 'slides':
            return SlidesAction;
        case 'message':
            return MessageAction;
        case 'none':
            return NoAction;
        default:
            return SentenceAction;
    }
}

function NoAction(props) {
    return createElement$2('thread-action', { className: 'no-action' });
}

function SlidesAction(props) {
    return createElement$2(
        'thread-action',
        babelHelpers.extends({}, renderHtmlProps(props), { full: true, editing: props.editing, className: 'timeline-kickoff' }),
        createElement$2(ActionPart, babelHelpers.extends({}, props, { part: props.inputs[0] || {} }))
    );
}

function MessageAction(props) {
    return createElement$2(
        'thread-action',
        null,
        createElement$2('input', { name: 'message', type: props.inputType, className: 'free-text', placeholder: props.placeholder,
            oninput: props.onInput, onchange: props.onChange, onblur: props.onBlur
        })
    );
}

function SentenceAction(props) {
    var staticPart = props.inputs[0]; //TODO all filled ones
    var nextPart = props.inputs[1]; //TODO first unfilled


    //TODO make staticPart with already chosen bit. (sentence construction)
    return createElement$2(
        'thread-action',
        babelHelpers.extends({}, renderHtmlProps(props), { full: true, editing: props.editing, className: 'timeline-kickoff' }),
        createElement$2(
            'span',
            { className: 'action-chosen' },
            props.staticPart
        ),
        createElement$2(
            'span',
            { className: 'action-open', onClick: props.logEvent, onChange: props.changeEvent },
            createElement$2('span', { className: 'blinking-cursor' }),
            createElement$2(ActionPart, babelHelpers.extends({}, props, { part: nextPart ? [nextPart.tag, nextPart.attrs].concat(nextPart.children) : ['span', {}] }))
        )
    );
}

/**
 * kickoff(entry)
 * choice
 * part = { tag, attrs, children } | string
 */
function ActionPart(props) {
    var part = props.part;

    switch (typeof part === 'undefined' ? 'undefined' : babelHelpers.typeof(part)) {
        case 'undefined': // no inputs in action
        case 'string':
            return createElement$2(
                'span',
                null,
                part
            );
    }

    //TODO initial value / current value from state

    switch (part.tag) {
        case 'select':
            if (part.attrs.type === 'timeline') {
                var stages = part.children.map(function (option) {
                    return babelHelpers.extends({}, option[1].attrs, { text: option[2] || '' });
                });
                return createElement$2(
                    'ol',
                    { className: props.choice && 'made-choice' },
                    stages.map(function (entry) {
                        return createElement$2(
                            'li',
                            null,
                            createElement$2(
                                'label',
                                { href: true },
                                createElement$2(
                                    'a',
                                    { onclick: function onclick() {
                                            return props.kickoff(entry);
                                        } },
                                    entry.text
                                )
                            )
                        );
                    }),
                    createElement$2('li', null)
                );
            }

            break;
        case 'input':
            break;
    }
    return VNodeFromJSONML(part);
}

function ShortThreadAction(props) {
    // if (!actionTemplate) return UnknownAction(props);
    var htmlProps = renderHtmlProps(props);
    return createElement$2(
        'thread-action',
        babelHelpers.extends({}, htmlProps, { onClick: function onClick() {
                return startAction(props);
            }, short: true }),
        shortenText(props.text, 20)
    );
}

// start the action within a response or input
// @ExposeOnElement()
function startAction(props) {
    var blockIndex = props.blockIndex,
        actionId = props.templateId,
        requiredFields = props.fieldNames,
        responseTemplate = props.responseTemplate,
        actionTemplate = incrementalTemplates.get(actionId, 'thread-action'),
        hiddenResponse = false;

    // no way to re-start an action
    //TODO if (actionId === this.state.actionId) return;

    if (props.beta) {
        // We're not able to have move informations at this moment, sorry.
        props.dispatch({ type: 'start response', blockIndex: blockIndex,
            payload: { blockIndex: blockIndex, actionId: actionId, requiredFields: requiredFields, responseTemplate: responseTemplate, hiddenResponse: hiddenResponse } });
        return;
    }

    if (props.fields) {
        props.dispatch({ type: 'start response', blockIndex: blockIndex, payload: { blockIndex: blockIndex, actionId: actionId, requiredFields: requiredFields, responseTemplate: responseTemplate, hiddenResponse: hiddenResponse } });
    } else {
        props.dispatch({ type: 'set response', blockIndex: blockIndex, payload: { blockIndex: blockIndex, actionId: actionId, requiredFields: requiredFields, responseTemplate: responseTemplate, hiddenResponse: hiddenResponse } });
    }
}

function shortenText(text, max) {
    if (text.length < max) return text;
    var parts = text.substring(0, max + 2).split(' ');
    --parts.length;
    return parts.join(' ') + '..';
}

var _dec$2;
var _class$2;

/** @jsx createElement */
// import { reducer as formReducer } from 'redux-form';

function stateSelector$1(storeState, props) {
    var template = incrementalTemplates.get(props.templateId);
    if (!template) return null;

    var block = storeState.thread[props.index];
    var otherActions = template.actions.filter(function (el) {
        return el.templateId !== block.actionId && el.type !== 'message';
    }).map(function (action) {
        return action.getRenderProps(props, block);
    });
    var actions = template.actions.filter(function (el) {
        return block.actionId ? el.templateId === block.actionId : true;
    }).map(function (action) {
        return action.getRenderProps(props, block);
    });
    var messageAction = actions.find(function (action) {
        return action.type === 'message' || action.templateId === block.actionId;
    });

    // Type of selected action, message if in available actions, or none. Used to determine Message Toolbar
    var activeActionType = actions.length === 1 ? actions[0].type : messageAction ? 'message' : 'none';

    var selectedActionType = actions.length === 1 ? actions[0].type : null;
    var enableMessage = actions.reduce(function (result, action) {
        return result || action.enableMessage;
    }, false);

    return babelHelpers.extends({}, block, { template: template, actions: actions, otherActions: otherActions, selectedActionType: selectedActionType, activeActionType: activeActionType, enableMessage: enableMessage, messageAction: messageAction });
}

var ConversationResponse = (_dec$2 = AsSubComponent({
    state: stateFromStore,
    stateSelector: stateSelector$1,
    stateRefiner: function stateRefiner(state, props) {
        return state;
    },
    dispatchMethods: function dispatchMethods(dispatch) {
        return {
            dispatch: dispatch,
            setResponse: function setResponse(payload) {
                dispatch({ type: 'set response', blockIndex: this.index || this.props.index, payload: payload });
            },
            startMessageEntry: function startMessageEntry() {
                if (!this.state.actionId) {
                    var actionId = this.state.enableMessage.actionId;

                    var payload = { actionId: actionId };
                    dispatch({ type: 'set response', blockIndex: this.index || this.props.index, payload: payload });
                }
            },
            submitResponse: function submitResponse() {}
        };
    }
}), _dec$2(_class$2 = function (_Component) {
    babelHelpers.inherits(ConversationResponse, _Component);

    // static get props() {
    //     return {
    //         storeChanges: prop.number(), //TODO build into customExtensions / conflux
    //         templateId: prop.string({ attribute: true }),
    //         index: prop.number({ attribute: true }),
    //         hidden: prop.boolean({ attribute: true }),
    //     };
    // }

    function ConversationResponse(props, context) {
        babelHelpers.classCallCheck(this, ConversationResponse);

        var _this = babelHelpers.possibleConstructorReturn(this, (ConversationResponse.__proto__ || Object.getPrototypeOf(ConversationResponse)).call(this, props, context));

        var other = _this.otherProps = {};

        var msg = _this.messageProps = {
            onInput: function onInput(_ref) {
                var target = _ref.target;
                return _this.startMessageEntry();
            },
            onChange: function onChange(_ref2) {
                var target = _ref2.target;
                msg.value = target.value;_this.startMessageEntry();
            },
            onBlur: function onBlur(_ref3) {
                var target = _ref3.target;
                msg.value = target.value;_this.startMessageEntry();
            },
            inputType: 'text',
            value: '',
            onSubmit: onSubmit,
            placeholder: 'Type message ...'
        };

        function onSubmit(event) {
            //TODO submit response
            console.info('Submit', msg.value);
            event.preventDefault();
            msg.value = '';
            return false;
        }
        return _this;
    }

    babelHelpers.createClass(ConversationResponse, [{
        key: 'renderTemplateActions',
        value: function renderTemplateActions(props, _ref4) {
            var template = _ref4.template;

            if (!template || !template.actions) return [];
            return;
        }
    }, {
        key: 'render',
        value: function render(props, state) {
            if (state && state.template) {
                // let className = state.actions.length==1 ? 'my right-thread pick-response':'my common-thread pick-response';
                var className = 'my common-thread pick-response';

                //TODO fill into the toolbar when action is picked and non-slide
                return createElement$2(
                    'conversation-response',
                    { className: className, hidden: props.hiddenResponse },
                    createElement$2(OtherActions, babelHelpers.extends({}, this.otherProps, { actions: state.otherActions, dispatch: this.dispatch, index: props.index })),
                    createElement$2(MessageToolbar, babelHelpers.extends({}, this.messageProps, { state: state, blockIndex: props.index }))
                );
            }
        }

        // when action was started and cancel is selected

    }, {
        key: 'cancelAction',
        value: function cancelAction(action) {
            this.removeAttribute('action-started');
        }
    }], [{
        key: 'computedProps',
        get: function get() {
            return {
                'class': function _class$2(base, _ref5) {
                    var rendering = _ref5.rendering;

                    if (this.state.response) return [].concat(base, ['my', 'right-thread']);
                    if (this.state.actionId) return [].concat(base, ['my', 'right-thread']);

                    return [].concat(base, ['my', 'common-thread', 'pick-response']);
                }
            };
        }
    }]);
    return ConversationResponse;
}(Component$1)) || _class$2);
function OtherActions(props) {
    return createElement$2(
        'div',
        { className: 'actions' },
        props.actions.map(function (action) {
            return createElement$2(ShortThreadAction, babelHelpers.extends({}, action, { blockIndex: props.index, dispatch: props.dispatch }));
        })
    );
}

function MessageToolbar(props) {
    var state = props.state;

    var ThreadAction = actionRenderer(state.activeActionType);

    // ? <ThreadAction {...state.actions[0]} state={state} bubbleRight={true} blockIndex={props.index} />

    // iOS go button
    // https://stackoverflow.com/questions/5665203/getting-iphone-go-button-to-submit-form
    return createElement$2(
        'nav',
        { className: 'toolbar' },
        createElement$2(
            'form',
            { className: 'text-form', onsubmit: props.onSubmit, action: 'send message' },
            createElement$2(ThreadAction, babelHelpers.extends({}, props, state.messageAction, { bubbleRight: true })),
            createElement$2('button', { type: 'submit', className: 'icons8-paper-plane2' })
        )
    );
    // <button className="person" type="button">🗣</button>
    // <button className="submit" type="button" onclick={submitFreeText}>⇡</button>
    // <button className="camera" type="button">📷</button>
    // <button className="record" type="button">🎤</button>
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

/**
 * The currently active debug mode names, and names to skip.
 */

var names = [];
var skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

var formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;
var colors = [];

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return colors[prevColor++ % colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug$1(namespace) {

  // define the `disabled` version
  function disabledReturned() {}
  disabledReturned.enabled = false;

  // define the `enabled` version
  function enabledReturned() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = coerce$1(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // if ('function' === typeof exports.formatArgs) {
    //   args = exports.formatArgs.apply(self, args);
    // }
    var logFn = enabled.log || /*exports.log ||*/console.log.bind(console);
    logFn.apply(self, args);
  }
  enabledReturned.enabled = true;

  var fn = enabled(namespace) ? enabledReturned : disabledReturned;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */



/**
 * Disable debug output.
 *
 * @api public
 */



/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = skips.length; i < len; i++) {
    if (skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = names.length; i < len; i++) {
    if (names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce$1(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

var _dec;
var _class;

/** @jsx createElement */
/**
 * Threads are conversations that the user may pick up. So they start with a conversation opener.
 */
var debug = debug$1('conversation');

function extractSource(child) {
	return {
		src: child.src,
		srcset: child.srcset,
		type: child.type
	};
}

function extractLead(child) {
	switch (child.localName) {
		case 'img':
			return { type: 'img', src: child.src, alt: child.getAttribute('alt'), width: child.getAttribute('width'), height: child.getAttribute('height') };
		case 'video':
			return { type: 'video', sources: Array.from(child.children).map(extractSource) };
	}
	//TODO mark for removal
}

/*
Threads could provide a .context like in React. A context chain could be main using Object.create(myContext)
*/
var ConversationThread = (_dec = AsCustomElement({
	// tag: 'conversation-thread', TODO queue define instead
	treeRenderer: infernoTreeRenderer,
	state: stateFromStore,
	stateSelector: function stateSelector(storeState, props) {
		return storeState.thread;
	},
	//TODO state extractor to load past conversation
	propsExtractor: function propsExtractor(children) {
		return { leads: children.filter(function (child) {
				return child.hasAttribute('conversation-lead');
			}).map(extractLead) };
	},
	dispatchMethods: function dispatchMethods(dispatch) {
		return {
			startTopic: function startTopic(payload) {
				dispatch({ type: 'start topic', payload: payload });
			}
		};
	}
}), _dec(_class = function (_Component) {
	babelHelpers.inherits(ConversationThread, _Component);

	function ConversationThread() {
		babelHelpers.classCallCheck(this, ConversationThread);
		return babelHelpers.possibleConstructorReturn(this, (ConversationThread.__proto__ || Object.getPrototypeOf(ConversationThread)).apply(this, arguments));
	}

	babelHelpers.createClass(ConversationThread, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			/* 1) first visit shwoing initial block, 2) subsequent - pick up ongoing, 3) subsequent - finished, option to start new. */

			// If location/router specifies a location in past conversation, adjust it
			// If location/router specifies a response to current block, create response
			// Otherwise start with pre-configured block

			this.startTopic({ topic: this.props.topic, startBlock: this.props.startBlock });
		}

		// JSONTML = JSON Template Markup Language (adjusted attributes and functions semantic for dynamic content)

	}, {
		key: 'render',
		value: function render(props) {
			var blocks = index$1.Children.map(this.selector.state, function (block, index) {
				return block.type === 'response' ? createElement$2(ConversationResponse, babelHelpers.extends({}, block, { key: index, index: index, topic: props.topic,
					hidden: block.hiddenResponse })) : createElement$2(ConversationBlock, babelHelpers.extends({}, block, { key: index, index: index }));
			});
			if (blocks === null) {
				blocks = ['No conversation thread'];
			} else if (blocks.length === 0) {
				blocks.push(createElement$2(
					'div',
					null,
					'No conversation started'
				));
			}

			var Leads = props.leads.length ? ConversationLeads : function () {
				return createElement$2('header', null);
			};

			return createElement$2(
				'div',
				null,
				createElement$2(Leads, props),
				createElement$2(
					'section',
					{ session: 'new', 'class': 'common-thread' },
					blocks
				)
			);
		}
	}], [{
		key: 'properties',
		get: function get() {
			return {
				topic: { type: String, default: 'conversation' },
				startBlock: { type: String, default: 'root' }
				// startBlock: prop.string({ attribute: 'start-block', default: 'root' }) // coerce(value) => value
			};
		}
	}]);
	return ConversationThread;
}(Component$1)) || _class);
function AuthorLine(props) {
	return createElement$2(
		'div',
		{ 'class': 'author' },
		createElement$2(
			'span',
			{ 'class': 'chat-heads smaller-chat-head' },
			createElement$2('img', { 'class': 'bio-head', src: props.src })
		),
		createElement$2(
			'div',
			{ 'class': 'name' },
			props.name
		),
		createElement$2(
			'div',
			{ 'class': 'location' },
			props.location
		)
	);
}

function ConversationLeads(props) {
	var author = {
		src: '/images/HenryLookingSq small.jpg',
		name: 'Henrik Vendelbo',
		location: 'Zürich, Switzerland',
		className: 'lead'
	};
	function SingleLead(lead) {
		//TODO type = video

		return createElement$2('img', lead);
	}
	return createElement$2(
		'header',
		{ 'class': 'post' },
		createElement$2(AuthorLine, author),
		createElement$2(
			'div',
			{ 'class': 'leads' },
			props.leads.map(SingleLead)
		)
	);
}

var _dec$3;
var _class$3;

/** @jsx createElement */
/**
 * Presentations are video/image/slides that represent a larger post/document.
 */
var ThreadPresentation = (_dec$3 = AsCustomElement({
    tag: 'thread-presentation',
    treeRenderer: infernoTreeRenderer,
    state: stateFromStore,
    stateSelector: function stateSelector(storeState, props) {
        return storeState.thread;
    },
    // propsExtractorSelector: 'flow-author',
    // propsExtractor: (children) => ({ authors: children.map(extractAuthor) }),
    dispatchMethods: function dispatchMethods(dispatch) {
        return {
            startTopic: function startTopic(payload) {
                dispatch({ type: 'start topic', payload: payload });
            }
        };
    }
}), _dec$3(_class$3 = function (_Component) {
    babelHelpers.inherits(ThreadPresentation, _Component);

    function ThreadPresentation() {
        babelHelpers.classCallCheck(this, ThreadPresentation);
        return babelHelpers.possibleConstructorReturn(this, (ThreadPresentation.__proto__ || Object.getPrototypeOf(ThreadPresentation)).apply(this, arguments));
    }

    babelHelpers.createClass(ThreadPresentation, [{
        key: 'renderHeads',
        value: function renderHeads(props) {
            //TODO hover over heads switch the author detail shown
            return createElement$2(
                'a',
                { href: props.website, className: 'image avatar line-item' },
                createElement$2('img', { className: '', src: props.img_src, alt: props.full_name })
            );
        }
    }, {
        key: 'renderAuthorDetail',
        value: function renderAuthorDetail(props) {
            return createElement$2(
                'div',
                { 'class': 'detail' },
                createElement$2(
                    'div',
                    null,
                    createElement$2(
                        'a',
                        { href: props.website, className: 'line-item name' },
                        createElement$2(
                            'strong',
                            null,
                            props.full_name
                        )
                    ),
                    props.twitter && createElement$2(
                        'a',
                        { href: props.twitter, className: 'line-item twitter-logo if_twitter_317720' },
                        ' '
                    ),
                    props.linkedin && createElement$2(
                        'a',
                        { href: props.linkedin, className: 'line-item linkedin-logo if_circle-linkedin_317750' },
                        ' '
                    )
                ),
                createElement$2(
                    'div',
                    { 'class': 'title' },
                    props.title
                )
            );
        }
    }, {
        key: 'render',
        value: function render(props) {
            var _this2 = this;

            return createElement$2(
                'div',
                null,
                createElement$2(
                    'header',
                    { className: 'with-chat-heads with-smaller-chat-heads author-line with-author-info' },
                    createElement$2(
                        'div',
                        { className: 'heads' },
                        props.authors.map(function (props) {
                            return _this2.renderHeads(props);
                        })
                    ),
                    props.authors.map(function (props) {
                        return _this2.renderAuthorDetail(props);
                    })
                ),
                createElement$2(
                    'video',
                    { poster: props.poster, muted: true, preload: 'auto', autoplay: true, playsinline: true },
                    props.mp4 && createElement$2('source', { src: props.mp4, type: 'video/mp4; codecs=avc1.42E01E,mp4a.40.2' })
                ),
                createElement$2(
                    'div',
                    { 'class': 'lead-box' },
                    createElement$2(
                        'p',
                        null,
                        props.lead
                    ),
                    createElement$2(
                        'div',
                        null,
                        createElement$2(
                            'button',
                            { style: 'width: 90px;', href: 'void:' },
                            'Learn more'
                        )
                    )
                )
            );
        }
    }], [{
        key: 'properties',
        get: function get() {
            // poster="/images/intro/org-gap.jpeg" mp4="/org-gap.m4v" authorkeys="henrik katty"
            return {
                poster: String,
                mp4: String,
                pretext: String,
                lead: String,
                authors: {
                    type: String,
                    default: [],
                    coerce: function coerce(authors) {
                        return authors.split(' ').map(authorKeyToData);
                    }
                }
            };
        }
    }]);
    return ThreadPresentation;
}(Component$1)) || _class$3);

function authorKeyToData(key) {
    var el = document.querySelector('meta[key="' + key + '"]');
    if (!el) return {};

    return {
        full_name: el.getAttribute('full-name'),
        website: el.getAttribute('website'),
        img_src: el.getAttribute('img-src'),
        bio: el.getAttribute('bio'),
        title: el.getAttribute('title'),
        twitter: 'https://twitter.com/' + el.getAttribute('twitter'),
        linkedin: 'https://linkedin.com/in/' + el.getAttribute('linkedin')
    };
}

var _dec$4;
var _class$4;

/** @jsx createElement */
// import 'whatwg-fetch';
// const debug = require('debug')('flow-card');

function extractProps(stages) {
	return {
		stages: stages
	};
}

function timeEntryFromSeed(el) {
	var id = el.id,
	    text = el.innerText;

	return {
		id: id,
		text: text
	};
}

function KickoffMarkup(props, state) {
	return createElement$2(
		'ol',
		{ className: props.choice && 'made-choice' },
		props.stages.map(function (entry) {
			return createElement$2(
				'li',
				null,
				createElement$2(
					'label',
					{ href: true },
					createElement$2(
						'a',
						{ onclick: props.kickoff },
						entry.text
					)
				)
			);
		}),
		createElement$2('li', null)
	);
}

(_dec$4 = AsCustomElement({
	tag: 'timeline-kickoff',
	treeRenderer: infernoTreeRenderer,
	state: stateFromStore,
	stateSelector: function stateSelector(storeState, props) {
		return storeState.thread.filter(function (block) {
			return block.topic === props.topic;
		});
	},
	propsExtractor: function propsExtractor(children) {
		console.info('ch', children);
		return extractProps(children.filter(function (el) {
			return el.localName === 'time';
		}).map(timeEntryFromSeed));
	},
	dispatchMethods: function dispatchMethods(dispatch) {
		return {
			dispatch: dispatch,
			kickoff: function kickoff(payload) {
				dispatch({ type: 'kickoff', payload: payload });
			}
		};
	}
}), _dec$4(_class$4 = function (_Component) {
	babelHelpers.inherits(TimelineKickoff, _Component);

	function TimelineKickoff() {
		babelHelpers.classCallCheck(this, TimelineKickoff);
		return babelHelpers.possibleConstructorReturn(this, (TimelineKickoff.__proto__ || Object.getPrototypeOf(TimelineKickoff)).apply(this, arguments));
	}

	babelHelpers.createClass(TimelineKickoff, [{
		key: 'submitGoogleForm',
		value: function submitGoogleForm(props, state) {
			var form = {
				project: { name: 'entry.552123813' },
				session: { name: 'entry.1374092746' },
				fullname: { name: 'entry.1662835028' },
				phone: { name: 'entry.4946242' },
				message: { name: 'entry.844571987' }
			};
			if (props.kickoffGoogleForm) {
				var sendData = function sendData(url, data) {
					var formData = new FormData();

					for (var name in data) {
						formData.append(name, data[name]);
					}

					fetch(responseUrl, {
						method: 'POST',
						body: formData
					}).then(function (response) {
						// ...
						console.info('Response', response);
					});
				};

				var responseUrl = props.kickoffGoogleForm.replace('/viewform', '') + '/formResponse';
			}
		}
	}, {
		key: 'renderInitial',
		value: function renderInitial(props, state) {
			function alertPickOnTimeline() {
				alert('Please choose a stage');
			}

			var index = 1;
			var block = {};

			// <KickoffMarkup {...props} kickoff={this.kickoff} />
			// <ConversationResponse {...block} index={index} dispatch={this.dispatch} />

			return createElement$2(
				'div',
				null,
				createElement$2(
					'h1',
					null,
					props.title
				),
				createElement$2(KickoffMarkup, babelHelpers.extends({}, props, { kickoff: this.kickoff })),
				createElement$2(
					'button',
					{ hidden: props.choice, onClick: alertPickOnTimeline },
					'Submit'
				),
				createElement$2(
					'button',
					{ onclick: this.submitGoogleForm(props, state) },
					'Send'
				)
			);
		}
	}, {
		key: 'renderEnterMessage',
		value: function renderEnterMessage(props, state) {
			return createElement$2(
				'div',
				null,
				createElement$2('input', { type: 'text', name: 'message', value: '' })
			);
		}
	}, {
		key: 'renderIdentity',
		value: function renderIdentity(props, state) {
			function submitIdentity() {}

			return createElement$2(
				'div',
				null,
				createElement$2(
					'div',
					{ className: 'identity' },
					createElement$2('input', { type: 'text', name: 'fullname', value: '', placeholder: 'Your Name' }),
					createElement$2('input', { type: 'tel', name: 'phone', value: '', placeholder: 'Mobile No.' }),
					createElement$2(
						'button',
						{ 'class': 'submit', onclick: submitIdentity },
						'Identify Yourself'
					)
				)
			);
		}
	}, {
		key: 'renderContent',
		value: function renderContent(props, state) {
			var thread = this.selector.state;
			if (thread.length) {
				return this.renderEnterMessage(props, state);
			} else {
				return this.renderInitial(props, state);
			}
			// identity
			// status
			// message
		}
	}, {
		key: 'render',
		value: function render(props, state) {
			return this.renderContent(props, state);
			// return <timeline-kickoff>{ this.renderContent(props) }</timeline-kickoff>;
		}
	}, {
		key: 'properties',
		get: function get() {
			return {
				title: String,
				kickoffGoogleForm: { type: String, attribute: 'kickoffgoogleform' },
				stages: Array,
				topic: String
			};
		}
	}]);
	return TimelineKickoff;
}(Component$1)) || _class$4);

// import ThreadAction from './actions/thread-action.element';
// import ConversationBlock from './conversation-block.element';
// import ConversationResponse from './conversation-response.element';
// import PortfolioSpread from './portfolio-spread.element';

function registerContentElements() {
    // customElements.define('thread-action',ThreadAction);
    customElements.define('conversation-thread', ConversationThread);
}

/**
 * Templates meant for conversations are indexed in `blocks` by id attribute.
 * The ID is removed so it can be reused by regular DOM elements.
 *
 * In future the ID will be a hash of the content.
 */
function scanTemplates() {
    incrementalTemplates.define('thread-action', ActionTemplate);
    incrementalTemplates.define('template', BlockTemplate); //TODO 'template[topic]' and multiple define support
    incrementalTemplates.define(function (template) {
        return Array.from((template.content || template).children);
    }, Statement); // immidiate children are assumed to be statements
    incrementalTemplates.upgradeDOM();
    //TODO scan conversation-block elements already put in the thread by server rendering
}

function startConversations() {
    if (!incrementalTemplates.ready) {
        incrementalTemplates.upgraded.then(_startConversations);
    } else {
        _startConversations();
    }
}

function _startConversations() {
    /**
     * Blocks are defined by putting them in the body or head tag outside a conversation-thread.
     * They are shown inside conversation-threads according to the replay and response rules of
     * the thread.
     */
    // customElements.define('conversation-response', ConversationResponse);

    //TODO customElements.define('portfolio-spread', PortfolioSpread);

    // reset scroll from main conversation - up
    var primaryConversation = document.querySelector('conversation-thread');
    for (var el = primaryConversation; el; el = el === document.body ? null : el.parentElement) {
        el.scrollTop = 0;
    }
}

/*
  Identify blocks with statements

  Navigation starts at the root block, all other blocks are hidden initially.
*/

// activate block places it below the last block in conversation

// param event or element


/*
block
block|action|history=0|rest=
*/
function decodeHash() {
    var nav = (arguments[0] || location.hash).split('|'),
        hashAt = nav[0].indexOf('#');

    // hash based URL
    if (hashAt >= 0) {
        nav[0] = nav[0].substring(hashAt + 1);
    }

    // path based URL
    else {
            nav[0] = nav[0].split('/').pop(); // leaf is block name
        }
    if (nav[0] && blocks[nav[0]]) {
        nav.block = blocks[nav[0]];
    }
    if (nav.length > 1) nav.action = nav[1];
    return nav;
}

function applyBlockFromHash(hash, state) {
    var nav = decodeHash(hash);
    if (arguments.length === 2) {
        // if moving back then roll back the conversation
    }
    if (nav.block) nav.block.activate(); //TODO boxEl

    if (nav.action) {
        var action = conversation.activeBlock.getAction(nav.action);
        if (action) {
            action.start(function () {
                action.navigate();
            });
            return action;
        }
    }

    /*
    function clickHandler(ev) {
        //TODO react to URL changes https://developer.mozilla.org/en/docs/Web/API/WindowEventHandlers/onhashchange
        // https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_pushState()_method
        if (ev.target.action) {
            ev.target.action.start(() => {
                ev.target.action.navigate();
            });
            ev.preventDefault();
        }
    }
     */
}

function applyHistoryState(hash, state) {
    if (state && state.past) {
        // reduce the past
        // remove the block from DOM
    }
}

/** @jsx createElement */
var ShowcaseCard = function (_Component) {
	babelHelpers.inherits(ShowcaseCard, _Component);

	function ShowcaseCard() {
		var _ref;

		var _temp, _this, _ret;

		babelHelpers.classCallCheck(this, ShowcaseCard);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = ShowcaseCard.__proto__ || Object.getPrototypeOf(ShowcaseCard)).call.apply(_ref, [this].concat(args))), _this), _this.onClick = _this.onClick.bind(_this), _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
	}

	babelHelpers.createClass(ShowcaseCard, [{
		key: "onClick",
		value: function onClick(event) {
			// const onClick = target.getAttribute('on-click');
			// switch(onClick) {
			// 	case 'previous': return this.previous();
			// 	case 'next': return this.next();
			// }
			location.href = this.props.href;
			event.preventDefault();
		}
	}, {
		key: "render",
		value: function render(props) {
			// {this.props.subtitle && <h4>{this.props.subtitle}</h4>}
			// {this.props.author && <h6 class="author">{this.props.author}</h6>}
			// already read? author? current marking? new? related articles? update bubbles?

			//TODO className="active" if active property?
			return createElement$2(
				"flow-card",
				{ title: props.title, style: "background-image: url(" + props.src + ")" },
				createElement$2(
					"div",
					{ className: "titles", onclick: this.onClick },
					props.title && createElement$2(
						"h2",
						null,
						props.title
					),
					props.actionText && createElement$2(
						"h4",
						null,
						createElement$2(
							"a",
							{ href: props.href },
							props.actionText
						)
					)
				)
			);
		}
	}]);
	return ShowcaseCard;
}(Component$1);

var _dec$5;
var _class$5;

/** @jsx createElement */
function showcaseFromSeed(el) {
	var img = el.querySelector('img');
	var attr1 = img ? img.src : (el.style.backgroundImage || '').replace('url("undefined")', '').replace('"', '').replace('url(', '').replace(')', '');
	var src = (el.getAttribute('img') || attr1).replace(/ /g, '%20');
	return {
		date: coerceDate(el.getAttribute('date')),
		priority: coerceNumber(el.getAttribute('priority')),
		title: el.getAttribute('title'),
		subtitle: el.getAttribute('subtitle'),
		href: el.getAttribute('href'),
		actionText: el.getAttribute('action-text'),
		authorKey: el.getAttribute('authorkey'),
		location: el.getAttribute('location'),
		src: src
	};
}

function coerceDate(dateLike) {
	switch (typeof dateLike === 'undefined' ? 'undefined' : babelHelpers.typeof(dateLike)) {
		case 'string':
		case 'number':
			return new Date(dateLike);
		case 'object':
			return dateLike;
		default:
			return null;
	}
}

function coerceNumber(numberLike) {
	switch (typeof numberLike === 'undefined' ? 'undefined' : babelHelpers.typeof(numberLike)) {
		case 'string':
			return Number(numberLike) || 0;
		default:
			return 0;
	}
}

function sortShowcase(a, b) {
	if (a.priority && !b.priority) return -1;
	if (!a.priority && b.priority) return 1;

	if (a.date > b.date) {
		return -1;
	}
	if (a.date < b.date) {
		return 1;
	}
	// a must be equal to b
	return 0;
}

function extractAction(showcases) {
	var payload = showcases.sort(sortShowcase);
	return {
		type: 'set showcase list',
		payload: payload
	};
}

// init through the DOM (this = element)
function connectedCallback$1(el, showcase) {
	el.innerHTML = '';
}

(_dec$5 = AsCustomElement({
	tag: 'context-showcase',
	treeRenderer: infernoTreeRenderer,
	state: stateFromStore,
	stateSelector: function stateSelector(storeState) {
		return storeState.showcase;
	},
	stateExtractorSelector: 'flow-card,showcase-link',
	stateExtractor: function stateExtractor(props, children) {
		return extractAction(children.map(showcaseFromSeed));
	},
	connectedCallback: connectedCallback$1
}), _dec$5(_class$5 = function (_Component) {
	babelHelpers.inherits(ContextShowcase, _Component);

	function ContextShowcase() {
		babelHelpers.classCallCheck(this, ContextShowcase);
		return babelHelpers.possibleConstructorReturn(this, (ContextShowcase.__proto__ || Object.getPrototypeOf(ContextShowcase)).apply(this, arguments));
	}

	babelHelpers.createClass(ContextShowcase, [{
		key: 'componentDidMount',
		value: function componentDidMount() {}
	}, {
		key: 'render',
		value: function render(props) {
			var state = this.selector.state || [];
			return createElement$2(
				'div',
				null,
				state.map && state.map(function (entry) {
					return createElement$2(ShowcaseCard, entry);
				})
			);
		}
	}], [{
		key: 'properties',
		get: function get() {}
	}]);
	return ContextShowcase;
}(Component$1)) || _class$5);

// import Card from './flow-card.element';

// TODO css object-fit, naturalWidth, naturalHeight lowSrc use to make smart img tags.

var _dec$6;
var _class$6;

/** @jsx createElement */
(_dec$6 = AsCustomElement({
    tag: 'alt-texts',
    // treeRenderer: infernoTreeRenderer,

    // trigger when scrolled into view
    connectedCallback: function connectedCallback(el) {
        el.hidden = false;
        if (el.firstElementChild) {
            var real = el.firstElementChild.cloneNode();
            // add something with .cloneNode(); if all are templates
            //TODO add active-bubble to bubble
            for (var child = el.firstElementChild, delay = 0; child; child = child.nextElementSibling) {
                child.style.display = 'none';
                var text = (child.content || child).textContent;
                TweenLite.to(real, .4, { delay: delay, text: text, ease: Linear.easeNone });
                delay += 2;
            }
            //TODO when animations are done remove active-bubble from bubble
            el.appendChild(real);
        }
    }
}), _dec$6(_class$6 = function (_Component) {
    babelHelpers.inherits(AltTexts, _Component);

    function AltTexts() {
        babelHelpers.classCallCheck(this, AltTexts);
        return babelHelpers.possibleConstructorReturn(this, (AltTexts.__proto__ || Object.getPrototypeOf(AltTexts)).apply(this, arguments));
    }

    babelHelpers.createClass(AltTexts, [{
        key: 'scrolledIntoViewCallback',
        value: function scrolledIntoViewCallback() {
            //TODO redo the connectedCallback
        }
    }]);
    return AltTexts;
}(Component$1)) || _class$6);

/*

$(function () {

    var t = ["COOL", "KNOWLEDGE", "DYNAMIC", "EXPERTS", "MARKETING"],
        $h1 = $(".weare__rotativa"),
        $sp = $h1.find(".weare__rotativa--highlight"),
        i = 0,
        widths = [];

    $.each(t, function (i, v) {
        var el = $('<span />', {
            text: v
        }).appendTo($h1);
        widths.push(el.width());
        el.remove();
    });

   $sp.css({
        opacity: 0
    });

    (function loop() {
        i = ++i % t.length;
        $sp.text(t[i]).animate({width: widths[i]}, 500, function () {
//                TweenLite.to($sp.text(t[i]), 0.5, {width:widths[i], onComplete:function () {
            TweenLite.to($sp.text(t[i]), 0.5, {autoAlpha:1});
            TweenLite.to($sp.text(t[i]), 0.5, {autoAlpha:0, delay:2, onComplete:loop});
//            }});
        });
    })();
});


*/

var _dec$7;
var _class$7;

/** @jsx createElement */
var timerSymbol = Symbol();

var TimeCountdown = (_dec$7 = AsCustomElement({
    tag: 'time-countdown',
    treeRenderer: infernoTreeRenderer,
    disconnectedCallback: function disconnectedCallback(el) {
        if (el[timerSymbol]) clearTimeout(el[timerSymbol]);
    }
}), _dec$7(_class$7 = function (_Component) {
    babelHelpers.inherits(TimeCountdown, _Component);
    babelHelpers.createClass(TimeCountdown, null, [{
        key: 'properties',
        get: function get() {
            return {
                //TODO fix Date coerce from string
                time: { type: Date, attribute: true, default: null },
                showSeconds: { type: Boolean, default: true }
            };
        }

        // state:
        // days: Number,
        // hours: Number,
        // minutes: Number,
        // seconds: Number,    

    }]);

    function TimeCountdown(props) {
        babelHelpers.classCallCheck(this, TimeCountdown);

        var _this = babelHelpers.possibleConstructorReturn(this, (TimeCountdown.__proto__ || Object.getPrototypeOf(TimeCountdown)).call(this, props));

        _this.state = { days: 0, hours: 0, minutes: 0, seconds: 0 };
        setTimeout(function () {
            return _this.updateTime();
        }, 30);
        return _this;
    }

    babelHelpers.createClass(TimeCountdown, [{
        key: 'updateTime',
        value: function updateTime() {
            var seconds_left = (new Date(this.props.time).getTime() - Date.now()) / 1000;
            var days = 0,
                hours = 0,
                minutes = 0,
                seconds = 0;

            // do some time calculations
            days = parseInt(seconds_left / 86400);
            seconds_left = seconds_left % 86400;

            hours = parseInt(seconds_left / 3600);
            seconds_left = seconds_left % 3600;

            minutes = parseInt(seconds_left / 60);
            seconds = parseInt(seconds_left % 60);
            if (days > 0 || hours > 0 || minutes > 0 || seconds > 0) {
                var ms_left = seconds_left % 60 * 1000;
                var delay = this.showSeconds ? ms_left % 1000 : ms_left;
                this[timerSymbol] = setTimeout(this.updateTime.bind(this), delay);
            } else {
                days = 0;
                hours = 0;
                minutes = 0;
                seconds = 0;
                this[timerSymbol] = null;
            }

            this.setState({ days: days, hours: hours, minutes: minutes, seconds: seconds });
        }
    }, {
        key: 'render',
        value: function render(props, _ref) {
            var days = _ref.days,
                hours = _ref.hours,
                minutes = _ref.minutes,
                seconds = _ref.seconds;

            return createElement$2(
                'span',
                null,
                createElement$2(
                    'div',
                    { 'class': 'time-countdown__digit time-countdown__days' },
                    createElement$2(
                        'div',
                        { 'class': 'time days' },
                        days || 0
                    ),
                    createElement$2(
                        'div',
                        { 'class': 'time-countdown__label' },
                        'days'
                    )
                ),
                createElement$2(
                    'div',
                    { 'class': 'time-countdown__digit time-countdown__hours' },
                    createElement$2(
                        'div',
                        { 'class': 'time hours' },
                        hours || 0
                    ),
                    createElement$2(
                        'div',
                        { 'class': 'time-countdown__label' },
                        'hours'
                    )
                ),
                createElement$2(
                    'div',
                    { 'class': 'time-countdown__digit time-countdown__minutes' },
                    createElement$2(
                        'div',
                        { 'class': 'time minutes' },
                        minutes || 0
                    ),
                    createElement$2(
                        'div',
                        { 'class': 'time-countdown__label' },
                        'mins'
                    )
                ),
                this.showSeconds && createElement$2(
                    'div',
                    { 'class': 'time-countdown__digit time-countdown__seconds' },
                    createElement$2(
                        'div',
                        { 'class': 'time seconds' },
                        seconds || 0
                    ),
                    createElement$2(
                        'div',
                        { 'class': 'time-countdown__label' },
                        'seconds'
                    )
                )
            );
        }
    }]);
    return TimeCountdown;
}(Component$1)) || _class$7);

var hookCallback;

function hooks() {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback(callback) {
    hookCallback = callback;
}

function isArray$6(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject$8(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined$4(input) {
    return input === void 0;
}

function isNumber$1(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map$1(arr, fn) {
    var res = [],
        i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function some(fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        } else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid(flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    } else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined$4(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined$4(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined$4(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined$4(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined$4(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined$4(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined$4(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined$4(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined$4(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined$4(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined$4(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}

function absFloor(number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (babelHelpers.typeof(arguments[i]) === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction$2(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set$2(config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction$2(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
        prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject$8(parentConfig[prop]) && isObject$8(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$8(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys$1;

if (Object.keys) {
    keys$1 = Object.keys;
} else {
    keys$1 = function keys$1(obj) {
        var i,
            res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$2 = keys$1;

var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
};

function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction$2(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat(key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate() {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal$1(number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    ss: '%d seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
};

function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction$2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}

function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction$2(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({ unit: u, priority: priorities[u] });
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet(unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$3(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get$2(this, unit);
        }
    };
}

function get$2(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$3(mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction$2(this[units])) {
        return this[units]();
    }
    return this;
}

function stringSet(units, value) {
    if ((typeof units === 'undefined' ? 'undefined' : babelHelpers.typeof(units)) === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction$2(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function func() {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
        i,
        length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '',
            i;
        for (i = 0; i < length; i++) {
            output += isFunction$2(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1 = /\d/; //       0 - 9
var match2 = /\d\d/; //      00 - 99
var match3 = /\d{3}/; //     000 - 999
var match4 = /\d{4}/; //    0000 - 9999
var match6 = /[+-]?\d{6}/; // -999999 - 999999
var match1to2 = /\d\d?/; //       0 - 99
var match3to4 = /\d\d\d\d?/; //     999 - 9999
var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3 = /\d{1,3}/; //       0 - 999
var match1to4 = /\d{1,4}/; //       0 - 9999
var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

var matchUnsigned = /\d+/; //       0 - inf
var matchSigned = /[+-]?\d+/; //    -inf - inf

var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

var regexes = {};

function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction$2(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
    };
}

function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken(token, callback) {
    var i,
        func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber$1(callback)) {
        func = function func(input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function indexOf(o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M', match1to2);
addRegexToken('MM', match1to2, match2);
addRegexToken('MMM', function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths(m, format) {
    if (!m) {
        return isArray$6(this._months) ? this._months : this._months['standalone'];
    }
    return isArray$6(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort(m, format) {
    if (!m) {
        return isArray$6(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
    }
    return isArray$6(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth(mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber$1(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth(value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get$2(this, 'Month');
    }
}

function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse() {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY', 4], 0, 'year');
addFormatToken(0, ['YYYYY', 5], 0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y', matchSigned);
addRegexToken('YY', match1to2, match2);
addRegexToken('YYYY', match1to4, match4);
addRegexToken('YYYYY', match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear() {
    return isLeapYear(this.year());
}

function createDate(y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
    fwd = 7 + dow - doy,

    // first-week day local weekday -- which local weekday is fwd
    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w', match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W', match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow: 0, // Sunday is the first day of the week.
    doy: 6 // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek() {
    return this._week.dow;
}

function localeFirstDayOfYear() {
    return this._week.doy;
}

// MOMENTS

function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d', match1to2);
addRegexToken('e', match1to2);
addRegexToken('E', match1to2);
addRegexToken('dd', function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd', function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd', function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays(m, format) {
    if (!m) {
        return isArray$6(this._weekdays) ? this._weekdays : this._weekdays['standalone'];
    }
    return isArray$6(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort(m) {
    return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin(m) {
    return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek(input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}

function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});

function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a', matchMeridiem);
addRegexToken('A', matchMeridiem);
addRegexToken('H', match1to2);
addRegexToken('h', match1to2);
addRegexToken('k', match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + '').toLowerCase().charAt(0) === 'p';
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}

// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
        if (isUndefined$4(values)) {
            data = getLocale(key);
        } else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale(name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);

        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale,
            parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale(key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray$6(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$2(locales);
}

function checkOverflow(m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/],
// YYYYMM is NOT allowed by the standard
['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];

// iso time formats and regexes
var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat, dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i.replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
    .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
    .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + (match[1].length === 5 ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + (match[2].length > 10 ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) {
            // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][momentDate.getDay()];

            if (match[1].substr(0, 3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2:
                // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = (timezoneIndex < 0 ? ' -' : ' +') + ('' + timezoneIndex).replace(/^-?/, '0').match(/..$/)[0] + '00';
                }
                break;
            case 4:
                // Zone
                timezone = timezones[match[5]];
                break;
            default:
                // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
});

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            } else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}

function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map$1([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig(config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || format === undefined && input === '') {
        return createInvalid({ nullInput: true });
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray$6(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    } else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined$4(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray$6(input)) {
        config._a = map$1(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject$8(input)) {
        configFromObject(config);
    } else if (isNumber$1(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if (isObject$8(input) && isObjectEmpty(input) || isArray$6(input) && input.length === 0) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
    } else {
        return createInvalid();
    }
});

var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
    } else {
        return createInvalid();
    }
});

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray$6(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min$2() {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max$1() {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function now() {
    return Date.now ? Date.now() : +new Date();
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
    minutes * 6e4 + // 1000 * 60
    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days + weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months + quarters * 3 + years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration(obj) {
    return obj instanceof Duration;
}

function absRound(number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z', matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone(input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset() {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        } else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}

function isDaylightSavingTimeShifted() {
    if (!isUndefined$4(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal() {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
}

function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration(input, key) {
    var duration = input,

    // matching against regexp is expensive, do it on demand
    match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        };
    } else if (isNumber$1(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
        };
    } else if (duration == null) {
        // checks for null or undefined
        duration = {};
    } else if ((typeof duration === 'undefined' ? 'undefined' : babelHelpers.typeof(duration)) === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = { milliseconds: 0, months: 0 };

    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +base.clone().add(res.months, 'M');

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val;val = period;period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$3(mom, 'Date', get$2(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get$2(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add$1 = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1(time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction$2(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone() {
    return new Moment(this);
}

function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined$4(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined$4(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween(from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
}

function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
}

function diff(input, units, asFloat) {
    var that, zoneDelta, delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
        units === 'minute' ? delta / 6e4 : // 1000 * 60
        units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
        units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
        units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
        delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff(a, b) {
    // difference in months
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),

    // b is in (anchor - 1 month, anchor + 1 month)
    anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString$3() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction$2(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect() {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format(inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from$3(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale(key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
    if (key === undefined) {
        return this.localeData();
    } else {
        return this.locale(key);
    }
});

function localeData() {
    return this._locale;
}

function startOf(units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
        /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
        /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
        /* falls through */
        case 'hour':
            this.minutes(0);
        /* falls through */
        case 'minute':
            this.seconds(0);
        /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf(units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');
}

function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 60000;
}

function unix() {
    return Math.floor(this.valueOf() / 1000);
}

function toDate() {
    return new Date(this.valueOf());
}

function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject$4() {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2() {
    return isValid(this);
}

function parsingFlags() {
    return extend({}, getParsingFlags(this));
}

function invalidAt() {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg', 'weekYear');
addWeekYearFormatToken('ggggg', 'weekYear');
addWeekYearFormatToken('GGGG', 'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);

// PARSING

addRegexToken('G', matchSigned);
addRegexToken('g', matchSigned);
addRegexToken('GG', match1to2, match2);
addRegexToken('gg', match1to2, match2);
addRegexToken('GGGG', match1to4, match4);
addRegexToken('gggg', match1to4, match4);
addRegexToken('GGGGG', match1to6, match6);
addRegexToken('ggggg', match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
}

function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D', match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD', match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m', match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s', match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});

// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S', match1to3, match1);
addRegexToken('SS', match1to3, match2);
addRegexToken('SSS', match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z', 0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add = add$1;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from$3;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject$4;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
proto.toJSON = toJSON;
proto.toString = toString$3;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;

// Year
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix(input) {
    return createLocal(input * 1000);
}

function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat(string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal$1;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set$2;

// Month
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;

proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$3(format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl(format, index, field) {
    if (isNumber$1(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$3(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$3(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber$1(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber$1(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$3(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$3(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function ordinal(number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs() {
    var data = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);

    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);

    return this;
}

function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$2(input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil(number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;

    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;

    hours = absFloor(minutes / 60);
    data.hours = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days = days;
    data.months = months;
    data.years = years;

    return this;
}

function daysToMonths(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays(months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as(units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week':
                return days / 7 + milliseconds / 6048e5;
            case 'day':
                return days + milliseconds / 864e5;
            case 'hour':
                return days * 24 + milliseconds / 36e5;
            case 'minute':
                return days * 1440 + milliseconds / 6e4;
            case 'second':
                return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;
            default:
                throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1() {
    if (!this.isValid()) {
        return NaN;
    }
    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}

function makeAs(alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds = makeAs('s');
var asMinutes = makeAs('m');
var asHours = makeAs('h');
var asDays = makeAs('d');
var asWeeks = makeAs('w');
var asMonths = makeAs('M');
var asYears = makeAs('y');

function get$4(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds = makeGetter('seconds');
var minutes = makeGetter('minutes');
var hours = makeGetter('hours');
var days = makeGetter('days');
var months = makeGetter('months');
var years = makeGetter('years');

function weeks() {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44, // a few seconds to seconds
    s: 45, // seconds to minute
    m: 45, // minutes to hour
    h: 22, // hours to day
    d: 26, // days to month
    M: 11 // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1(posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds = round(duration.as('s'));
    var minutes = round(duration.as('m'));
    var hours = round(duration.as('h'));
    var days = round(duration.as('d'));
    var months = round(duration.as('M'));
    var years = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize(withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days = abs$1(this._days);
    var months = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$2;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.get = get$4;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports

//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn = proto;
hooks.min = min$2;
hooks.max = max$1;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;

var _dec$8;
var _class$8;

/** @jsx createElement */
var debug$2 = debug$1('slides');

var TrackPlan = function () {
    function TrackPlan() {
        babelHelpers.classCallCheck(this, TrackPlan);

        this.lastTrackName = null;
        this.tracks = {};
    }

    babelHelpers.createClass(TrackPlan, [{
        key: 'add',
        value: function add(el) {
            var trackName = el.getAttribute('track');
            if (trackName === null) {
                trackName = this.lastTrackName ? String.fromCodePoint(trackName.codePointAt(0) + 1) : 'a';
            }
            trackName = trackName.toLowerCase();
            this.lastTrackName = trackName;
            var track = this.tracks[trackName] = this.tracks[trackName] || [];

            track.push(el);
        }
    }, {
        key: 'forEachColumn',
        value: function forEachColumn(fn) {
            var _this = this;

            Object.keys(this.tracks).forEach(function (trackName) {
                fn(trackName, _this.tracks[trackName]);
            });
        }
    }]);
    return TrackPlan;
}();

var timerSymbol$1 = Symbol();

var FlowSlides = (_dec$8 = AsCustomElement({
    tag: 'flow-slides',
    treeRenderer: infernoTreeRenderer,
    connectedCallback: function connectedCallback(el, props) {
        var seeders = Array.from(document.querySelectorAll('seed-slides'));
        var plan = new TrackPlan();

        seeders.forEach(function (seeder) {
            Array.from(seeder.children).forEach(function (slideContent) {
                plan.add(slideContent);
                slideContent.parentNode.removeChild(slideContent);
            });
        });

        plan.forEachColumn(function (track, elements) {
            var column = document.createElement('flow-column');
            column.classList.add('flow-slides__column');
            column.classList.add('flow-slides__column-' + track);
            if (track === 'b') column.style.order = '-1';
            elements.forEach(function (el) {
                var slide = document.createElement('flow-slide');
                slide.classList.add('flow-slides__slide');
                slide.appendChild(el);
                column.appendChild(slide);
            });
            el.appendChild(column);
        });

        // 3 columns are added but the middel disappears???

        var animating = void 0;
        var runs = 0;

        var animateNextColumn = function animateNextColumn() {
            // show much less after 12 animations
            if (runs > 12 && runs % 5 != 0) return;

            if (animating) animating.classList.remove('flow-slides__animating');
            animating = animating && animating.nextElementSibling || el.firstElementChild;
            animating.classList.add('flow-slides__animating');
            ++runs;
        };

        animateNextColumn();
        setInterval(animateNextColumn, 10 * 1000);
    },
    disconnectedCallback: function disconnectedCallback(el) {
        clearInterval(el[timerSymbol$1]);
    }
}), _dec$8(_class$8 = function (_Component) {
    babelHelpers.inherits(FlowSlides, _Component);

    function FlowSlides() {
        babelHelpers.classCallCheck(this, FlowSlides);
        return babelHelpers.possibleConstructorReturn(this, (FlowSlides.__proto__ || Object.getPrototypeOf(FlowSlides)).apply(this, arguments));
    }

    babelHelpers.createClass(FlowSlides, null, [{
        key: 'properties',
        get: function get() {
            return {
                datetime: { type: Date, attribute: true, default: null },
                format: { type: String, default: 'dddd, MMMM Do YYYY, hh:mm' }
            };
        }
    }]);
    return FlowSlides;
}(Component$1)) || _class$8);

var _dec$9;
var _class$9;

/** @jsx createElement */
hooks.locale(document.documentElement.lang || 'en');

var FlowTime = (_dec$9 = AsCustomElement({
    tag: 'flow-time',
    treeRenderer: infernoTreeRenderer
}), _dec$9(_class$9 = function (_Component) {
    babelHelpers.inherits(FlowTime, _Component);

    function FlowTime() {
        babelHelpers.classCallCheck(this, FlowTime);
        return babelHelpers.possibleConstructorReturn(this, (FlowTime.__proto__ || Object.getPrototypeOf(FlowTime)).apply(this, arguments));
    }

    babelHelpers.createClass(FlowTime, [{
        key: 'render',
        value: function render(props) {
            if (!props.datetime) return props.originalChildren;
            return props.showUtc ? hooks(props.datetime).utc().format(props.format) : hooks(props.datetime).format(props.format);
        }
    }], [{
        key: 'properties',
        get: function get() {
            return {
                datetime: { type: Date, attribute: true, default: null },
                format: { type: String, default: 'dddd, MMMM Do YYYY, HH:mm' },
                showUtc: { type: Boolean, default: true }
                //TODO children { childrenformat: 'jsonml'}
            };
        }
    }]);
    return FlowTime;
}(Component$1)) || _class$9);

var index$8 = typeof Symbol === 'undefined' ? function (description) {
	return '@' + (description || '@') + Math.random();
} : Symbol;

/*! npm.im/intervalometer */
function intervalometer(cb, request, cancel, requestParameter) {
	var requestId;
	var previousLoopTime;
	function loop(now) {
		// must be requested before cb() because that might call .stop()
		requestId = request(loop, requestParameter);

		// called with "ms since last call". 0 on start()
		cb(now - (previousLoopTime || now));

		previousLoopTime = now;
	}
	return {
		start: function start() {
			if (!requestId) {
				// prevent double starts
				loop(0);
			}
		},
		stop: function stop() {
			cancel(requestId);
			requestId = null;
			previousLoopTime = 0;
		}
	};
}

function frameIntervalometer(cb) {
	return intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);
}

/*! npm.im/iphone-inline-video */
function preventEvent(element, eventName, toggleProperty, preventWithProperty) {
	function handler(e) {
		if (Boolean(element[toggleProperty]) === Boolean(preventWithProperty)) {
			e.stopImmediatePropagation();
			// console.log(eventName, 'prevented on', element);
		}
		delete element[toggleProperty];
	}
	element.addEventListener(eventName, handler, false);

	// Return handler to allow to disable the prevention. Usage:
	// const preventionHandler = preventEvent(el, 'click');
	// el.removeEventHandler('click', preventionHandler);
	return handler;
}

function proxyProperty(object, propertyName, sourceObject, copyFirst) {
	function get() {
		return sourceObject[propertyName];
	}
	function set(value) {
		sourceObject[propertyName] = value;
	}

	if (copyFirst) {
		set(object[propertyName]);
	}

	Object.defineProperty(object, propertyName, { get: get, set: set });
}

function proxyEvent(object, eventName, sourceObject) {
	sourceObject.addEventListener(eventName, function () {
		return object.dispatchEvent(new Event(eventName));
	});
}

function dispatchEventAsync(element, type) {
	Promise.resolve().then(function () {
		element.dispatchEvent(new Event(type));
	});
}

// iOS 10 adds support for native inline playback + silent autoplay
var isWhitelisted = 'object-fit' in document.head.style && /iPhone|iPod/i.test(navigator.userAgent) && !matchMedia('(-webkit-video-playable-inline)').matches;

var ಠ = index$8();
var ಠevent = index$8();
var ಠplay = index$8('nativeplay');
var ಠpause = index$8('nativepause');

/**
 * UTILS
 */

function getAudioFromVideo(video) {
	var audio = new Audio();
	proxyEvent(video, 'play', audio);
	proxyEvent(video, 'playing', audio);
	proxyEvent(video, 'pause', audio);
	audio.crossOrigin = video.crossOrigin;

	// 'data:' causes audio.networkState > 0
	// which then allows to keep <audio> in a resumable playing state
	// i.e. once you set a real src it will keep playing if it was if .play() was called
	audio.src = video.src || video.currentSrc || 'data:';

	// if (audio.src === 'data:') {
	//   TODO: wait for video to be selected
	// }
	return audio;
}

var lastRequests = [];
var requestIndex = 0;
var lastTimeupdateEvent;

function setTime(video, time, rememberOnly) {
	// allow one timeupdate event every 200+ ms
	if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {
		video[ಠevent] = true;
		lastTimeupdateEvent = Date.now();
	}
	if (!rememberOnly) {
		video.currentTime = time;
	}
	lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;
}

function isPlayerEnded(player) {
	return player.driver.currentTime >= player.video.duration;
}

function update(timeDiff) {
	var player = this;
	// console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);
	if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {
		if (!player.hasAudio) {
			player.driver.currentTime = player.video.currentTime + timeDiff * player.video.playbackRate / 1000;
			if (player.video.loop && isPlayerEnded(player)) {
				player.driver.currentTime = 0;
			}
		}
		setTime(player.video, player.driver.currentTime);
	} else if (player.video.networkState === player.video.NETWORK_IDLE && !player.video.buffered.length) {
		// this should happen when the source is available but:
		// - it's potentially playing (.paused === false)
		// - it's not ready to play
		// - it's not loading
		// If it hasAudio, that will be loaded in the 'emptied' handler below
		player.video.load();
		// console.log('Will load');
	}

	// console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');

	if (player.video.ended) {
		delete player.video[ಠevent]; // allow timeupdate event
		player.video.pause(true);
	}
}

/**
 * METHODS
 */

function play$1() {
	// console.log('play');
	var video = this;
	var player = video[ಠ];

	// if it's fullscreen, use the native player
	if (video.webkitDisplayingFullscreen) {
		video[ಠplay]();
		return;
	}

	if (player.driver.src !== 'data:' && player.driver.src !== video.src) {
		// console.log('src changed on play', video.src);
		setTime(video, 0, true);
		player.driver.src = video.src;
	}

	if (!video.paused) {
		return;
	}
	player.paused = false;

	if (!video.buffered.length) {
		// .load() causes the emptied event
		// the alternative is .play()+.pause() but that triggers play/pause events, even worse
		// possibly the alternative is preventing this event only once
		video.load();
	}

	player.driver.play();
	player.updater.start();

	if (!player.hasAudio) {
		dispatchEventAsync(video, 'play');
		if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {
			// console.log('onplay');
			dispatchEventAsync(video, 'playing');
		}
	}
}
function pause$1(forceEvents) {
	// console.log('pause');
	var video = this;
	var player = video[ಠ];

	player.driver.pause();
	player.updater.stop();

	// if it's fullscreen, the developer the native player.pause()
	// This is at the end of pause() because it also
	// needs to make sure that the simulation is paused
	if (video.webkitDisplayingFullscreen) {
		video[ಠpause]();
	}

	if (player.paused && !forceEvents) {
		return;
	}

	player.paused = true;
	if (!player.hasAudio) {
		dispatchEventAsync(video, 'pause');
	}
	if (video.ended) {
		video[ಠevent] = true;
		dispatchEventAsync(video, 'ended');
	}
}

/**
 * SETUP
 */

function addPlayer(video, hasAudio) {
	var player = video[ಠ] = {};
	player.paused = true; // track whether 'pause' events have been fired
	player.hasAudio = hasAudio;
	player.video = video;
	player.updater = frameIntervalometer(update.bind(player));

	if (hasAudio) {
		player.driver = getAudioFromVideo(video);
	} else {
		video.addEventListener('canplay', function () {
			if (!video.paused) {
				// console.log('oncanplay');
				dispatchEventAsync(video, 'playing');
			}
		});
		player.driver = {
			src: video.src || video.currentSrc || 'data:',
			muted: true,
			paused: true,
			pause: function pause$1() {
				player.driver.paused = true;
			},
			play: function play$1() {
				player.driver.paused = false;
				// media automatically goes to 0 if .play() is called when it's done
				if (isPlayerEnded(player)) {
					setTime(video, 0);
				}
			},
			get ended() {
				return isPlayerEnded(player);
			}
		};
	}

	// .load() causes the emptied event
	video.addEventListener('emptied', function () {
		// console.log('driver src is', player.driver.src);
		var wasEmpty = !player.driver.src || player.driver.src === 'data:';
		if (player.driver.src && player.driver.src !== video.src) {
			// console.log('src changed to', video.src);
			setTime(video, 0, true);
			player.driver.src = video.src;
			// playing videos will only keep playing if no src was present when .play()’ed
			if (wasEmpty) {
				player.driver.play();
			} else {
				player.updater.stop();
			}
		}
	}, false);

	// stop programmatic player when OS takes over
	video.addEventListener('webkitbeginfullscreen', function () {
		if (!video.paused) {
			// make sure that the <audio> and the syncer/updater are stopped
			video.pause();

			// play video natively
			video[ಠplay]();
		} else if (hasAudio && !player.driver.buffered.length) {
			// if the first play is native,
			// the <audio> needs to be buffered manually
			// so when the fullscreen ends, it can be set to the same current time
			player.driver.load();
		}
	});
	if (hasAudio) {
		video.addEventListener('webkitendfullscreen', function () {
			// sync audio to new video position
			player.driver.currentTime = video.currentTime;
			// console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');
		});

		// allow seeking
		video.addEventListener('seeking', function () {
			if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {
				// console.log('User-requested seeking');
				player.driver.currentTime = video.currentTime;
			}
		});
	}
}

function overloadAPI(video) {
	var player = video[ಠ];
	video[ಠplay] = video.play;
	video[ಠpause] = video.pause;
	video.play = play$1;
	video.pause = pause$1;
	proxyProperty(video, 'paused', player.driver);
	proxyProperty(video, 'muted', player.driver, true);
	proxyProperty(video, 'playbackRate', player.driver, true);
	proxyProperty(video, 'ended', player.driver);
	proxyProperty(video, 'loop', player.driver, true);
	preventEvent(video, 'seeking');
	preventEvent(video, 'seeked');
	preventEvent(video, 'timeupdate', ಠevent, false);
	preventEvent(video, 'ended', ಠevent, false); // prevent occasional native ended events
}

function enableInlineVideo(video, hasAudio, onlyWhitelisted) {
	if (hasAudio === void 0) hasAudio = true;
	if (onlyWhitelisted === void 0) onlyWhitelisted = true;

	if (onlyWhitelisted && !isWhitelisted || video[ಠ]) {
		return;
	}
	addPlayer(video, hasAudio);
	overloadAPI(video);
	video.classList.add('IIV');
	if (!hasAudio && video.autoplay) {
		video.play();
	}
	if (!/iPhone|iPod|iPad/.test(navigator.platform)) {
		console.warn('iphone-inline-video is not guaranteed to work in emulated environments');
	}
}

enableInlineVideo.isWhitelisted = isWhitelisted;

var debug$3 = debug$1('flow-video');

/*
    video will play automatically muted when page loads
    unmute button is shown
    once played first time a play button is shown
    video only plays when visible (scroll and page visibility)

    Video should be *autoplaying* when
    * in view
    * was not manually paused or ended

    Video starts playing muted when page loads


    TODO Only play one video at a time in the flow.
*/

//TODO activate/deactivate pause/continue

// active FlowView elements
var videos = [];

window.addEventListener('scroll', function (ev) {
    videos.forEach(function (el) {
        if (el.isInView() && !el.playing) el.play();
        if (!el.isInView() && el.playing) el.pause();
    });
});

// if not touch
/*
document.body.addEventListener('mousemove', ev => {
    videos.forEach(el => {
        if (el.contains(ev.target)) el.unmute();
        else el.mute();
    });
});
*/

// Set the name of the hidden property and the change event for visibility
var hiddenDoc;
var visibilityChange;
if (typeof document.hidden !== "undefined") {
    // Opera 12.10 and Firefox 18 and later support
    hiddenDoc = "hidden";
    visibilityChange = "visibilitychange";
} else if (typeof document.msHidden !== "undefined") {
    hiddenDoc = "msHidden";
    visibilityChange = "msvisibilitychange";
} else if (typeof document.webkitHidden !== "undefined") {
    hiddenDoc = "webkitHidden";
    visibilityChange = "webkitvisibilitychange";
}

// Handle page visibility change
document.addEventListener(visibilityChange, function (ev) {
    videos.forEach(function (el) {

        // If the page is hidden, pause the video;
        // if the page is shown, play the video
        if (document[hiddenDoc]) {
            el.pause();
        } else if (el.isInView() && !el.playing) {
            el.play();
        }
    });
}, false);

//TODO tap video over hover it to expose extra Controls

var FlowVideo = function (_HTMLElement) {
    babelHelpers.inherits(FlowVideo, _HTMLElement);

    function FlowVideo() {
        babelHelpers.classCallCheck(this, FlowVideo);
        return babelHelpers.possibleConstructorReturn(this, (FlowVideo.__proto__ || Object.getPrototypeOf(FlowVideo)).apply(this, arguments));
    }

    babelHelpers.createClass(FlowVideo, [{
        key: 'play',
        value: function play(ev, interactive) {
            var _this2 = this;

            var video = this.querySelector('video');

            if (!this.playing && (this.autoplaying || interactive)) {
                this.playing = 1;
                window.requestAnimationFrame(function () {
                    if (_this2.playing === 1) {
                        // unless paused inbetween
                        if (video.currentTime === video.duration) {
                            video.currentTime = 0;
                        }
                        if (interactive) _this2.unmute();
                        video.play();
                        _this2.playing = 2;
                        _this2.classList.add('playing');
                        _this2.autoplaying = true;
                        debug$3('playing video');
                    }
                });
            }
        }
    }, {
        key: 'pause',
        value: function pause(ev, interactive) {
            var video = this.querySelector('video');

            if (this.playing) {
                if (this.playing === 2) video.pause();
                this.playing = 0;
                this.classList.remove('playing');
                if (interactive) {
                    this.autoplaying = false;
                }
                debug$3('paused video');
            }
        }
    }, {
        key: 'mute',
        value: function mute(ev, interactive) {
            var video = this.querySelector('video');
            video.muted = true;
            this.classList.add('muted');
            if (interactive) this.userMuted = true;
        }
    }, {
        key: 'unmute',
        value: function unmute(ev, interactive) {
            var video = this.querySelector('video');
            // if still hovering after a while unmute
            video.muted = false;
            this.classList.remove('muted');
            if (interactive) this.userMuted = false;
        }
    }, {
        key: 'connectedCallback',


        // attr favor-once = when shown fully don't start over
        value: function connectedCallback() {
            var _this3 = this;

            this.playing = 0; // 0=no, 1=will-play, 2=playing

            var video = this.querySelector('video');
            var markedMute = video.muted;
            video.volume = 0.5; // no so loud

            enableInlineVideo(video, markedMute);

            if (markedMute) this.classList.add('muted');

            //TODO perhaps use riot.observe(video)
            video.addEventListener('ended', function (ev) {
                _this3.playing = 0;
                _this3.classList.remove('playing');
                _this3.autoplaying = false;
            });
            video.addEventListener('pause', function (ev) {
                _this3.playing = 0;
                _this3.classList.remove('playing');
            });

            var flowButtons = Array.from(this.querySelectorAll('button.flow-control'));
            flowButtons.forEach(function (ctl) {
                ctl.type = 'button';
            });

            // any button in flow-video can have a flow-control attribute
            var tapButton = function tapButton(ev) {
                var button = ev.target.closest('button');
                if (button) {
                    var type = button.getAttribute('flow-control');
                    if (type in _this3) _this3[type](ev, true);
                }
            };

            this.addEventListener('touchend', tapButton);
            this.addEventListener('click', tapButton);

            // if hover unmute or if unmute clicked

            // track manual volume change to set the level for unmute
            // this.addEventListener('volumechange');

            videos.push(this);

            // starts out autoplaying
            video.autoplay = true;
            this.autoplaying = true;
            //TODO play if in view

            // initially no autoplay only when connected
            video.currentTime = 0;
            if (this.isInView()) this.play();else this.pause();
        }
    }, {
        key: 'disconnectedCallback',
        value: function disconnectedCallback() {
            var idx = videos.indexOf(this);
            if (idx >= 0) videos.splice(idx, 1);
        }
    }, {
        key: 'isInView',
        value: function isInView() {
            var rect = this.getBoundingClientRect(); // takes scroll into account

            // tab visible
            return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && /*or $(window).height() */
            rect.right <= (window.innerWidth || document.documentElement.clientWidth) /*or $(window).width() */
            ;
        }
    }, {
        key: 'autoplaying',
        get: function get() {
            return this._autoplaying;
        },
        set: function set(a) {
            this._autoplaying = a;
            if (a) this.classList.add('autoplaying');else this.classList.remove('autoplaying');
        }
    }]);
    return FlowVideo;
}(HTMLElement);

var _dec$10;
var _class$10;

/** @jsx createElement */
var TypeformShareButton = (_dec$10 = AsCustomElement({
	tag: 'typeform-share-button',
	treeRenderer: infernoTreeRenderer
}), _dec$10(_class$10 = function (_Component) {
	babelHelpers.inherits(TypeformShareButton, _Component);

	function TypeformShareButton() {
		babelHelpers.classCallCheck(this, TypeformShareButton);
		return babelHelpers.possibleConstructorReturn(this, (TypeformShareButton.__proto__ || Object.getPrototypeOf(TypeformShareButton)).apply(this, arguments));
	}

	babelHelpers.createClass(TypeformShareButton, [{
		key: 'render',


		/*
  <script>
  	(function(){
  		var qs,js,q,s,d=document,gi=d.getElementById,ce=d.createElement,
  		gt=d.getElementsByTagName,id='typef_orm',
  		b='https://s3-eu-west-1.amazonaws.com/share.typeform.com/';
  		if(!gi.call(d,id)){js=ce.call(d,'script');
  		js.id=id;js.src=b+'widget.js';
  		q=gt.call(d,'script')[0];
  		q.parentNode.insertBefore(js,q)
  	}})()
  		</script>
  */

		value: function render(props) {
			var code = '9b7b3baf558d53bea7be8e5b3f0da602ddfb3a3f';
			return;
			createElement$2(
				'span',
				null,
				createElement$2('div', { 'class': 'typeform-widget', 'data-url': 'https://ignorethegap.typeform.com/to/{code}', 'data-text': 'UX Research Questionnaire', style: 'width:100%;height:500px;' }),
				createElement$2(
					'div',
					{ style: 'font-family: Sans-Serif;font-size: 12px;color: #999;opacity: 0.5; padding-top: 5px;' },
					createElement$2(
						'a',
						{ href: 'https://www.typeform.com/examples/surveys/?utm_campaign={code}&utm_source=typeform.com-3471289-Basic&utm_medium=typeform&utm_content=typeform-embedded-onlinesurvey&utm_term=EN', style: 'color: #999', target: '_blank' },
						'Online survey'
					),
					'powered by Typeform'
				)
			);
		}
	}]);
	return TypeformShareButton;
}(Component$1)) || _class$10);

var MDLCard = function (_HTMLElement) {
    babelHelpers.inherits(MDLCard, _HTMLElement);

    function MDLCard() {
        babelHelpers.classCallCheck(this, MDLCard);
        return babelHelpers.possibleConstructorReturn(this, (MDLCard.__proto__ || Object.getPrototypeOf(MDLCard)).apply(this, arguments));
    }

    babelHelpers.createClass(MDLCard, [{
        key: 'connectedCallback',
        value: function connectedCallback() {
            this.testTest = 'test';
        }
    }]);
    return MDLCard;
}(HTMLElement);

customElements.define('mdl-card', MDLCard);

customElements.define('flow-video', FlowVideo);
// TODO css object-fit, naturalWidth, naturalHeight lowSrc use to make smart img tags.

document.documentElement.classList.remove('no-js');
document.documentElement.classList.add('js');

//TODO document layout principle / semantic
var overlayedTopics = document.querySelectorAll('.overlayed-topic');
if (overlayedTopics.length && 'ontouchstart' in document.documentElement) {
    Array.from(overlayedTopics).forEach(function (el) {
        return el.classList.add('touch-scroll');
    });
}

document.Survey = Survey;

//TODO split out in "conversation-flow.js"
// ensureConversationDOM();
// measureDOM();

// TODO magic links that can deduct progress of conversation and adjust UI
// document.body.addEventListener('click', navigateToHref, true);

window.addEventListener('resize', function () {
    //TODO adjust content/view height
});

window.addEventListener('popstate', function (ev) {
    // console.info('pop',ev.path[0].location,ev);
    applyHistoryState(document.location.hash, ev.state);
});

scanTemplates();
registerContentElements();
// applyBlockFromHash(); future forwarding the conversation
// removeHash();
// window.addEventListener('hashchange', applyBlockFromHash);

startConversations(); //TODO only start it if the conversation markup is present

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZWxlbWVudC1jbG9zZXN0L2VsZW1lbnQtY2xvc2VzdC5qcyIsInNoaW1zLmpzIiwiY29udmVyc2F0aW9uL1N1cnZleS5qcyIsImNvbnZlcnNhdGlvbi91c2VyUmVjb3JkLmpzIiwiZG9tL2luY3JlbWVudGFsVGVtcGxhdGVzLmpzIiwiZG9tL2F0dHJpYnV0ZXMuanMiLCJkb20vdGVtcGxhdGVkLmpzIiwiY29udmVyc2F0aW9uL2Jsb2NrLnRlbXBsYXRlLmpzIiwiY29udmVyc2F0aW9uL3N0YXRlbWVudC50ZW1wbGF0ZS5qcyIsImRhdGEvc2hhMS5qcyIsImNvbnZlcnNhdGlvbi9hY3Rpb25zL2lucHV0cy5qcyIsImNvbnZlcnNhdGlvbi9hY3Rpb25zL3RocmVhZC1hY3Rpb24udGVtcGxhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvaW5mZXJuby9kaXN0L2luZGV4LmVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2luZmVybm8tY29tcG9uZW50L2Rpc3QvaW5kZXguZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvaW5mZXJuby1jb21wYXQvZGlzdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pbmZlcm5vLWNvbXBhdC9pbmRleC5qcyIsImRvbS9jYXNlLWNvbnZlcnQuanMiLCJkb20vQXNDdXN0b21FbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2luZmVybm8tY3JlYXRlLWVsZW1lbnQvZGlzdC9pbmRleC5lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9pbmZlcm5vLXZub2RlLWZsYWdzL2Rpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaW5mZXJuby12bm9kZS1mbGFncy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pbmZlcm5vLWRldnRvb2xzL2Rpc3QvaW5kZXguZXMuanMiLCJkb20vaW5mZXJub1RyZWVSZW5kZXJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy96ZW4tb2JzZXJ2YWJsZS96ZW4tb2JzZXJ2YWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy96ZW4tb2JzZXJ2YWJsZS9pbmRleC5qcyIsImNvbnZlcnNhdGlvbi9hY3Rpb25zL2FjdGlvbnMuanMiLCJjb250ZW50L2FjdGlvbnMuanMiLCJzaG93Y2FzZS9hY3Rpb25zLmpzIiwiZGF0YS9jcmVhdGVTZWxlY3Rvci5qcyIsImRhdGEvc3RhdGVGcm9tU3RvcmUuanMiLCJkYXRhL2NvbmZsdXguanMiLCJkb20vQXNTdWJDb21wb25lbnQuanMiLCJjb252ZXJzYXRpb24vQ29udmVyc2F0aW9uQmxvY2suanMiLCJjb252ZXJzYXRpb24vYWN0aW9ucy9UaHJlYWRBY3Rpb24uanMiLCJjb252ZXJzYXRpb24vQ29udmVyc2F0aW9uUmVzcG9uc2UuanMiLCJkZWJ1Zy5qcyIsImNvbnZlcnNhdGlvbi9jb252ZXJzYXRpb24tdGhyZWFkLmVsZW1lbnQuanMiLCJjb252ZXJzYXRpb24vdGhyZWFkLXByZXNlbnRhdGlvbi5lbGVtZW50LmpzIiwiY29udmVyc2F0aW9uL2FjdGlvbnMvdGltZWxpbmUta2lja29mZi5lbGVtZW50LmpzIiwiY29udmVyc2F0aW9uL2luZGV4LmpzIiwic2hvd2Nhc2UvU2hvd2Nhc2VDYXJkLmpzIiwic2hvd2Nhc2UvY29udGV4dC1zaG93Y2FzZS5lbGVtZW50LmpzIiwic2hvd2Nhc2UvaW5kZXguanMiLCJ0eXBvZ3JhcGh5L2FsdC10ZXh0cy5lbGVtZW50LmpzIiwiY29udGVudC90aW1lLWNvdW50ZG93bi5lbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2hvb2tzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2lzLWFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2lzLW9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91dGlscy9pcy1vYmplY3QtZW1wdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdXRpbHMvaXMtdW5kZWZpbmVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2lzLW51bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91dGlscy9pcy1kYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL21hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91dGlscy9oYXMtb3duLXByb3AuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdXRpbHMvZXh0ZW5kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2NyZWF0ZS91dGMuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvY3JlYXRlL3BhcnNpbmctZmxhZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdXRpbHMvc29tZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9jcmVhdGUvdmFsaWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L2NvbnN0cnVjdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2Ficy1mbG9vci5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91dGlscy90by1pbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdXRpbHMvY29tcGFyZS1hcnJheXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdXRpbHMvZGVwcmVjYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2lzLWZ1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2xvY2FsZS9zZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbG9jYWxlL2NvbnN0cnVjdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbG9jYWxlL2NhbGVuZGFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2xvY2FsZS9mb3JtYXRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2xvY2FsZS9pbnZhbGlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2xvY2FsZS9vcmRpbmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2xvY2FsZS9yZWxhdGl2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91bml0cy9hbGlhc2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3VuaXRzL3ByaW9yaXRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L2dldC1zZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdXRpbHMvemVyby1maWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvcGFyc2UvcmVnZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvcGFyc2UvdG9rZW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2luZGV4LW9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3VuaXRzL21vbnRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3VuaXRzL3llYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvY3JlYXRlL2RhdGUtZnJvbS1hcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91bml0cy93ZWVrLWNhbGVuZGFyLXV0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3VuaXRzL3dlZWsuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvZGF5LW9mLXdlZWsuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvaG91ci5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9sb2NhbGUvYmFzZS1jb25maWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbG9jYWxlL2xvY2FsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvY3JlYXRlL2NoZWNrLW92ZXJmbG93LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2NyZWF0ZS9mcm9tLXN0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91dGlscy9kZWZhdWx0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9jcmVhdGUvZnJvbS1hcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9jcmVhdGUvZnJvbS1zdHJpbmctYW5kLWZvcm1hdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9jcmVhdGUvZnJvbS1zdHJpbmctYW5kLWFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2NyZWF0ZS9mcm9tLW9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9jcmVhdGUvZnJvbS1hbnl0aGluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9jcmVhdGUvbG9jYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L21pbi1tYXguanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L25vdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9kdXJhdGlvbi92YWxpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9kdXJhdGlvbi9jb25zdHJ1Y3Rvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91dGlscy9hYnMtcm91bmQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvb2Zmc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2R1cmF0aW9uL2NyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9tb21lbnQvYWRkLXN1YnRyYWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL21vbWVudC9jYWxlbmRhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9tb21lbnQvY2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L2NvbXBhcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L2RpZmYuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L2Zvcm1hdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9tb21lbnQvZnJvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9tb21lbnQvdG8uanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbW9tZW50L2xvY2FsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9tb21lbnQvc3RhcnQtZW5kLW9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL21vbWVudC90by10eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL21vbWVudC92YWxpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9tb21lbnQvY3JlYXRpb24tZGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91bml0cy93ZWVrLXllYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvcXVhcnRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91bml0cy9kYXktb2YtbW9udGguanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvZGF5LW9mLXllYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvbWludXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3VuaXRzL3NlY29uZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91bml0cy9taWxsaXNlY29uZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi91bml0cy90aW1lem9uZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9tb21lbnQvcHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL21vbWVudC9tb21lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbG9jYWxlL3ByZS1wb3N0LWZvcm1hdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9sb2NhbGUvcHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2xvY2FsZS9saXN0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9sb2NhbGUvZW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvbG9jYWxlL2xvY2FsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9kdXJhdGlvbi9hYnMuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvZHVyYXRpb24vYWRkLXN1YnRyYWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3V0aWxzL2Ficy1jZWlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL2R1cmF0aW9uL2J1YmJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9kdXJhdGlvbi9hcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9kdXJhdGlvbi9nZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvZHVyYXRpb24vaHVtYW5pemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvZHVyYXRpb24vaXNvLXN0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9tb21lbnQvc3JjL2xpYi9kdXJhdGlvbi9wcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvZHVyYXRpb24vZHVyYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbW9tZW50L3NyYy9saWIvdW5pdHMvdGltZXN0YW1wLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbGliL3VuaXRzL3VuaXRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21vbWVudC9zcmMvbW9tZW50LmpzIiwiY29udGVudC9mbG93LXNsaWRlcy5lbGVtZW50LmpzIiwiY29udGVudC9mbG93LXRpbWUuZWxlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb29yLW1hbnMtc3ltYm9sL2Rpc3QvcG9vci1tYW5zLXN5bWJvbC5lcy1tb2R1bGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2ludGVydmFsb21ldGVyL2Rpc3QvaW50ZXJ2YWxvbWV0ZXIuZXMtbW9kdWxlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9pcGhvbmUtaW5saW5lLXZpZGVvL2Rpc3QvaXBob25lLWlubGluZS12aWRlby5lcy1tb2R1bGVzLmpzIiwiY29udGVudC9mbG93LXZpZGVvLmVsZW1lbnQuanMiLCJjb250ZW50L3R5cGVmb3JtLXNoYXJlLWJ1dHRvbi5lbGVtZW50LmpzIiwiY29udGVudC9pbmRleC5qcyIsImluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzcGFjZXMgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBzcGFjZSA9ICdbJyArIHNwYWNlcyArICddJztcbnZhciBub24gPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgQUxJQVMpIHtcbiAgdmFyIGV4cCA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmIChBTElBUykgZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uIChzdHJpbmcsIFRZUEUpIHtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuIiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIGlmIChpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYgKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgkcmVwbGFjZXIpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUgKGFMZW4gPiBpbmRleCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG4iLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuIiwiLy8gZWxlbWVudC1jbG9zZXN0IHwgQ0MwLTEuMCB8IGdpdGh1Yi5jb20vam9uYXRoYW50bmVhbC9jbG9zZXN0XG5cbihmdW5jdGlvbiAoRWxlbWVudFByb3RvKSB7XG5cdGlmICh0eXBlb2YgRWxlbWVudFByb3RvLm1hdGNoZXMgIT09ICdmdW5jdGlvbicpIHtcblx0XHRFbGVtZW50UHJvdG8ubWF0Y2hlcyA9IEVsZW1lbnRQcm90by5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50UHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnRQcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZnVuY3Rpb24gbWF0Y2hlcyhzZWxlY3Rvcikge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gKGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudC5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRcdHZhciBpbmRleCA9IDA7XG5cblx0XHRcdHdoaWxlIChlbGVtZW50c1tpbmRleF0gJiYgZWxlbWVudHNbaW5kZXhdICE9PSBlbGVtZW50KSB7XG5cdFx0XHRcdCsraW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBCb29sZWFuKGVsZW1lbnRzW2luZGV4XSk7XG5cdFx0fTtcblx0fVxuXG5cdGlmICh0eXBlb2YgRWxlbWVudFByb3RvLmNsb3Nlc3QgIT09ICdmdW5jdGlvbicpIHtcblx0XHRFbGVtZW50UHJvdG8uY2xvc2VzdCA9IGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcztcblxuXHRcdFx0d2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fVxufSkod2luZG93LkVsZW1lbnQucHJvdG90eXBlKTtcbiIsImltcG9ydCAnY29yZS1qcy9mbi9zdHJpbmcvdHJpbSc7XG5pbXBvcnQgJ2NvcmUtanMvZm4vc3RyaW5nL3N0YXJ0cy13aXRoJztcbmltcG9ydCAnY29yZS1qcy9mbi9zdHJpbmcvZW5kcy13aXRoJztcbmltcG9ydCAnY29yZS1qcy9lczYvc3ltYm9sJztcblxuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L2Zyb20nO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L29mJztcbmltcG9ydCAnY29yZS1qcy9mbi9hcnJheS9maW5kJztcbmltcG9ydCAnY29yZS1qcy9mbi9hcnJheS9maW5kLWluZGV4JztcblxuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9hc3NpZ24nO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9pcyc7XG5cbmltcG9ydCAnZWxlbWVudC1jbG9zZXN0JztcblxuLy8gZWwubWF0Y2hlcyhzZWxlY3RvcikgZnJvbSBNRE5cbmlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPVxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHMpLFxuICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG4gICAgICAgICAgICByZXR1cm4gaSA+IC0xO1xuICAgICAgICB9O1xufVxuXG4vLyBlbC5jbG9zZXN0KHNlbGVjdG9yKSBmcm9tIE1ETlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdFxuaWYgKHdpbmRvdy5FbGVtZW50ICYmICFFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0KSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9XG4gICAgZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGkgPSBtYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IGVsKSB7fTtcbiAgICAgICAgfSB3aGlsZSAoKGkgPCAwKSAmJiAoZWwgPSBlbC5wYXJlbnRFbGVtZW50KSk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3VydmV5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmVzcG9uc2VzID0gW107XG4gICAgfVxuXG4gICAgZmlsZVJlc3BvbnNlKG5hbWUsdGV4dCkge1xuICAgICAgICAvLyB2YXIgcmVzcG9uc2VzID0gdGhpcy5yZXNwb25zZXNbbmFtZV0gPSB0aGlzLnJlc3BvbnNlc1tuYW1lXSB8fCBbXTtcbiAgICAgICAgLy9UT0RPIG1peCBpbiB1cGRhdGUgcmVtb3ZhbElEIGZvciB3aGVuIGl0IHdhcyB1cGxvYWRlZFxuICAgICAgICB2YXIgZW50cnkgPSB7IHN1cnZleTp0aGlzLm5hbWUsIG5hbWU6bmFtZSwgdGV4dDp0ZXh0LCB0eXBlOlwicmVzcG9uc2VcIiB9O1xuICAgICAgICB0aGlzLnJlc3BvbnNlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgc3VydmV5VXBkYXRlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc3VydmV5VXBkYXRlcyA9IEpTT04uc3RyaW5naWZ5KHN1cnZleVVwZGF0ZXMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTdXJ2ZXkobmFtZSkge1xuICAgICAgICBpZiAoU3VydmV5Lmluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgQ29uY3JldGVTdXJ2ZXkgPSBTdXJ2ZXkuYnlOYW1lW25hbWVdIHx8IFN1cnZleS5EZWZhdWx0O1xuICAgICAgICAgICAgU3VydmV5Lmluc3RhbmNlc1tuYW1lXSA9IG5ldyBDb25jcmV0ZVN1cnZleShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3VydmV5Lmluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG59XG5cblN1cnZleS5EZWZhdWx0ID0gY2xhc3MgRGVmYXVsdFN1cnZleSBleHRlbmRzIFN1cnZleSB7XG5cbn07XG5cblN1cnZleS5ieU5hbWUgPSB7fTtcblN1cnZleS5pbnN0YW5jZXMgPSB7fTtcblxudmFyIHN1cnZleVVwZGF0ZXMgPSBKU09OLnBhcnNlKHNlc3Npb25TdG9yYWdlLnN1cnZleVVwZGF0ZXMgfHwgXCJbXVwiKTtcbiIsIi8vIGlmIG5vIHVuaXF1ZSBJRCBjcmVhdGUgb25lXG52YXIga2V5ID0gbG9jYXRpb24ucGF0aG5hbWU7XG5cbmV4cG9ydCB2YXIgYWxsUGFzdENvbnZlcnNhdGlvbiA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmFsbFBhc3RDb252ZXJzYXRpb24gfHwgXCJ7fVwiKTtcbmV4cG9ydCB2YXIgcGFzdENvbnZlcnNhdGlvbiA9IGFsbFBhc3RDb252ZXJzYXRpb25ba2V5XTtcblxuaWYgKCFwYXN0Q29udmVyc2F0aW9uKSB7XG4gICAgcGFzdENvbnZlcnNhdGlvbiA9IGFsbFBhc3RDb252ZXJzYXRpb25ba2V5XSA9IFtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkQmxvY2soaWQsYmxvY2spIHtcbiAgICBwYXN0Q29udmVyc2F0aW9uLnB1c2goe1xuICAgICAgICBibG9jazogaWRcbiAgICB9KTtcbiAgICBsb2NhbFN0b3JhZ2UucGFzdENvbnZlcnNhdGlvbiA9IEpTT04uc3RyaW5naWZ5KHBhc3RDb252ZXJzYXRpb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkQWN0aW9uKGFjdGlvbix0ZXh0KSB7XG4gICAgcGFzdENvbnZlcnNhdGlvbi5wdXNoKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24ubGFiZWwgfHwgdHJ1ZSxcbiAgICAgICAgbGFiZWw6IGFjdGlvbi5sYWJlbCxcbiAgICAgICAgYmxvY2s6IGFjdGlvbi5ibG9jaz8gYWN0aW9uLmJsb2NrLm5hbWUgOiBudWxsLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgfSk7XG4gICAgbG9jYWxTdG9yYWdlLmFsbFBhc3RDb252ZXJzYXRpb24gPSBKU09OLnN0cmluZ2lmeShhbGxQYXN0Q29udmVyc2F0aW9uKTtcbn1cblxuLypcblxuY2hvaWNlIG5hbWVzcGFjZSArIG5hbWVcbmluY29tcGxldGUgc3VydmV5c1xuc3VnZ2VzdGVkIHJlc291cmNlc1xudW5zZW50IGNvbXBsZXRlIHN1cnZleXNcblxuKi9cbiIsInZhciBjdXN0b21UYWdzID0ge307XG52YXIgY3VzdG9tVXBncmFkZXJzID0gW107XG52YXIgdW5pcXVlcyA9IHt9O1xuXG52YXIgd2FpdGluZ0ZvciA9IDE7IC8vIHdhaXRpbmcgZm9yIE4gaWRzIHRvIGNvbXBsZXRlXG52YXIgZmlyZVJlYWR5OyAvLyB0aGlzIGlzIGZvciByZXNvbHZpbmcgdGhlIHVwZ3JhZGVkIHByb21pc2VcblxuY29uc3QgdXBncmFkZWRGbGFnID0gU3ltYm9sKCd1cGdyYWRlZCcpO1xuY29uc3QgVVBHUkFERV9BUEkgPSB7ICd1cGdyYWRlZENhbGxiYWNrJzp0cnVlLCAndXBncmFkZUNhbGxiYWNrJzp0cnVlLCBpZGVudGlmeTogdHJ1ZSB9O1xuXG5jb25zdCBJRF9OQU1FID0gJ3RlbXBsYXRlSWQnO1xuXG5sZXQgaW5jcmVtZW50YWxUZW1wbGF0ZXMgPSB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICB1bmlxdWUsXG4gICAgZGVmaW5lLFxuICAgIHVwZ3JhZGVET00sXG4gICAgdXBncmFkZUVsZW1lbnQsXG4gICAgdXBncmFkZWRFbGVtZW50LFxuICAgIHJlYWR5OiBmYWxzZSxcbiAgICB1cGdyYWRlZDogbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgICAgZmlyZVJlYWR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaW5jcmVtZW50YWxUZW1wbGF0ZXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvL1RPRE8gaWYgaWQgZmFpbHMsIHNob3VsZCB0aGlzIGZhaWw/XG4gICAgfSlcbn07XG5cbmZ1bmN0aW9uIHVuaXF1ZSh0YWcpIHtcbiAgICBpZiAoISB1bmlxdWVzW3RhZ10pIHVuaXF1ZXNbdGFnXSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIHVuaXF1ZXNbdGFnXTtcbn1cblxuZnVuY3Rpb24gZ2V0KGlkLCB0YWcgPSAndGVtcGxhdGUnKSB7XG4gICAgcmV0dXJuIHVuaXF1ZSh0YWcpW2lkXTtcbn1cblxuZnVuY3Rpb24gc2V0KGlkLCBlbCwgdGFnID0gJ3RlbXBsYXRlJykge1xuICAgIHVuaXF1ZSh0YWcpW2lkXSA9IGVsO1xufVxuXG5mdW5jdGlvbiBkZWZpbmUodGFnLCBjb25zdHJ1Y3Rvcikge1xuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjdXN0b21UYWdzW3RhZ10gPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGluY3JlbWVudGFsVGVtcGxhdGVzLnJlYWR5KSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJykpLmZvckVhY2godGVtcGxhdGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVt1cGdyYWRlZEZsYWddKSB0ZW1wbGF0ZVt0YWddID0gY29uc3RydWN0b3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjdXN0b21VcGdyYWRlcnMucHVzaChbdGFnLCBjb25zdHJ1Y3Rvcl0pO1xuICAgICAgICAvL1RPRE8gaWYgaW5jcmVtZW50YWxUZW1wbGF0ZXMudXBncmFkZWRcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVFbGVtZW50KGVsLCBjb25zdHJ1Y3RvciwgdGVtcGxhdGUsIGNhbGxiYWNrTmFtZSA9ICd1cGdyYWRlQ2FsbGJhY2snKSB7XG4gICAgY29uc3QgcHJvdG8gPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBwcm90b1tjYWxsYmFja05hbWVdO1xuICAgIGNvbnN0IGlkZW50aWZ5ID0gcHJvdG8uaWRlbnRpZnk7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChuID0+IHtcbiAgICAgICAgaWYgKCEgVVBHUkFERV9BUElbbl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbik7XG4gICAgICAgICAgICBpZiAoZGVzY3IuZ2V0IHx8IGRlc2NyLnNldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBuLCBkZXNjcik7XG4gICAgICAgICAgICBlbHNlIGVsW25dID0gcHJvdG9bbl07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGVsLmlzRnJvbSA9IGNvbnN0cnVjdG9yO1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2suY2FsbChlbCwgdGVtcGxhdGUpO1xuXG4gICAgLy9UT0RPIGNvbnNpZGVyIHdoYXQgdG8gZG8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIHVwZ3JhZGVzIGZvciBlbGVtZW50XG4gICAgaWYgKGlkZW50aWZ5KSB7XG4gICAgICAgIGNvbnN0IGlkID0gaWRlbnRpZnkuY2FsbChlbCwgdGVtcGxhdGUpO1xuXG4gICAgICAgIGlmICghaWQpIHsgcmV0dXJuOyB9IC8vIGxvZyB0aGF0IHRoZSB0ZW1wbGF0ZSBpcyBpZ25vcmVkIHdpdGhvdXQgaWRcblxuICAgICAgICAvLyBpZiBwcm9taXNlIGtlZXAgdHJhY2sgb24gd2hlbiBpdCdzIGRvbmVcbiAgICAgICAgaWYgKGlkICYmIGlkLnRoZW4pIHtcbiAgICAgICAgICAgIGlkLnRoZW4obGF0ZVNhdmVJZCk7XG4gICAgICAgICAgICArK3dhaXRpbmdGb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYXZlSWQoaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGF0ZVNhdmVJZChpZCkge1xuICAgICAgICBzYXZlSWQoaWQpO1xuICAgICAgICBpZiAoLS13YWl0aW5nRm9yID09PSAwKSBmaXJlUmVhZHkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXZlSWQoaWQpIHtcbiAgICAgICAgdW5pcXVlKGVsLmxvY2FsTmFtZSlbaWRdID0gZWw7XG4gICAgICAgIGVsW0lEX05BTUVdID0gaWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGdyYWRlZEVsZW1lbnQoZWwsIGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZSwgY2FsbGJhY2tOYW1lID0gJ3VwZ3JhZGVkQ2FsbGJhY2snKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbY2FsbGJhY2tOYW1lXTtcblxuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2suY2FsbChlbCwgdGVtcGxhdGUpO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlRE9NKGRvbSA9IGRvY3VtZW50LCBub2RlTmFtZSA9ICd0ZW1wbGF0ZVtpbmNyZW1lbnRhbF0nKSB7XG4gICAgQXJyYXkuZnJvbShkb20ucXVlcnlTZWxlY3RvckFsbChub2RlTmFtZSkpLmZvckVhY2godGVtcGxhdGUgPT4ge1xuICAgICAgICAvL1RPRE8gdXBncmFkZSB0ZW1wbGF0ZXMgYWNjb3JkaW5nIHRvIHNlbGVjdG9ycyBzdGFydGluZyB3aXRoIHRlbXBsYXRlIHRlbXBsYXRlLm1hdGNoZXMoLi4pXG4gICAgICAgIGZvcihsZXQgdGFnIGluIGN1c3RvbVRhZ3MpIHtcbiAgICAgICAgICAgIGlmICh0YWcuaW5kZXhPZigndGVtcGxhdGUnKSA9PT0gMCAmJiB0ZW1wbGF0ZS5tYXRjaGVzKHRhZykpIHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlRWxlbWVudCh0ZW1wbGF0ZSwgY3VzdG9tVGFnc1t0YWddLCB0ZW1wbGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IHRhZyBpbiBjdXN0b21UYWdzKSB7XG4gICAgICAgICAgICAodGVtcGxhdGUuY29udGVudCB8fCB0ZW1wbGF0ZSkucXVlcnlTZWxlY3RvckFsbCh0YWcpLmZvckVhY2goZWwgPT4gdXBncmFkZUVsZW1lbnQoZWwsIGN1c3RvbVRhZ3NbdGFnXSwgdGVtcGxhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21VcGdyYWRlcnMuZm9yRWFjaCh1cGdyYWRlciA9PiB7XG4gICAgICAgICAgICBjb25zdCBbbGlzdGVyLCBjb25zdHJ1Y3Rvcl0gPSB1cGdyYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGVscyA9IGxpc3Rlcih0ZW1wbGF0ZSk7XG4gICAgICAgICAgICBlbHMuZm9yRWFjaChlbCA9PiB1cGdyYWRlRWxlbWVudChlbCwgY29uc3RydWN0b3IsIHRlbXBsYXRlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvcihsZXQgdGFnIGluIGN1c3RvbVRhZ3MpIHtcbiAgICAgICAgICAgIGlmICh0YWcuaW5kZXhPZigndGVtcGxhdGUnKSA9PT0gMCAmJiB0ZW1wbGF0ZS5tYXRjaGVzKHRhZykpIHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlZEVsZW1lbnQodGVtcGxhdGUsIGN1c3RvbVRhZ3NbdGFnXSwgdGVtcGxhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGVtcGxhdGVbdXBncmFkZWRGbGFnXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoZG9tID09PSBkb2N1bWVudCkge1xuICAgICAgICBpZiAoLS13YWl0aW5nRm9yID09PSAwKSBmaXJlUmVhZHkoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluY3JlbWVudGFsVGVtcGxhdGVzO1xuIiwiXG5leHBvcnQgZnVuY3Rpb24gYXR0cnMycHJvcHMoYXR0cnMsIHJlbmFtZSA9IGRlZmF1bHRSZW5hbWUsIGNvZXJjZSA9IGRlZmF1bHRDb2VyY2UpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcblxuICAgIC8vVE9ETyB1c2UgY3VycnlDb21wdXRlUHJvcHMgdG8gbWFrZSBnZW5lcmFsIGltcGxcbiAgICBmb3IgKGxldCBpID0gMCwgYXR0cjsgKGF0dHIgPSBhdHRyc1tpXSk7IGkrKykge1xuICAgICAgICBjb25zdCBuYW1lID0gcmVuYW1lKGF0dHIubmFtZSk7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IGNvZXJjZShuYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRDb2VyY2UobmFtZSx2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5hbWUobmFtZSkge1xuICAgIHJldHVybiBuYW1lICE9PSAnY2hpbGRyZW4nID8gbmFtZSA6IG51bGw7XG59XG4iLCIvKlxuICogVGVtcGxhdGVzIGFyZSBiYXNlZCBvbiBKU09OTUxcbiAqXG4gKiBUaGUgYXR0cmlidXRlcyBvYmplY3QgaXMgc3BsaXQgaW50byBgc3RhdGljYCwgYGR5bmFtaWNgIGFuZCBgdGltaW5nYCB0aGF0IGRlc2NyaWJlcyB0aGUgcmVuZGVyaW5nIHBsYW4uXG4gKlxuIHRoZSBqc29ubWwgYXR0cmlidXRlcyBhcmUgYW4gYXJyYXkgdG8gYWR2b2lkIGNvbnZlcnNpb24gZm9yIGluY3JlbWVudGFsLWRvbVxuICovXG5cbmltcG9ydCB7IGF0dHJzMnByb3BzLCBkZWZhdWx0UmVuYW1lLCBkZWZhdWx0Q29lcmNlIH0gZnJvbSAnLi9hdHRyaWJ1dGVzJztcblxuLy9UT0RPIHNob3VsZCB0ZW1wbGF0aW5nIG9mIGF0dHJpYnV0ZXMgYmUgc3VwcG9ydGVkIHZpYSBjb2VyY2UgLT4gZnVuY3Rpb24gLT4gcmVuZGVycyB3aXRoIGNvbnRleHRcblxuLy8gVE9ETyBvbmx5IHNraXAgYmxhbmsgdGV4dCBlbGVtZW50cyAody4gb25seSB3aGl0ZXNwYWNlKVxuZXhwb3J0IGZ1bmN0aW9uIGZyYWdtZW50Mmpzb25tbChmcmFnbWVudCwgdGFnTmFtZT1udWxsLCBhdHRycz17fSwgb3B0cyA9IHsgcmVuYW1lOiBudWxsLCBjb2VyY2U6IG51bGwsIGJhc2VQcm9wczogbnVsbCB9KSB7XG4gICAgY29uc3QgcmVuYW1lID0gb3B0cy5yZW5hbWUgfHwgZGVmYXVsdFJlbmFtZTtcbiAgICBjb25zdCBjb2VyY2UgPSBvcHRzLmNvZXJjZSB8fCBkZWZhdWx0Q29lcmNlO1xuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICAgIGNvbnN0IGJhc2UgPSBbdGFnTmFtZSwgeyAuLi5iYXNlUHJvcHMsIC4uLmF0dHJzMnByb3BzKGF0dHJzLCByZW5hbWUsIGNvZXJjZSkgfV07XG4gICAgLy9UT0RPIGFzc2lnbiBrZXlzXG5cbiAgICBmaWxsSW5KU09OTUwoYmFzZSwgZnJhZ21lbnQuY2hpbGROb2RlcywgcmVuYW1lLCBjb2VyY2UsIHNraXBUZXh0KTtcblxuICAgIGZ1bmN0aW9uIHNraXBUZXh0KG5vZGUpIHtcbiAgICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudDJqc29ubWwoZWwsIG9wdHMgPSB7IHJlbmFtZTogbnVsbCwgY29lcmNlOiBudWxsLCBiYXNlUHJvcHM6IG51bGwgfSkge1xuICAgIGNvbnN0IHJlbmFtZSA9IG9wdHMucmVuYW1lIHx8IGRlZmF1bHRSZW5hbWU7XG4gICAgY29uc3QgY29lcmNlID0gb3B0cy5jb2VyY2UgfHwgZGVmYXVsdENvZXJjZTtcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgICBjb25zdCBiYXNlID0gW2VsLmxvY2FsTmFtZSwgeyAuLi5iYXNlUHJvcHMsIC4uLmF0dHJzMnByb3BzKGVsLmF0dHJpYnV0ZXMsIHJlbmFtZSwgY29lcmNlLCBlbC5pc0Zyb20gfHwgZWwuY29uc3RydWN0b3IsIGVsLmxvY2FsTmFtZSkgfV07XG4gICAgLy9UT0RPIGFzc2lnbiBrZXlzXG5cbiAgICBmaWxsSW5KU09OTUwoYmFzZSwgZWwuY2hpbGROb2RlcywgcmVuYW1lLCBjb2VyY2UsIGRlZmF1bHRDaGlsZEZpbHRlcik7XG5cbiAgICByZXR1cm4gYmFzZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENoaWxkRmlsdGVyKG5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBmaWxsSW5KU09OTUwocGFyZW50LCBjaGlsZE5vZGVzLCByZW5hbWUsIGNvZXJjZSwgZmlsdGVyID0gZGVmYXVsdENoaWxkRmlsdGVyKSB7XG4gICAgZm9yKHZhciBpPTAsIGM7IGMgPSBjaGlsZE5vZGVzW2ldOyArK2kpIHtcbiAgICAgICAgLy8gVE9ETyB0dXJuIGV4cHJlc3Npb25zIGludG8gZnVuY3Rpb25zXG4gICAgICAgIGlmICghIGZpbHRlcihjKSkgY29udGludWU7XG5cbiAgICAgICAgc3dpdGNoKGMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IFtjLmxvY2FsTmFtZSwgYXR0cnMycHJvcHMoYy5hdHRyaWJ1dGVzLCByZW5hbWUsIGNvZXJjZSwgYy5pc0Zyb20gfHwgYy5jb25zdHJ1Y3RvciwgYy5sb2NhbE5hbWUpXTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgICBmaWxsSW5KU09OTUwoanNvbiwgYy5jaGlsZE5vZGVzLCByZW5hbWUsIGNvZXJjZSwgZGVmYXVsdENoaWxkRmlsdGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBwYXJlbnQucHVzaChjLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBpZ25vcmVpbmcgQ0RBVEEgJiBjb21tZW50cyBmb3Igbm93XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBmcmFnbWVudDJqc29ubWwgfSBmcm9tICcuLi9kb20vdGVtcGxhdGVkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvY2tUZW1wbGF0ZSB7XG5cbiAgICB1cGdyYWRlQ2FsbGJhY2soKSB7XG4gICAgICAgIC8vVE9ETyBzaG9ydGN1dCBrZXlzICgxLi45KVxuICAgICAgICB0aGlzLnRvcGljID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RvcGljJyk7XG5cbiAgICAgICAgaWYgKHRoaXMudG9waWMgJiYgdGhpcy5pZCkge1xuICAgICAgICAgICAgY2xlYW5CbG9jayh0aGlzLmNvbnRlbnQgfHwgdGhpcyk7XG4gICAgICAgICAgICAvLyBpbnRlcnByZXQgY29tbWVudHMgZm9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQganNvbm1sKCkge1xuICAgICAgICAvL1RPRE8gaW50ZXJwcmV0IGF0dHJpYnV0ZXMgdG8gbWFrZSB0aGUgb3V0cHV0IGF0dHJpYnV0ZXMuIGNsYXNzLCBpZCxcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gJ3RoZWlyIGxlZnQtdGhyZWFkJztcbiAgICAgICAgY29uc3QgYmFzZVByb3BzID0geyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmFtZShuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykgcmV0dXJuICdjbGFzc05hbWUnO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29lcmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NsYXNzTmFtZScpIHJldHVybiB2YWx1ZSArICcgJyArIGNsYXNzTmFtZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fanNvbm1sXG4gICAgICAgICAgICA/IHRoaXMuX2pzb25tbFxuICAgICAgICAgICAgOiAodGhpcy5fanNvbm1sID0gZnJhZ21lbnQyanNvbm1sKHRoaXMuY29udGVudCB8fCB0aGlzLCAnY29udmVyc2F0aW9uLWJsb2NrJywgdGhpcy5hdHRyaWJ1dGVzLCB7IHJlbmFtZSwgY29lcmNlLCBiYXNlUHJvcHMgfSkpO1xuICAgIH1cblxuICAgIHVwZ3JhZGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnRvcGljICYmIHRoaXMuaWQpIHtcbiAgICAgICAgICAgIGNsZWFuQmxvY2sodGhpcy5jb250ZW50IHx8IHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IEFycmF5LmZyb20oKHRoaXMuY29udGVudCB8fCB0aGlzKS5xdWVyeVNlbGVjdG9yQWxsKCcuc3RhdGVtZW50JykpO1xuICAgIH1cblxuICAgIHJlbmRlckpTT05NTChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc29ubWw7IC8vVE9ETyByZW5kZXJUZW1wbGF0ZSh0aGlzLmpzb25tbCwgc3RhdGUsIG1ldGEpXG4gICAgfVxuXG4gICAgaWRlbnRpZnkoKSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuaWQgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQtaWQnKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIHJldHVybiBpZDsgLy8gZmlsZWQgdW5kZXIgdGhpcyBJRFxuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5CbG9jayhlbGVtKSB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHBhcmFncmFwaHNcbiAgICAgICAgQXJyYXkuZnJvbShlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoJ3AnKSkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IGNoaWxkLnRleHRDb250ZW50LnJlcGxhY2UoL1xccy9nLCcnKTtcbiAgICAgICAgICAgIGlmICghdGV4dCAmJiBqdXN0V2hpdGVzcGFjZShjaGlsZC5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubG9jYWxOYW1lID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBtaWdodCBkbyBzb21ldGhpbmcgYWJvdXQgSFIsIHF1b3RlcywgRklFTERTRVRcblxuICAgICAgICBmdW5jdGlvbiBqdXN0V2hpdGVzcGFjZShjaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yKGxldCBpPTAsbD1jaGlsZHJlbi5sZW5ndGg7IGk8bDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKGNoaWxkcmVuW2ldLmxvY2FsTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YnInOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm9uLXdoaXRlc3BhY2UgY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiIsIi8vIGltcG9ydCByZWNvcmRWRG9tIGZyb20gJy4uL2RvbS9yZWNvcmRWRG9tJztcblxuLypcbiAgICBTdGF0ZW1lbnQgcGhhc2VzXG5cbiAgICAxLiBoaWRkZW4gKyBjbGFzcz1zdGF0ZW1lbnRcbiAgICAyLiBjbGFzcz1zdGF0ZW1lbnQgcGVuZGluZy1zdGF0ZW1lbnRcbiAgICAzLiBjbGFzcz1zdGF0ZW1lbnQgc2hvd24tc3RhdGVtZW50XG5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVtZW50IHtcblxuICAgIHN0YXRpYyBjbGFzc2VzV2hpbGVTaG93aW5nID0gWydzaG93aW5nLXN0YXRlbWVudCddO1xuICAgIHN0YXRpYyBjbGFzc2VzV2hpbGVQZW5kaW5nID0gWydwZW5kaW5nLXN0YXRlbWVudCddO1xuICAgIHN0YXRpYyB0aW1pbmcgPSB7IGRlbGF5QmV0d2VlbjogMS40LCBwZW5kaW5nUGVyaW9kOiAuNiB9O1xuXG4gICAgdXBncmFkZUNhbGxiYWNrKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3RhdGVtZW50Jyk7XG4gICAgICAgIC8vVE9ETyBwbGFuIHJlbmRlciB3aXRoIEpTT05NTCB0cmVlXG4gICAgICAgIC8vIHRoaXMucmVjb3JkaW5nID0gcmVjb3JkVkRvbSh0aGlzLCBleGNsdWRlVGhyZWFkQWN0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4Y2x1ZGVUaHJlYWRBY3Rpb24oZWwpIHtcbiAgICBsZXQgbm9kZU5hbWUgPSBlbC5sb2NhbE5hbWU7XG4gICAgcmV0dXJuIG5vZGVOYW1lICE9PSAndGhyZWFkLWFjdGlvbic7XG59XG4iLCIvKipcbipcbiogIFNlY3VyZSBIYXNoIEFsZ29yaXRobSAoU0hBMSlcblxuKiAgaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm8vXG5cbipcblxuKiovXG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBTSEExIChtc2cpIHtcblxuXG5cblxuICAgIGZ1bmN0aW9uIHJvdGF0ZV9sZWZ0KG4scykge1xuXG5cbiAgICAgICAgdmFyIHQ0ID0gKCBuPDxzICkgfCAobj4+PigzMi1zKSk7XG5cblxuICAgICAgICByZXR1cm4gdDQ7XG5cblxuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBsc2JfaGV4KHZhbCkge1xuXG5cbiAgICAgICAgdmFyIHN0cj1cIlwiO1xuXG5cbiAgICAgICAgdmFyIGk7XG5cblxuICAgICAgICB2YXIgdmg7XG5cblxuICAgICAgICB2YXIgdmw7XG5cblxuXG5cbiAgICAgICAgZm9yKCBpPTA7IGk8PTY7IGkrPTIgKSB7XG5cblxuICAgICAgICAgICAgdmggPSAodmFsPj4+KGkqNCs0KSkmMHgwZjtcblxuXG4gICAgICAgICAgICB2bCA9ICh2YWw+Pj4oaSo0KSkmMHgwZjtcblxuXG4gICAgICAgICAgICBzdHIgKz0gdmgudG9TdHJpbmcoMTYpICsgdmwudG9TdHJpbmcoMTYpO1xuXG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHN0cjtcblxuXG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIGN2dF9oZXgodmFsKSB7XG5cblxuICAgICAgICB2YXIgc3RyPVwiXCI7XG5cblxuICAgICAgICB2YXIgaTtcblxuXG4gICAgICAgIHZhciB2O1xuXG5cblxuXG4gICAgICAgIGZvciggaT03OyBpPj0wOyBpLS0gKSB7XG5cblxuICAgICAgICAgICAgdiA9ICh2YWw+Pj4oaSo0KSkmMHgwZjtcblxuXG4gICAgICAgICAgICBzdHIgKz0gdi50b1N0cmluZygxNik7XG5cblxuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gc3RyO1xuXG5cbiAgICB9O1xuXG5cblxuXG5cblxuICAgIGZ1bmN0aW9uIFV0ZjhFbmNvZGUoc3RyaW5nKSB7XG5cblxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxyXFxuL2csXCJcXG5cIik7XG5cblxuICAgICAgICB2YXIgdXRmdGV4dCA9IFwiXCI7XG5cblxuXG5cbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBzdHJpbmcubGVuZ3RoOyBuKyspIHtcblxuXG5cblxuICAgICAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcblxuXG5cblxuICAgICAgICAgICAgaWYgKGMgPCAxMjgpIHtcblxuXG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuXG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBlbHNlIGlmKChjID4gMTI3KSAmJiAoYyA8IDIwNDgpKSB7XG5cblxuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiA2KSB8IDE5Mik7XG5cblxuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XG5cblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGVsc2Uge1xuXG5cbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gMTIpIHwgMjI0KTtcblxuXG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCk7XG5cblxuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDYzKSB8IDEyOCk7XG5cblxuICAgICAgICAgICAgfVxuXG5cblxuXG4gICAgICAgIH1cblxuXG5cblxuICAgICAgICByZXR1cm4gdXRmdGV4dDtcblxuXG4gICAgfTtcblxuXG5cblxuICAgIHZhciBibG9ja3N0YXJ0O1xuXG5cbiAgICB2YXIgaSwgajtcblxuXG4gICAgdmFyIFcgPSBuZXcgQXJyYXkoODApO1xuXG5cbiAgICB2YXIgSDAgPSAweDY3NDUyMzAxO1xuXG5cbiAgICB2YXIgSDEgPSAweEVGQ0RBQjg5O1xuXG5cbiAgICB2YXIgSDIgPSAweDk4QkFEQ0ZFO1xuXG5cbiAgICB2YXIgSDMgPSAweDEwMzI1NDc2O1xuXG5cbiAgICB2YXIgSDQgPSAweEMzRDJFMUYwO1xuXG5cbiAgICB2YXIgQSwgQiwgQywgRCwgRTtcblxuXG4gICAgdmFyIHRlbXA7XG5cblxuXG5cbiAgICBtc2cgPSBVdGY4RW5jb2RlKG1zZyk7XG5cblxuXG5cbiAgICB2YXIgbXNnX2xlbiA9IG1zZy5sZW5ndGg7XG5cblxuXG5cbiAgICB2YXIgd29yZF9hcnJheSA9IG5ldyBBcnJheSgpO1xuXG5cbiAgICBmb3IoIGk9MDsgaTxtc2dfbGVuLTM7IGkrPTQgKSB7XG5cblxuICAgICAgICBqID0gbXNnLmNoYXJDb2RlQXQoaSk8PDI0IHwgbXNnLmNoYXJDb2RlQXQoaSsxKTw8MTYgfFxuXG5cbiAgICAgICAgbXNnLmNoYXJDb2RlQXQoaSsyKTw8OCB8IG1zZy5jaGFyQ29kZUF0KGkrMyk7XG5cblxuICAgICAgICB3b3JkX2FycmF5LnB1c2goIGogKTtcblxuXG4gICAgfVxuXG5cblxuXG4gICAgc3dpdGNoKCBtc2dfbGVuICUgNCApIHtcblxuXG4gICAgICAgIGNhc2UgMDpcblxuXG4gICAgICAgICAgICBpID0gMHgwODAwMDAwMDA7XG5cblxuICAgICAgICBicmVhaztcblxuXG4gICAgICAgIGNhc2UgMTpcblxuXG4gICAgICAgICAgICBpID0gbXNnLmNoYXJDb2RlQXQobXNnX2xlbi0xKTw8MjQgfCAweDA4MDAwMDA7XG5cblxuICAgICAgICBicmVhaztcblxuXG5cblxuICAgICAgICBjYXNlIDI6XG5cblxuICAgICAgICAgICAgaSA9IG1zZy5jaGFyQ29kZUF0KG1zZ19sZW4tMik8PDI0IHwgbXNnLmNoYXJDb2RlQXQobXNnX2xlbi0xKTw8MTYgfCAweDA4MDAwO1xuXG5cbiAgICAgICAgYnJlYWs7XG5cblxuXG5cbiAgICAgICAgY2FzZSAzOlxuXG5cbiAgICAgICAgICAgIGkgPSBtc2cuY2hhckNvZGVBdChtc2dfbGVuLTMpPDwyNCB8IG1zZy5jaGFyQ29kZUF0KG1zZ19sZW4tMik8PDE2IHwgbXNnLmNoYXJDb2RlQXQobXNnX2xlbi0xKTw8OCAgICB8IDB4ODA7XG5cblxuICAgICAgICBicmVhaztcblxuXG4gICAgfVxuXG5cblxuXG4gICAgd29yZF9hcnJheS5wdXNoKCBpICk7XG5cblxuXG5cbiAgICB3aGlsZSggKHdvcmRfYXJyYXkubGVuZ3RoICUgMTYpICE9IDE0ICkgd29yZF9hcnJheS5wdXNoKCAwICk7XG5cblxuXG5cbiAgICB3b3JkX2FycmF5LnB1c2goIG1zZ19sZW4+Pj4yOSApO1xuXG5cbiAgICB3b3JkX2FycmF5LnB1c2goIChtc2dfbGVuPDwzKSYweDBmZmZmZmZmZiApO1xuXG5cblxuXG5cblxuICAgIGZvciAoIGJsb2Nrc3RhcnQ9MDsgYmxvY2tzdGFydDx3b3JkX2FycmF5Lmxlbmd0aDsgYmxvY2tzdGFydCs9MTYgKSB7XG5cblxuXG5cbiAgICAgICAgZm9yKCBpPTA7IGk8MTY7IGkrKyApIFdbaV0gPSB3b3JkX2FycmF5W2Jsb2Nrc3RhcnQraV07XG5cblxuICAgICAgICBmb3IoIGk9MTY7IGk8PTc5OyBpKysgKSBXW2ldID0gcm90YXRlX2xlZnQoV1tpLTNdIF4gV1tpLThdIF4gV1tpLTE0XSBeIFdbaS0xNl0sIDEpO1xuXG5cblxuXG4gICAgICAgIEEgPSBIMDtcblxuXG4gICAgICAgIEIgPSBIMTtcblxuXG4gICAgICAgIEMgPSBIMjtcblxuXG4gICAgICAgIEQgPSBIMztcblxuXG4gICAgICAgIEUgPSBINDtcblxuXG5cblxuICAgICAgICBmb3IoIGk9IDA7IGk8PTE5OyBpKysgKSB7XG5cblxuICAgICAgICAgICAgdGVtcCA9IChyb3RhdGVfbGVmdChBLDUpICsgKChCJkMpIHwgKH5CJkQpKSArIEUgKyBXW2ldICsgMHg1QTgyNzk5OSkgJiAweDBmZmZmZmZmZjtcblxuXG4gICAgICAgICAgICBFID0gRDtcblxuXG4gICAgICAgICAgICBEID0gQztcblxuXG4gICAgICAgICAgICBDID0gcm90YXRlX2xlZnQoQiwzMCk7XG5cblxuICAgICAgICAgICAgQiA9IEE7XG5cblxuICAgICAgICAgICAgQSA9IHRlbXA7XG5cblxuICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgZm9yKCBpPTIwOyBpPD0zOTsgaSsrICkge1xuXG5cbiAgICAgICAgICAgIHRlbXAgPSAocm90YXRlX2xlZnQoQSw1KSArIChCIF4gQyBeIEQpICsgRSArIFdbaV0gKyAweDZFRDlFQkExKSAmIDB4MGZmZmZmZmZmO1xuXG5cbiAgICAgICAgICAgIEUgPSBEO1xuXG5cbiAgICAgICAgICAgIEQgPSBDO1xuXG5cbiAgICAgICAgICAgIEMgPSByb3RhdGVfbGVmdChCLDMwKTtcblxuXG4gICAgICAgICAgICBCID0gQTtcblxuXG4gICAgICAgICAgICBBID0gdGVtcDtcblxuXG4gICAgICAgIH1cblxuXG5cblxuICAgICAgICBmb3IoIGk9NDA7IGk8PTU5OyBpKysgKSB7XG5cblxuICAgICAgICAgICAgdGVtcCA9IChyb3RhdGVfbGVmdChBLDUpICsgKChCJkMpIHwgKEImRCkgfCAoQyZEKSkgKyBFICsgV1tpXSArIDB4OEYxQkJDREMpICYgMHgwZmZmZmZmZmY7XG5cblxuICAgICAgICAgICAgRSA9IEQ7XG5cblxuICAgICAgICAgICAgRCA9IEM7XG5cblxuICAgICAgICAgICAgQyA9IHJvdGF0ZV9sZWZ0KEIsMzApO1xuXG5cbiAgICAgICAgICAgIEIgPSBBO1xuXG5cbiAgICAgICAgICAgIEEgPSB0ZW1wO1xuXG5cbiAgICAgICAgfVxuXG5cblxuXG4gICAgICAgIGZvciggaT02MDsgaTw9Nzk7IGkrKyApIHtcblxuXG4gICAgICAgICAgICB0ZW1wID0gKHJvdGF0ZV9sZWZ0KEEsNSkgKyAoQiBeIEMgXiBEKSArIEUgKyBXW2ldICsgMHhDQTYyQzFENikgJiAweDBmZmZmZmZmZjtcblxuXG4gICAgICAgICAgICBFID0gRDtcblxuXG4gICAgICAgICAgICBEID0gQztcblxuXG4gICAgICAgICAgICBDID0gcm90YXRlX2xlZnQoQiwzMCk7XG5cblxuICAgICAgICAgICAgQiA9IEE7XG5cblxuICAgICAgICAgICAgQSA9IHRlbXA7XG5cblxuICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgSDAgPSAoSDAgKyBBKSAmIDB4MGZmZmZmZmZmO1xuXG5cbiAgICAgICAgSDEgPSAoSDEgKyBCKSAmIDB4MGZmZmZmZmZmO1xuXG5cbiAgICAgICAgSDIgPSAoSDIgKyBDKSAmIDB4MGZmZmZmZmZmO1xuXG5cbiAgICAgICAgSDMgPSAoSDMgKyBEKSAmIDB4MGZmZmZmZmZmO1xuXG5cbiAgICAgICAgSDQgPSAoSDQgKyBFKSAmIDB4MGZmZmZmZmZmO1xuXG5cblxuXG4gICAgfVxuXG5cblxuXG4gICAgdmFyIHRlbXAgPSBjdnRfaGV4KEgwKSArIGN2dF9oZXgoSDEpICsgY3Z0X2hleChIMikgKyBjdnRfaGV4KEgzKSArIGN2dF9oZXgoSDQpO1xuXG5cblxuXG4gICAgcmV0dXJuIHRlbXAudG9Mb3dlckNhc2UoKTtcblxuXG5cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBmaWVsZExpc3QoYWN0aW9uKSB7XG4gICAgY29uc3QgZmllbGRzID0gQXJyYXkuZnJvbShhY3Rpb24ucXVlcnlTZWxlY3RvckFsbChPYmplY3Qua2V5cyhGSUVMRFMpLmpvaW4oJywnKSkpO1xuXG4gICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLm5hbWUpIHtcbiAgICAgICAgICAgIGZpZWxkLnNldEF0dHJpYnV0ZSgnbmFtZScsbWFrZVVuaXF1ZU5hbWUoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG52YXIgdW5pcXVlTmFtZSA9IDE7XG5cbmZ1bmN0aW9uIG1ha2VVbmlxdWVOYW1lKCkge1xuICAgIHJldHVybiB1bmlxdWVOYW1lKys7XG59XG5cblxuZXhwb3J0IGNvbnN0IEZJRUxEUyA9IHtcbiAgICAnaW5wdXQnOiB7XG5cbiAgICB9LFxuXG4gICAgJ3NlbGVjdCc6IHtcblxuICAgIH0sXG5cbiAgICAndGV4dGFyZWEnOiB7XG5cbiAgICB9XG59O1xuIiwiLy8gaW1wb3J0IGhhc2hTdHJpbmcgZnJvbSAnLi4vZGF0YS9oYXNoU3RyaW5nJztcbmltcG9ydCB7IFNIQTEgfSBmcm9tICcuLi8uLi9kYXRhL3NoYTEnO1xuXG5pbXBvcnQge2VsZW1lbnQyanNvbm1sfSBmcm9tICcuLi8uLi9kb20vdGVtcGxhdGVkJztcblxuaW1wb3J0IGluY3JlbWVudGFsVGVtcGxhdGVzIGZyb20gJy4uLy4uL2RvbS9pbmNyZW1lbnRhbFRlbXBsYXRlcyc7XG5cbmltcG9ydCB7ZmllbGRMaXN0LCBGSUVMRFN9IGZyb20gJy4vaW5wdXRzJztcblxuLypcbiBjaG9pY2VSZXF1aXJlZCBmb3IgZWxlbWVudHMgYGlucHV0YCwgYHNlbGVjdGAsIGB0ZXh0YXJlYWAuXG4gKi9cbmZ1bmN0aW9uIGFubm90YXRlTWFya3VwKHN0YXRlKSB7XG5cbiAgICAvLyByZXBsYWNlcyBlbGVtZW50cyBmaWxsZWQgaW4gZm9yIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gZWxKU09OID0+IHtcblxuICAgICAgICAvLyB0ZXh0IG5vZGVcbiAgICAgICAgaWYgKHR5cGVvZiBlbEpTT04gPT09ICdzdHJpbmcnKSByZXR1cm4gZWxKU09OLnRyaW0oKTtcblxuICAgICAgICAvLyBpbnB1dC9zZWxlY3QvdGV4dGFyZWFcbiAgICAgICAgaWYgKEZJRUxEU1sgZWxKU09OWzBdIF0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbEpTT05bMV0ubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHN0YXRlKSByZXR1cm4gc3RhdGVbbmFtZV07XG5cbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBlbEpTT04ubWFwKHRyaW1FbnRyeSkuZmlsdGVyKGVudHJ5ID0+IGVudHJ5KTtcbiAgICAgICAgICAgIC8vVE9ETyBzZXQgZGVmYXVsdCB2YWx1ZVxuXG4gICAgICAgICAgICB0cmltbWVkLmNob2ljZVJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWxlbWVudHMgbWFya2VkIGhpbnQgYXJlIG5vdCBwYXJ0IG9mIHRoZSByZXN1bHRpbmcgdGV4dC5cbiAgICAgICAgLy8gVE9ETyBqc29udG1sLmhhc0F0dHJpYnV0ZShlbCkgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnaGludCcpKSByZXR1cm4gJyc7XG5cbiAgICAgICAgLy8gb3RoZXIgZWxlbWVudFxuICAgICAgICByZXR1cm4gZWxKU09OO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmltRW50cnkoZW50cnkpIHtcbiAgICAgICAgLy8gdGV4dCBub2RlXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSByZXR1cm4gZW50cnkucmVwbGFjZSgnXFxuJywnJykudHJpbSgpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNwb25zZVBhcnRzVG9UZW1wbGF0ZShwYXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnQ7XG5cbiAgICByZXR1cm4gJyMnICsgcGFydFsxXS5uYW1lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25UZW1wbGF0ZSB7XG4gICAgdXBncmFkZUNhbGxiYWNrKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ3RvcGljJykpIHRoaXMuc2V0QXR0cmlidXRlKCd0b3BpYycsdGVtcGxhdGUudG9waWMpO1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlLmFjdGlvbnMgPT0gdW5kZWZpbmVkKSB0ZW1wbGF0ZS5hY3Rpb25zID0gW107XG4gICAgICAgIHRlbXBsYXRlLmFjdGlvbnMucHVzaCh0aGlzKTtcblxuICAgICAgICB0aGlzLmZpZWxkTmFtZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZmllbGRzID0ge307XG4gICAgICAgIGZpZWxkTGlzdCh0aGlzKS5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmllbGROYW1lcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkLm5hbWVdID0gZmllbGQ7XG4gICAgICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcblxuICAgICAgICAgICAgY29uc3QgdXBncmFkZUJ5VHlwZSA9IHRoaXNbJ3VwZ3JhZGUgJyArIGZpZWxkLmxvY2FsTmFtZV07XG4gICAgICAgICAgICBpZiAodXBncmFkZUJ5VHlwZSkgdXBncmFkZUJ5VHlwZS5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgY2FuIGJlIHJlbmRlcmVkIGVhc2lseSB3aXRoIHJlY29yZGluZ1xuICAgICAgICAvLyB0aGlzLnJlY29yZGluZyA9IHJlY29yZEluY3JlbWVudGFsRG9tKHRoaXMpO1xuXG4gICAgICAgIC8vIEpTT05NTCByZXBsYWNlcyByZWNvcmRpbmdcbiAgICAgICAgdGhpcy5wYXJ0c0xpc3QgPSBlbGVtZW50Mmpzb25tbCh0aGlzKS5zbGljZSgyKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZVRlbXBsYXRlID0gdGhpcy5wYXJ0c0xpc3QubWFwKHJlc3BvbnNlUGFydHNUb1RlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZVRlbXBsYXRlLnJlbmRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAocGFydCA9PiBwYXJ0LmNoYXJBdCgwKSA9PT0gJyMnID8gc3RhdGVbcGFydC5zdWJzdHJpbmcoMSldIDogcGFydCkuam9pbignJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgJ3VwZ3JhZGUgc2VsZWN0JyhzZWxlY3QpIHtcbiAgICAgICAgc3dpdGNoKHNlbGVjdC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgICAgICAgY2FzZSAndGltZWxpbmUnOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc3QgYmxhbmtPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgICAgICBibGFua09wdGlvbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGJsYW5rT3B0aW9uLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgc2VsZWN0Lmluc2VydEJlZm9yZShibGFua09wdGlvbiwgc2VsZWN0LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICAgICAgICBzZWxlY3QudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBAcGFyYW0gc3RhdGUgVGhlIGNvbmZsdXggc3RhdGUgZm9yIHRoZSBibG9jayAqL1xuICAgIHBhcnRpYWxseUZpbGxlZENvbnRlbnQoc3RhdGUpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnBhcnRzTGlzdC5tYXAoYW5ub3RhdGVNYXJrdXAoc3RhdGUpKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQpO1xuICAgICAgICBmb3IodmFyIGkgPSAwLCBlbnRyeTsgZW50cnkgPSBjb250ZW50W2ldOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5jaG9pY2VSZXF1aXJlZCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudC5zdGF0aWNMZW5ndGggPSBpO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICBpZGVudGlmeSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBpZiAoaWQpIHJldHVybiB0ZW1wbGF0ZS50ZW1wbGF0ZUlkICsgJzonICsgaWQ7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5uZXJIVE1MICsgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gbWFrZSBzaGEgaGFzaFxuICAgICAgICAgICAgcmV0dXJuIFNIQTEodGhpcy5pbm5lckhUTUwgKyB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpLCAnU0hBLTI1NicpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSZW5kZXJQcm9wcyhyZXNwb25zZVByb3BzLCBibG9jaykge1xuICAgICAgICAvL1RPRE8gYmxlbmQgaW4gU3RhdGUgZm9yIHRoZSBpbnB1dHMgYnkgbmFtZSAoc3RhdGVbYWN0aW9uIGlucHV0IG5hbWVdKVxuICAgICAgICBjb25zdCBpbnB1dHMgPSB0aGlzLnBhcnRzTGlzdC5tYXAoZGVzY3JpYmVJbnB1dChyZXNwb25zZVByb3BzLCBibG9jaykpLmZpbHRlcigocGFydCkgPT4gcGFydCk7XG5cbiAgICAgICAgLy9UT0RPIHNjYW4gaW5wdXRzIHRvIHNlZSBpZiBwYXN0IHRoZSBwcmVyb2xsIGlucHV0c1xuICAgICAgICAvLyBjb25zdCBlbmFibGVNZXNzYWdlID0gaW5wdXRzLnJlZHVjZSgocmVzdWx0LCBpbnB1dCkgPT4gaW5wdXQudHlwZSA9PT0gJ21lc3NhZ2UnID8geyBpbnB1dCwgYWN0aW9uSWQ6IHRoaXMudGVtcGxhdGVJZCB9IDogZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgZW5hYmxlTWVzc2FnZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdtZXNzYWdlJyA/IHtcbiAgICAgICAgICAgIGFjdGlvbklkOiB0aGlzLnRlbXBsYXRlSWQsXG4gICAgICAgIH0gOiBmYWxzZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGVtcGxhdGVJZDogdGhpcy50ZW1wbGF0ZUlkLFxuICAgICAgICAgICAgYmV0YTogdGhpcy5oYXNBdHRyaWJ1dGUoJ2JldGEnKSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICBuZXh0QmxvY2tJZDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Jsb2NrJyksXG4gICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3RvcGljJykgfHwgcmVzcG9uc2VQcm9wcz8gcmVzcG9uc2VQcm9wcy50b3BpYzonJyxcbiAgICAgICAgICAgIGVuYWJsZU1lc3NhZ2UsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBmdWxsOiByZXNwb25zZVByb3BzLmFjdGlvbnNJZCA9PT0gYmxvY2sudGVtcGxhdGVJZCxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuaW5uZXJUZXh0LFxuXG4gICAgICAgICAgICBsb2dFdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdjbGljaycsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFuZ2VFdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdjaGFuZ2UnLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVJbnB1dChwcm9wcywgc3RhdGUpIHtcbiAgICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgICAgIC8vIHRleHQgbm9kZVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgcmV0dXJuIHRyaW1FbnRyeShpbnB1dCk7XG5cbiAgICAgICAgLy8gZWxlbWVudFxuICAgICAgICBpZiAoRklFTERTWyBpbnB1dFswXSBdKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gaW5wdXRbMV0ubmFtZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVbbmFtZV0sXG4gICAgICAgICAgICAgICAgdGFnOiBpbnB1dFswXSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBpbnB1dFsxXSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogaW5wdXQuc2xpY2UoMiwxMDApLm1hcCh0cmltRW50cnkpLmZpbHRlcihpbnB1dCA9PiBpbnB1dCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmltRW50cnkoZW50cnkpIHtcbiAgICAgICAgLy8gdGV4dCBub2RlXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSByZXR1cm4gZW50cnkucmVwbGFjZSgnXFxuJywnJykudHJpbSgpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxufVxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJuby1TaGFyZWRcclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxudmFyIE5PX09QID0gXCIkTk9fT1BcIjtcclxudmFyIEVSUk9SX01TRyA9IFwiYSBydW50aW1lIGVycm9yIG9jY3VyZWQhIFVzZSBJbmZlcm5vIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50IHRvIGZpbmQgdGhlIGVycm9yLlwiO1xyXG4vLyBUaGlzIHNob3VsZCBiZSBib29sZWFuIGFuZCBub3QgcmVmZXJlbmNlIHRvIHdpbmRvdy5kb2N1bWVudFxyXG52YXIgaXNCcm93c2VyID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQpO1xyXG4vLyB0aGlzIGlzIE1VQ0ggZmFzdGVyIHRoYW4gLmNvbnN0cnVjdG9yID09PSBBcnJheSBhbmQgaW5zdGFuY2VvZiBBcnJheVxyXG4vLyBpbiBOb2RlIDcgYW5kIHRoZSBsYXRlciB2ZXJzaW9ucyBvZiBWOCwgc2xvd2VyIGluIG9sZGVyIHZlcnNpb25zIHRob3VnaFxyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQobykge1xyXG4gICAgcmV0dXJuICFpc1VuZGVmaW5lZChvLnByb3RvdHlwZSkgJiYgIWlzVW5kZWZpbmVkKG8ucHJvdG90eXBlLnJlbmRlcik7XHJcbn1cclxuZnVuY3Rpb24gaXNTdHJpbmdPck51bWJlcihvKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvO1xyXG4gICAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIjtcclxufVxyXG5mdW5jdGlvbiBpc051bGxPclVuZGVmKG8pIHtcclxuICAgIHJldHVybiBpc1VuZGVmaW5lZChvKSB8fCBpc051bGwobyk7XHJcbn1cclxuZnVuY3Rpb24gaXNJbnZhbGlkKG8pIHtcclxuICAgIHJldHVybiBpc051bGwobykgfHwgbyA9PT0gZmFsc2UgfHwgaXNUcnVlKG8pIHx8IGlzVW5kZWZpbmVkKG8pO1xyXG59XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24obykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuZnVuY3Rpb24gaXNTdHJpbmcobykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSBcInN0cmluZ1wiO1xyXG59XHJcbmZ1bmN0aW9uIGlzTnVtYmVyKG8pIHtcclxuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIjtcclxufVxyXG5mdW5jdGlvbiBpc051bGwobykge1xyXG4gICAgcmV0dXJuIG8gPT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNUcnVlKG8pIHtcclxuICAgIHJldHVybiBvID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcclxuICAgIHJldHVybiBvID09PSB2b2lkIDA7XHJcbn1cclxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm9iamVjdFwiO1xyXG59XHJcbmZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSkge1xyXG4gICAgaWYgKCFtZXNzYWdlKSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IEVSUk9SX01TRztcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcigoXCJJbmZlcm5vIEVycm9yOiBcIiArIG1lc3NhZ2UpKTtcclxufVxyXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXHJcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XHJcbn1cclxuZnVuY3Rpb24gY29tYmluZUZyb20oZmlyc3QsIHNlY29uZCkge1xyXG4gICAgdmFyIG91dCA9IHt9O1xyXG4gICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGZpcnN0KSB7XHJcbiAgICAgICAgICAgIG91dFtrZXldID0gZmlyc3Rba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2Vjb25kKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5JDEgaW4gc2Vjb25kKSB7XHJcbiAgICAgICAgICAgIG91dFtrZXkkMV0gPSBzZWNvbmRba2V5JDFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn1cclxuZnVuY3Rpb24gTGlmZWN5Y2xlKCkge1xyXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcclxufVxyXG5MaWZlY3ljbGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoY2FsbGJhY2spIHtcclxuICAgIHRoaXMubGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xyXG59O1xyXG5MaWZlY3ljbGUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xyXG4gICAgdmFyIGxpc3RlbmVyO1xyXG4gICAgLy8gV2UgbmVlZCB0byByZW1vdmUgY3VycmVudCBsaXN0ZW5lciBmcm9tIGFycmF5IHdoZW4gY2FsbGluZyBpdCwgYmVjYXVzZSBtb3JlIGxpc3RlbmVycyBtaWdodCBiZSBhZGRlZFxyXG4gICAgd2hpbGUgKChsaXN0ZW5lciA9IGxpc3RlbmVycy5zaGlmdCgpKSkge1xyXG4gICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICB9XHJcbn07XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm9cclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxudmFyIG9wdGlvbnMgPSB7XHJcbiAgICBhZnRlck1vdW50OiBudWxsLFxyXG4gICAgYWZ0ZXJSZW5kZXI6IG51bGwsXHJcbiAgICBhZnRlclVwZGF0ZTogbnVsbCxcclxuICAgIGJlZm9yZVJlbmRlcjogbnVsbCxcclxuICAgIGJlZm9yZVVubW91bnQ6IG51bGwsXHJcbiAgICBjcmVhdGVWTm9kZTogbnVsbCxcclxuICAgIGZpbmRET01Ob2RlRW5hYmxlZDogZmFsc2UsXHJcbiAgICByZWN5Y2xpbmdFbmFibGVkOiBmYWxzZSxcclxuICAgIHJvb3RzOiBbXVxyXG59O1xuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbnZhciB4bGlua05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XHJcbnZhciB4bWxOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCI7XHJcbnZhciBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcclxudmFyIHN0cmljdFByb3BzID0gbmV3IFNldCgpO1xyXG5zdHJpY3RQcm9wcy5hZGQoXCJ2b2x1bWVcIik7XHJcbnN0cmljdFByb3BzLmFkZChcImRlZmF1bHRDaGVja2VkXCIpO1xyXG52YXIgYm9vbGVhblByb3BzID0gbmV3IFNldCgpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwibXV0ZWRcIik7XHJcbmJvb2xlYW5Qcm9wcy5hZGQoXCJzY29wZWRcIik7XHJcbmJvb2xlYW5Qcm9wcy5hZGQoXCJsb29wXCIpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwib3BlblwiKTtcclxuYm9vbGVhblByb3BzLmFkZChcImNoZWNrZWRcIik7XHJcbmJvb2xlYW5Qcm9wcy5hZGQoXCJkZWZhdWx0XCIpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwiY2FwdHVyZVwiKTtcclxuYm9vbGVhblByb3BzLmFkZChcImRpc2FibGVkXCIpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwicmVhZE9ubHlcIik7XHJcbmJvb2xlYW5Qcm9wcy5hZGQoXCJyZXF1aXJlZFwiKTtcclxuYm9vbGVhblByb3BzLmFkZChcImF1dG9wbGF5XCIpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwiY29udHJvbHNcIik7XHJcbmJvb2xlYW5Qcm9wcy5hZGQoXCJzZWFtbGVzc1wiKTtcclxuYm9vbGVhblByb3BzLmFkZChcInJldmVyc2VkXCIpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwiYWxsb3dmdWxsc2NyZWVuXCIpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwibm92YWxpZGF0ZVwiKTtcclxuYm9vbGVhblByb3BzLmFkZChcImhpZGRlblwiKTtcclxuYm9vbGVhblByb3BzLmFkZChcImF1dG9Gb2N1c1wiKTtcclxuYm9vbGVhblByb3BzLmFkZChcInNlbGVjdGVkXCIpO1xyXG5ib29sZWFuUHJvcHMuYWRkKFwiaW5kZXRlcm1pbmF0ZVwiKTtcclxudmFyIG5hbWVzcGFjZXMgPSBuZXcgTWFwKCk7XHJcbm5hbWVzcGFjZXMuc2V0KFwieGxpbms6aHJlZlwiLCB4bGlua05TKTtcclxubmFtZXNwYWNlcy5zZXQoXCJ4bGluazphcmNyb2xlXCIsIHhsaW5rTlMpO1xyXG5uYW1lc3BhY2VzLnNldChcInhsaW5rOmFjdHVhdGVcIiwgeGxpbmtOUyk7XHJcbm5hbWVzcGFjZXMuc2V0KFwieGxpbms6c2hvd1wiLCB4bGlua05TKTtcclxubmFtZXNwYWNlcy5zZXQoXCJ4bGluazpyb2xlXCIsIHhsaW5rTlMpO1xyXG5uYW1lc3BhY2VzLnNldChcInhsaW5rOnRpdGxlXCIsIHhsaW5rTlMpO1xyXG5uYW1lc3BhY2VzLnNldChcInhsaW5rOnR5cGVcIiwgeGxpbmtOUyk7XHJcbm5hbWVzcGFjZXMuc2V0KFwieG1sOmJhc2VcIiwgeG1sTlMpO1xyXG5uYW1lc3BhY2VzLnNldChcInhtbDpsYW5nXCIsIHhtbE5TKTtcclxubmFtZXNwYWNlcy5zZXQoXCJ4bWw6c3BhY2VcIiwgeG1sTlMpO1xyXG52YXIgaXNVbml0bGVzc051bWJlciA9IG5ldyBTZXQoKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJib3JkZXJJbWFnZU91dHNldFwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJib3JkZXJJbWFnZVNsaWNlXCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcImJvcmRlckltYWdlV2lkdGhcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiYm94RmxleFwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJib3hGbGV4R3JvdXBcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiYm94T3JkaW5hbEdyb3VwXCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcImNvbHVtbkNvdW50XCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcImZsZXhcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiZmxleEdyb3dcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiZmxleFBvc2l0aXZlXCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcImZsZXhTaHJpbmtcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiZmxleE5lZ2F0aXZlXCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcImZsZXhPcmRlclwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJncmlkUm93XCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcImdyaWRDb2x1bW5cIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiZm9udFdlaWdodFwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJsaW5lQ2xhbXBcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwibGluZUhlaWdodFwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJvcGFjaXR5XCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcIm9yZGVyXCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcIm9ycGhhbnNcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwidGFiU2l6ZVwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJ3aWRvd3NcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiekluZGV4XCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcInpvb21cIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiZmlsbE9wYWNpdHlcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwiZmxvb2RPcGFjaXR5XCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcInN0b3BPcGFjaXR5XCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcInN0cm9rZURhc2hhcnJheVwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJzdHJva2VEYXNob2Zmc2V0XCIpO1xyXG5pc1VuaXRsZXNzTnVtYmVyLmFkZChcInN0cm9rZU1pdGVybGltaXRcIik7XHJcbmlzVW5pdGxlc3NOdW1iZXIuYWRkKFwic3Ryb2tlT3BhY2l0eVwiKTtcclxuaXNVbml0bGVzc051bWJlci5hZGQoXCJzdHJva2VXaWR0aFwiKTtcclxudmFyIHNraXBQcm9wcyA9IG5ldyBTZXQoKTtcclxuc2tpcFByb3BzLmFkZChcImNoaWxkcmVuXCIpO1xyXG5za2lwUHJvcHMuYWRkKFwiY2hpbGRyZW5UeXBlXCIpO1xyXG5za2lwUHJvcHMuYWRkKFwiZGVmYXVsdFZhbHVlXCIpO1xyXG5za2lwUHJvcHMuYWRkKFwicmVmXCIpO1xyXG5za2lwUHJvcHMuYWRkKFwia2V5XCIpO1xyXG5za2lwUHJvcHMuYWRkKFwiY2hlY2tlZFwiKTtcclxuc2tpcFByb3BzLmFkZChcIm11bHRpcGxlXCIpO1xyXG52YXIgZGVsZWdhdGVkRXZlbnRzID0gbmV3IFNldCgpO1xyXG5kZWxlZ2F0ZWRFdmVudHMuYWRkKFwib25DbGlja1wiKTtcclxuZGVsZWdhdGVkRXZlbnRzLmFkZChcIm9uTW91c2VEb3duXCIpO1xyXG5kZWxlZ2F0ZWRFdmVudHMuYWRkKFwib25Nb3VzZVVwXCIpO1xyXG5kZWxlZ2F0ZWRFdmVudHMuYWRkKFwib25Nb3VzZU1vdmVcIik7XHJcbmRlbGVnYXRlZEV2ZW50cy5hZGQoXCJvblN1Ym1pdFwiKTtcclxuZGVsZWdhdGVkRXZlbnRzLmFkZChcIm9uRGJsQ2xpY2tcIik7XHJcbmRlbGVnYXRlZEV2ZW50cy5hZGQoXCJvbktleURvd25cIik7XHJcbmRlbGVnYXRlZEV2ZW50cy5hZGQoXCJvbktleVVwXCIpO1xyXG5kZWxlZ2F0ZWRFdmVudHMuYWRkKFwib25LZXlQcmVzc1wiKTtcblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJub1xyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG52YXIgaXNpT1MgPSBpc0Jyb3dzZXIgJiZcclxuICAgICEhbmF2aWdhdG9yLnBsYXRmb3JtICYmXHJcbiAgICAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xyXG52YXIgZGVsZWdhdGVkRXZlbnRzJDEgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG5hbWUsIGxhc3RFdmVudCwgbmV4dEV2ZW50LCBkb20pIHtcclxuICAgIHZhciBkZWxlZ2F0ZWRSb290cyA9IGRlbGVnYXRlZEV2ZW50cyQxLmdldChuYW1lKTtcclxuICAgIGlmIChuZXh0RXZlbnQpIHtcclxuICAgICAgICBpZiAoIWRlbGVnYXRlZFJvb3RzKSB7XHJcbiAgICAgICAgICAgIGRlbGVnYXRlZFJvb3RzID0geyBpdGVtczogbmV3IE1hcCgpLCBkb2NFdmVudDogbnVsbCB9O1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZWRSb290cy5kb2NFdmVudCA9IGF0dGFjaEV2ZW50VG9Eb2N1bWVudChuYW1lLCBkZWxlZ2F0ZWRSb290cyk7XHJcbiAgICAgICAgICAgIGRlbGVnYXRlZEV2ZW50cyQxLnNldChuYW1lLCBkZWxlZ2F0ZWRSb290cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGFzdEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChpc2lPUyAmJiBuYW1lID09PSBcIm9uQ2xpY2tcIikge1xyXG4gICAgICAgICAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxlZ2F0ZWRSb290cy5pdGVtcy5zZXQoZG9tLCBuZXh0RXZlbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGVsZWdhdGVkUm9vdHMpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSBkZWxlZ2F0ZWRSb290cy5pdGVtcztcclxuICAgICAgICBpZiAoaXRlbXMuZGVsZXRlKGRvbSkpIHtcclxuICAgICAgICAgICAgLy8gSWYgYW55IGl0ZW1zIHdlcmUgZGVsZXRlZCwgY2hlY2sgaWYgbGlzdGVuZXIgbmVlZCB0byBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgIGlmIChpdGVtcy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG5vcm1hbGl6ZUV2ZW50TmFtZShuYW1lKSwgZGVsZWdhdGVkUm9vdHMuZG9jRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVkRXZlbnRzJDEuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRzKGV2ZW50LCB0YXJnZXQsIGl0ZW1zLCBjb3VudCwgaXNDbGljaywgZXZlbnREYXRhKSB7XHJcbiAgICB2YXIgZG9tID0gdGFyZ2V0O1xyXG4gICAgd2hpbGUgKGNvdW50ID4gMCkge1xyXG4gICAgICAgIHZhciBldmVudHNUb1RyaWdnZXIgPSBpdGVtcy5nZXQoZG9tKTtcclxuICAgICAgICBpZiAoZXZlbnRzVG9UcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIGNvdW50LS07XHJcbiAgICAgICAgICAgIC8vIGxpbmtFdmVudCBvYmplY3RcclxuICAgICAgICAgICAgZXZlbnREYXRhLmRvbSA9IGRvbTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50c1RvVHJpZ2dlci5ldmVudCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzVG9UcmlnZ2VyLmV2ZW50KGV2ZW50c1RvVHJpZ2dlci5kYXRhLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHNUb1RyaWdnZXIoZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWxCdWJibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcclxuICAgICAgICAvLyBIdG1sIE5vZGVzIGNhbiBiZSBuZXN0ZWQgZmU6IHNwYW4gaW5zaWRlIGJ1dHRvbiBpbiB0aGF0IHNjZW5hcmlvIGJyb3dzZXIgZG9lcyBub3QgaGFuZGxlIGRpc2FibGVkIGF0dHJpYnV0ZSBvbiBwYXJlbnQsXHJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZXZlbnQgbGlzdGVuZXIgaXMgb24gZG9jdW1lbnQuYm9keVxyXG4gICAgICAgIC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzXHJcbiAgICAgICAgaWYgKGRvbSA9PT0gbnVsbCB8fCAoaXNDbGljayAmJiBkb20uZGlzYWJsZWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnROYW1lKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lLnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcclxuICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgIHRoaXMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbn1cclxuZnVuY3Rpb24gYXR0YWNoRXZlbnRUb0RvY3VtZW50KG5hbWUsIGRlbGVnYXRlZFJvb3RzKSB7XHJcbiAgICB2YXIgZG9jRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgY291bnQgPSBkZWxlZ2F0ZWRSb290cy5pdGVtcy5zaXplO1xyXG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFByb3BhZ2F0aW9uO1xyXG4gICAgICAgICAgICAvLyBFdmVudCBkYXRhIG5lZWRzIHRvIGJlIG9iamVjdCB0byBzYXZlIHJlZmVyZW5jZSB0byBjdXJyZW50VGFyZ2V0IGdldHRlclxyXG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgZG9tOiBkb2N1bWVudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGF0YS5kb207XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8qIHNhZmFyaTcgYW5kIHBoYW50b21KUyB3aWxsIGNyYXNoICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudHMoZXZlbnQsIGV2ZW50LnRhcmdldCwgZGVsZWdhdGVkUm9vdHMuaXRlbXMsIGNvdW50LCBldmVudC50eXBlID09PSBcImNsaWNrXCIsIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobm9ybWFsaXplRXZlbnROYW1lKG5hbWUpLCBkb2NFdmVudCk7XHJcbiAgICByZXR1cm4gZG9jRXZlbnQ7XHJcbn1cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5XHJcbmZ1bmN0aW9uIGVtcHR5Rm4oKSB7IH1cclxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tKSB7XHJcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxyXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxyXG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xyXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxyXG4gICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcclxuICAgIC8vIEp1c3Qgc2V0IGl0IHVzaW5nIHRoZSBvbmNsaWNrIHByb3BlcnR5IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBtYW5hZ2UgYW55XHJcbiAgICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcclxuICAgIC8vIHJlbW92ZWQuXHJcbiAgICAvLyBUT0RPOiBPbmx5IGRvIHRoaXMgZm9yIHRoZSByZWxldmFudCBTYWZhcmlzIG1heWJlP1xyXG4gICAgZG9tLm9uY2xpY2sgPSBlbXB0eUZuO1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm9cclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuZnVuY3Rpb24gaXNDaGVja2VkVHlwZSh0eXBlKSB7XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHR5cGUgPT09IFwicmFkaW9cIjtcclxufVxyXG5mdW5jdGlvbiBvblRleHRJbnB1dENoYW5nZShlKSB7XHJcbiAgICB2YXIgdk5vZGUgPSB0aGlzLnZOb2RlO1xyXG4gICAgdmFyIHByb3BzID0gdk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgdmFyIGRvbSA9IHZOb2RlLmRvbTtcclxuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJvcHMudmFsdWU7XHJcbiAgICBpZiAocHJvcHMub25JbnB1dCkge1xyXG4gICAgICAgIHZhciBldmVudCA9IHByb3BzLm9uSW5wdXQ7XHJcbiAgICAgICAgaWYgKGV2ZW50LmV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LmV2ZW50KGV2ZW50LmRhdGEsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnQoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMub25pbnB1dCkge1xyXG4gICAgICAgIHByb3BzLm9uaW5wdXQoZSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgdXNlciBtYXkgaGF2ZSB1cGRhdGVkIHRoZSB2Tm9kZSBmcm9tIHRoZSBhYm92ZSBvbklucHV0IGV2ZW50cyBzeW5jcm9ub3VzbHlcclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gZ2V0IGl0IGZyb20gdGhlIGNvbnRleHQgb2YgYHRoaXNgIGFnYWluXHJcbiAgICB2YXIgbmV3Vk5vZGUgPSB0aGlzLnZOb2RlO1xyXG4gICAgdmFyIG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgLy8gSWYgcmVuZGVyIGlzIGdvaW5nIGFzeW5jIHRoZXJlIGlzIG5vIHZhbHVlIGNoYW5nZSB5ZXQsIGl0IHdpbGwgY29tZSBiYWNrIHRvIHByb2Nlc3MgaW5wdXQgc29vblxyXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IG5ld1Byb3BzLnZhbHVlKSB7XHJcbiAgICAgICAgLy8gV2hlbiB0aGlzIGhhcHBlbnMgd2UgbmVlZCB0byBzdG9yZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvbiBhbmQgcmVzdG9yZSBpdCwgdG8gYXZvaWQganVtcGluZ1xyXG4gICAgICAgIGFwcGx5VmFsdWUobmV3UHJvcHMsIGRvbSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gd3JhcHBlZE9uQ2hhbmdlKGUpIHtcclxuICAgIHZhciBwcm9wcyA9IHRoaXMudk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgdmFyIGV2ZW50ID0gcHJvcHMub25DaGFuZ2U7XHJcbiAgICBpZiAoZXZlbnQuZXZlbnQpIHtcclxuICAgICAgICBldmVudC5ldmVudChldmVudC5kYXRhLCBlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50KGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG9uQ2hlY2tib3hDaGFuZ2UoZSkge1xyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gVGhpcyBjbGljayBzaG91bGQgbm90IHByb3BhZ2F0ZSBpdHMgZm9yIGludGVybmFsIHVzZVxyXG4gICAgdmFyIHZOb2RlID0gdGhpcy52Tm9kZTtcclxuICAgIHZhciBwcm9wcyA9IHZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIHZhciBkb20gPSB2Tm9kZS5kb207XHJcbiAgICBpZiAocHJvcHMub25DbGljaykge1xyXG4gICAgICAgIHZhciBldmVudCA9IHByb3BzLm9uQ2xpY2s7XHJcbiAgICAgICAgaWYgKGV2ZW50LmV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LmV2ZW50KGV2ZW50LmRhdGEsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnQoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMub25jbGljaykge1xyXG4gICAgICAgIHByb3BzLm9uY2xpY2soZSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgdXNlciBtYXkgaGF2ZSB1cGRhdGVkIHRoZSB2Tm9kZSBmcm9tIHRoZSBhYm92ZSBvbklucHV0IGV2ZW50cyBzeW5jcm9ub3VzbHlcclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gZ2V0IGl0IGZyb20gdGhlIGNvbnRleHQgb2YgYHRoaXNgIGFnYWluXHJcbiAgICB2YXIgbmV3Vk5vZGUgPSB0aGlzLnZOb2RlO1xyXG4gICAgdmFyIG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgLy8gSWYgcmVuZGVyIGlzIGdvaW5nIGFzeW5jIHRoZXJlIGlzIG5vIHZhbHVlIGNoYW5nZSB5ZXQsIGl0IHdpbGwgY29tZSBiYWNrIHRvIHByb2Nlc3MgaW5wdXQgc29vblxyXG4gICAgYXBwbHlWYWx1ZShuZXdQcm9wcywgZG9tKTtcclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzSW5wdXQodk5vZGUsIGRvbSwgbmV4dFByb3BzT3JFbXB0eSwgbW91bnRpbmcsIGlzQ29udHJvbGxlZCkge1xyXG4gICAgYXBwbHlWYWx1ZShuZXh0UHJvcHNPckVtcHR5LCBkb20pO1xyXG4gICAgaWYgKGlzQ29udHJvbGxlZCkge1xyXG4gICAgICAgIGRvbS52Tm9kZSA9IHZOb2RlOyAvLyBUT0RPOiBSZW1vdmUgdGhpcyB3aGVuIGltcGxlbWVudGluZyBGaWJlcidzXHJcbiAgICAgICAgaWYgKG1vdW50aW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NoZWNrZWRUeXBlKG5leHRQcm9wc09yRW1wdHkudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGRvbS5vbmNsaWNrID0gb25DaGVja2JveENoYW5nZTtcclxuICAgICAgICAgICAgICAgIGRvbS5vbmNsaWNrLndyYXBwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9tLm9uaW5wdXQgPSBvblRleHRJbnB1dENoYW5nZTtcclxuICAgICAgICAgICAgICAgIGRvbS5vbmlucHV0LndyYXBwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcHNPckVtcHR5Lm9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBkb20ub25jaGFuZ2UgPSB3cmFwcGVkT25DaGFuZ2U7XHJcbiAgICAgICAgICAgICAgICBkb20ub25jaGFuZ2Uud3JhcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlWYWx1ZShuZXh0UHJvcHNPckVtcHR5LCBkb20pIHtcclxuICAgIHZhciB0eXBlID0gbmV4dFByb3BzT3JFbXB0eS50eXBlO1xyXG4gICAgdmFyIHZhbHVlID0gbmV4dFByb3BzT3JFbXB0eS52YWx1ZTtcclxuICAgIHZhciBjaGVja2VkID0gbmV4dFByb3BzT3JFbXB0eS5jaGVja2VkO1xyXG4gICAgdmFyIG11bHRpcGxlID0gbmV4dFByb3BzT3JFbXB0eS5tdWx0aXBsZTtcclxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBuZXh0UHJvcHNPckVtcHR5LmRlZmF1bHRWYWx1ZTtcclxuICAgIHZhciBoYXNWYWx1ZSA9ICFpc051bGxPclVuZGVmKHZhbHVlKTtcclxuICAgIGlmICh0eXBlICYmIHR5cGUgIT09IGRvbS50eXBlKSB7XHJcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobXVsdGlwbGUgJiYgbXVsdGlwbGUgIT09IGRvbS5tdWx0aXBsZSkge1xyXG4gICAgICAgIGRvbS5tdWx0aXBsZSA9IG11bHRpcGxlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc051bGxPclVuZGVmKGRlZmF1bHRWYWx1ZSkgJiYgIWhhc1ZhbHVlKSB7XHJcbiAgICAgICAgZG9tLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZSArIFwiXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNDaGVja2VkVHlwZSh0eXBlKSkge1xyXG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xyXG4gICAgICAgICAgICBkb20udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKGNoZWNrZWQpKSB7XHJcbiAgICAgICAgICAgIGRvbS5jaGVja2VkID0gY2hlY2tlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaGFzVmFsdWUgJiYgZG9tLnZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb20uZGVmYXVsdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGRvbS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaXNOdWxsT3JVbmRlZihjaGVja2VkKSkge1xyXG4gICAgICAgICAgICBkb20uY2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm9cclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRPcHRpb25Hcm91cCh2Tm9kZSwgdmFsdWUpIHtcclxuICAgIHZhciB0eXBlID0gdk5vZGUudHlwZTtcclxuICAgIGlmICh0eXBlID09PSBcIm9wdGdyb3VwXCIpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbjtcclxuICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZE9wdGlvbihjaGlsZHJlbltpXSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkT3B0aW9uKGNoaWxkcmVuLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdXBkYXRlQ2hpbGRPcHRpb24odk5vZGUsIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB1cGRhdGVDaGlsZE9wdGlvbih2Tm9kZSwgdmFsdWUpIHtcclxuICAgIHZhciBwcm9wcyA9IHZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIHZhciBkb20gPSB2Tm9kZS5kb207XHJcbiAgICAvLyB3ZSBkbyB0aGlzIGFzIG11bHRpcGxlIG1heSBoYXZlIGNoYW5nZWRcclxuICAgIGRvbS52YWx1ZSA9IHByb3BzLnZhbHVlO1xyXG4gICAgaWYgKChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5pbmRleE9mKHByb3BzLnZhbHVlKSAhPT0gLTEpIHx8XHJcbiAgICAgICAgcHJvcHMudmFsdWUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgZG9tLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSB8fCAhaXNOdWxsT3JVbmRlZihwcm9wcy5zZWxlY3RlZCkpIHtcclxuICAgICAgICBkb20uc2VsZWN0ZWQgPSBwcm9wcy5zZWxlY3RlZCB8fCBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBvblNlbGVjdENoYW5nZShlKSB7XHJcbiAgICB2YXIgdk5vZGUgPSB0aGlzLnZOb2RlO1xyXG4gICAgdmFyIHByb3BzID0gdk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgdmFyIGRvbSA9IHZOb2RlLmRvbTtcclxuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJvcHMudmFsdWU7XHJcbiAgICBpZiAocHJvcHMub25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSBwcm9wcy5vbkNoYW5nZTtcclxuICAgICAgICBpZiAoZXZlbnQuZXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQuZXZlbnQoZXZlbnQuZGF0YSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wcy5vbmNoYW5nZSkge1xyXG4gICAgICAgIHByb3BzLm9uY2hhbmdlKGUpO1xyXG4gICAgfVxyXG4gICAgLy8gdGhlIHVzZXIgbWF5IGhhdmUgdXBkYXRlZCB0aGUgdk5vZGUgZnJvbSB0aGUgYWJvdmUgb25JbnB1dCBldmVudHMgc3luY3Jvbm91c2x5XHJcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGdldCBpdCBmcm9tIHRoZSBjb250ZXh0IG9mIGB0aGlzYCBhZ2FpblxyXG4gICAgdmFyIG5ld1ZOb2RlID0gdGhpcy52Tm9kZTtcclxuICAgIHZhciBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIC8vIElmIHJlbmRlciBpcyBnb2luZyBhc3luYyB0aGVyZSBpcyBubyB2YWx1ZSBjaGFuZ2UgeWV0LCBpdCB3aWxsIGNvbWUgYmFjayB0byBwcm9jZXNzIGlucHV0IHNvb25cclxuICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSBuZXdQcm9wcy52YWx1ZSkge1xyXG4gICAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zIHdlIG5lZWQgdG8gc3RvcmUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gYW5kIHJlc3RvcmUgaXQsIHRvIGF2b2lkIGp1bXBpbmdcclxuICAgICAgICBhcHBseVZhbHVlJDEobmV3Vk5vZGUsIGRvbSwgbmV3UHJvcHMsIGZhbHNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzU2VsZWN0KHZOb2RlLCBkb20sIG5leHRQcm9wc09yRW1wdHksIG1vdW50aW5nLCBpc0NvbnRyb2xsZWQpIHtcclxuICAgIGFwcGx5VmFsdWUkMSh2Tm9kZSwgZG9tLCBuZXh0UHJvcHNPckVtcHR5LCBtb3VudGluZyk7XHJcbiAgICBpZiAoaXNDb250cm9sbGVkKSB7XHJcbiAgICAgICAgZG9tLnZOb2RlID0gdk5vZGU7IC8vIFRPRE86IFJlbW92ZSB0aGlzIHdoZW4gaW1wbGVtZW50aW5nIEZpYmVyJ3NcclxuICAgICAgICBpZiAobW91bnRpbmcpIHtcclxuICAgICAgICAgICAgZG9tLm9uY2hhbmdlID0gb25TZWxlY3RDaGFuZ2U7XHJcbiAgICAgICAgICAgIGRvbS5vbmNoYW5nZS53cmFwcGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlWYWx1ZSQxKHZOb2RlLCBkb20sIG5leHRQcm9wc09yRW1wdHksIG1vdW50aW5nKSB7XHJcbiAgICBpZiAobmV4dFByb3BzT3JFbXB0eS5tdWx0aXBsZSAhPT0gZG9tLm11bHRpcGxlKSB7XHJcbiAgICAgICAgZG9tLm11bHRpcGxlID0gbmV4dFByb3BzT3JFbXB0eS5tdWx0aXBsZTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xyXG4gICAgaWYgKCFpc0ludmFsaWQoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gbmV4dFByb3BzT3JFbXB0eS52YWx1ZTtcclxuICAgICAgICBpZiAobW91bnRpbmcgJiYgaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBuZXh0UHJvcHNPckVtcHR5LmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRPcHRpb25Hcm91cChjaGlsZHJlbltpXSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkT3B0aW9uR3JvdXAoY2hpbGRyZW4sIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJub1xyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG5mdW5jdGlvbiB3cmFwcGVkT25DaGFuZ2UkMShlKSB7XHJcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIHZhciBldmVudCA9IHByb3BzLm9uQ2hhbmdlO1xyXG4gICAgaWYgKGV2ZW50LmV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQuZXZlbnQoZXZlbnQuZGF0YSwgZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBldmVudChlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBvblRleHRhcmVhSW5wdXRDaGFuZ2UoZSkge1xyXG4gICAgdmFyIHZOb2RlID0gdGhpcy52Tm9kZTtcclxuICAgIHZhciBwcm9wcyA9IHZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJvcHMudmFsdWU7XHJcbiAgICBpZiAocHJvcHMub25JbnB1dCkge1xyXG4gICAgICAgIHZhciBldmVudCA9IHByb3BzLm9uSW5wdXQ7XHJcbiAgICAgICAgaWYgKGV2ZW50LmV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LmV2ZW50KGV2ZW50LmRhdGEsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnQoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcHMub25pbnB1dCkge1xyXG4gICAgICAgIHByb3BzLm9uaW5wdXQoZSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgdXNlciBtYXkgaGF2ZSB1cGRhdGVkIHRoZSB2Tm9kZSBmcm9tIHRoZSBhYm92ZSBvbklucHV0IGV2ZW50cyBzeW5jcm9ub3VzbHlcclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gZ2V0IGl0IGZyb20gdGhlIGNvbnRleHQgb2YgYHRoaXNgIGFnYWluXHJcbiAgICB2YXIgbmV3Vk5vZGUgPSB0aGlzLnZOb2RlO1xyXG4gICAgdmFyIG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgLy8gSWYgcmVuZGVyIGlzIGdvaW5nIGFzeW5jIHRoZXJlIGlzIG5vIHZhbHVlIGNoYW5nZSB5ZXQsIGl0IHdpbGwgY29tZSBiYWNrIHRvIHByb2Nlc3MgaW5wdXQgc29vblxyXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IG5ld1Byb3BzLnZhbHVlKSB7XHJcbiAgICAgICAgLy8gV2hlbiB0aGlzIGhhcHBlbnMgd2UgbmVlZCB0byBzdG9yZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvbiBhbmQgcmVzdG9yZSBpdCwgdG8gYXZvaWQganVtcGluZ1xyXG4gICAgICAgIGFwcGx5VmFsdWUkMihuZXdWTm9kZSwgdk5vZGUuZG9tLCBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc1RleHRhcmVhKHZOb2RlLCBkb20sIG5leHRQcm9wc09yRW1wdHksIG1vdW50aW5nLCBpc0NvbnRyb2xsZWQpIHtcclxuICAgIGFwcGx5VmFsdWUkMihuZXh0UHJvcHNPckVtcHR5LCBkb20sIG1vdW50aW5nKTtcclxuICAgIGlmIChpc0NvbnRyb2xsZWQpIHtcclxuICAgICAgICBkb20udk5vZGUgPSB2Tm9kZTsgLy8gVE9ETzogUmVtb3ZlIHRoaXMgd2hlbiBpbXBsZW1lbnRpbmcgRmliZXInc1xyXG4gICAgICAgIGlmIChtb3VudGluZykge1xyXG4gICAgICAgICAgICBkb20ub25pbnB1dCA9IG9uVGV4dGFyZWFJbnB1dENoYW5nZTtcclxuICAgICAgICAgICAgZG9tLm9uaW5wdXQud3JhcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcHNPckVtcHR5Lm9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBkb20ub25jaGFuZ2UgPSB3cmFwcGVkT25DaGFuZ2UkMTtcclxuICAgICAgICAgICAgICAgIGRvbS5vbmNoYW5nZS53cmFwcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseVZhbHVlJDIobmV4dFByb3BzT3JFbXB0eSwgZG9tLCBtb3VudGluZykge1xyXG4gICAgdmFyIHZhbHVlID0gbmV4dFByb3BzT3JFbXB0eS52YWx1ZTtcclxuICAgIHZhciBkb21WYWx1ZSA9IGRvbS52YWx1ZTtcclxuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xyXG4gICAgICAgIGlmIChtb3VudGluZykge1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gbmV4dFByb3BzT3JFbXB0eS5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihkZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSBkb21WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbVZhbHVlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICBkb20uZGVmYXVsdFZhbHVlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGRvbS52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBUaGVyZSBpcyB2YWx1ZSBzbyBrZWVwIGl0IGNvbnRyb2xsZWQgKi9cclxuICAgICAgICBpZiAoZG9tVmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRvbS5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgZG9tLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm9cclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuLyoqXHJcbiAqIFRoZXJlIGlzIGN1cnJlbnRseSBubyBzdXBwb3J0IGZvciBzd2l0Y2hpbmcgc2FtZSBpbnB1dCBiZXR3ZWVuIGNvbnRyb2xsZWQgYW5kIG5vbkNvbnRyb2xsZWRcclxuICogSWYgdGhhdCBldmVyIGJlY29tZXMgYSByZWFsIGlzc3VlLCB0aGVuIHJlIGRlc2lnbiBjb250cm9sbGVkIGVsZW1lbnRzXHJcbiAqIEN1cnJlbnRseSB1c2VyIG11c3QgY2hvb3NlIGVpdGhlciBjb250cm9sbGVkIG9yIG5vbi1jb250cm9sbGVkIGFuZCBzdGljayB3aXRoIHRoYXRcclxuICovXHJcbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50KGZsYWdzLCB2Tm9kZSwgZG9tLCBuZXh0UHJvcHNPckVtcHR5LCBtb3VudGluZywgaXNDb250cm9sbGVkKSB7XHJcbiAgICBpZiAoZmxhZ3MgJiA1MTIgLyogSW5wdXRFbGVtZW50ICovKSB7XHJcbiAgICAgICAgcHJvY2Vzc0lucHV0KHZOb2RlLCBkb20sIG5leHRQcm9wc09yRW1wdHksIG1vdW50aW5nLCBpc0NvbnRyb2xsZWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZsYWdzICYgMjA0OCAvKiBTZWxlY3RFbGVtZW50ICovKSB7XHJcbiAgICAgICAgcHJvY2Vzc1NlbGVjdCh2Tm9kZSwgZG9tLCBuZXh0UHJvcHNPckVtcHR5LCBtb3VudGluZywgaXNDb250cm9sbGVkKTtcclxuICAgIH1cclxuICAgIGlmIChmbGFncyAmIDEwMjQgLyogVGV4dGFyZWFFbGVtZW50ICovKSB7XHJcbiAgICAgICAgcHJvY2Vzc1RleHRhcmVhKHZOb2RlLCBkb20sIG5leHRQcm9wc09yRW1wdHksIG1vdW50aW5nLCBpc0NvbnRyb2xsZWQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29udHJvbGxlZEZvcm1FbGVtZW50KG5leHRQcm9wc09yRW1wdHkpIHtcclxuICAgIHJldHVybiBuZXh0UHJvcHNPckVtcHR5LnR5cGUgJiYgaXNDaGVja2VkVHlwZShuZXh0UHJvcHNPckVtcHR5LnR5cGUpXHJcbiAgICAgICAgPyAhaXNOdWxsT3JVbmRlZihuZXh0UHJvcHNPckVtcHR5LmNoZWNrZWQpXHJcbiAgICAgICAgOiAhaXNOdWxsT3JVbmRlZihuZXh0UHJvcHNPckVtcHR5LnZhbHVlKTtcclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkTm9kZXMocGFyZW50RG9tKSB7XHJcbiAgICB2YXIgZG9tID0gcGFyZW50RG9tLmZpcnN0Q2hpbGQ7XHJcbiAgICB3aGlsZSAoZG9tKSB7XHJcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PT0gOCkge1xyXG4gICAgICAgICAgICBpZiAoZG9tLmRhdGEgPT09IFwiIVwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudERvbS5yZXBsYWNlQ2hpbGQocGxhY2Vob2xkZXIsIGRvbSk7XHJcbiAgICAgICAgICAgICAgICBkb20gPSBkb20ubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERvbSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnREb20ucmVtb3ZlQ2hpbGQoZG9tKTtcclxuICAgICAgICAgICAgICAgIGRvbSA9IGxhc3REb20gfHwgcGFyZW50RG9tLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZUNvbXBvbmVudCh2Tm9kZSwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc0NsYXNzKSB7XHJcbiAgICB2YXIgdHlwZSA9IHZOb2RlLnR5cGU7XHJcbiAgICB2YXIgcmVmID0gdk5vZGUucmVmO1xyXG4gICAgdmFyIHByb3BzID0gdk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgaWYgKGlzQ2xhc3MpIHtcclxuICAgICAgICB2YXIgX2lzU1ZHID0gZG9tLm5hbWVzcGFjZVVSSSA9PT0gc3ZnTlM7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlQ2xhc3NDb21wb25lbnRJbnN0YW5jZSh2Tm9kZSwgdHlwZSwgcHJvcHMsIGNvbnRleHQsIF9pc1NWRywgbGlmZWN5Y2xlKTtcclxuICAgICAgICB2YXIgaW5wdXQgPSBpbnN0YW5jZS5fbGFzdElucHV0O1xyXG4gICAgICAgIGluc3RhbmNlLl92Tm9kZSA9IHZOb2RlO1xyXG4gICAgICAgIGh5ZHJhdGUoaW5wdXQsIGRvbSwgbGlmZWN5Y2xlLCBpbnN0YW5jZS5fY2hpbGRDb250ZXh0LCBfaXNTVkcpO1xyXG4gICAgICAgIHZOb2RlLmRvbSA9IGlucHV0LmRvbTtcclxuICAgICAgICBtb3VudENsYXNzQ29tcG9uZW50Q2FsbGJhY2tzKHZOb2RlLCByZWYsIGluc3RhbmNlLCBsaWZlY3ljbGUpO1xyXG4gICAgICAgIGluc3RhbmNlLl91cGRhdGluZyA9IGZhbHNlOyAvLyBNb3VudCBmaW5pc2hlZCBhbGxvdyBnb2luZyBzeW5jXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZmluZERPTU5vZGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFRvRE9NTm9kZU1hcC5zZXQoaW5zdGFuY2UsIGRvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGlucHV0JDEgPSBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50SW5wdXQodk5vZGUsIHR5cGUsIHByb3BzLCBjb250ZXh0KTtcclxuICAgICAgICBoeWRyYXRlKGlucHV0JDEsIGRvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgdk5vZGUuY2hpbGRyZW4gPSBpbnB1dCQxO1xyXG4gICAgICAgIHZOb2RlLmRvbSA9IGlucHV0JDEuZG9tO1xyXG4gICAgICAgIG1vdW50RnVuY3Rpb25hbENvbXBvbmVudENhbGxiYWNrcyhwcm9wcywgcmVmLCBkb20sIGxpZmVjeWNsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9tO1xyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVFbGVtZW50KHZOb2RlLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xyXG4gICAgdmFyIHByb3BzID0gdk5vZGUucHJvcHM7XHJcbiAgICB2YXIgY2xhc3NOYW1lID0gdk5vZGUuY2xhc3NOYW1lO1xyXG4gICAgdmFyIGZsYWdzID0gdk5vZGUuZmxhZ3M7XHJcbiAgICB2YXIgcmVmID0gdk5vZGUucmVmO1xyXG4gICAgaXNTVkcgPSBpc1NWRyB8fCAoZmxhZ3MgJiAxMjggLyogU3ZnRWxlbWVudCAqLykgPiAwO1xyXG4gICAgaWYgKGRvbS5ub2RlVHlwZSAhPT0gMSB8fCBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSB2Tm9kZS50eXBlKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3YXJuaW5nKFwiSW5mZXJubyBoeWRyYXRpb246IFNlcnZlci1zaWRlIG1hcmt1cCBkb2Vzbid0IG1hdGNoIGNsaWVudC1zaWRlIG1hcmt1cCBvciBJbml0aWFsIHJlbmRlciB0YXJnZXQgaXMgbm90IGVtcHR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3RG9tID0gbW91bnRFbGVtZW50KHZOb2RlLCBudWxsLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgICAgICB2Tm9kZS5kb20gPSBuZXdEb207XHJcbiAgICAgICAgcmVwbGFjZUNoaWxkKGRvbS5wYXJlbnROb2RlLCBuZXdEb20sIGRvbSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0RvbTtcclxuICAgIH1cclxuICAgIHZOb2RlLmRvbSA9IGRvbTtcclxuICAgIGlmICghaXNJbnZhbGlkKGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihjaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvbS5maXJzdENoaWxkICE9PSBudWxsICYmICFpc1NhbWVQcm9wc0lubmVySFRNTChkb20sIHByb3BzKSkge1xyXG4gICAgICAgIGRvbS50ZXh0Q29udGVudCA9IFwiXCI7IC8vIGRvbSBoYXMgY29udGVudCwgYnV0IFZOb2RlIGhhcyBubyBjaGlsZHJlbiByZW1vdmUgZXZlcnl0aGluZyBmcm9tIERPTVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIGhhc0NvbnRyb2xsZWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpc0Zvcm1FbGVtZW50ID0gKGZsYWdzICYgMzU4NCAvKiBGb3JtRWxlbWVudCAqLykgPiAwO1xyXG4gICAgICAgIGlmIChpc0Zvcm1FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGhhc0NvbnRyb2xsZWRWYWx1ZSA9IGlzQ29udHJvbGxlZEZvcm1FbGVtZW50KHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAvLyBkbyBub3QgYWRkIGEgaGFzT3duUHJvcGVydHkgY2hlY2sgaGVyZSwgaXQgYWZmZWN0cyBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICBwYXRjaFByb3AocHJvcCwgbnVsbCwgcHJvcHNbcHJvcF0sIGRvbSwgaXNTVkcsIGhhc0NvbnRyb2xsZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Zvcm1FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KGZsYWdzLCB2Tm9kZSwgZG9tLCBwcm9wcywgdHJ1ZSwgaGFzQ29udHJvbGxlZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY2xhc3NOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGRvbS5jbGFzc05hbWUgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyZWYpIHtcclxuICAgICAgICBtb3VudFJlZihkb20sIHJlZiwgbGlmZWN5Y2xlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb207XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpIHtcclxuICAgIG5vcm1hbGl6ZUNoaWxkTm9kZXMocGFyZW50RG9tKTtcclxuICAgIHZhciBkb20gPSBwYXJlbnREb20uZmlyc3RDaGlsZDtcclxuICAgIGlmIChpc1N0cmluZ09yTnVtYmVyKGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGlmICghaXNOdWxsKGRvbSkgJiYgZG9tLm5vZGVUeXBlID09PSAzKSB7XHJcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVZhbHVlICE9PSBjaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgZG9tLm5vZGVWYWx1ZSA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHBhcmVudERvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnREb20udGV4dENvbnRlbnQgPSBjaGlsZHJlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc051bGwoZG9tKSkge1xyXG4gICAgICAgICAgICBkb20gPSBkb20ubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsKGNoaWxkKSAmJiBpc09iamVjdChjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGRvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBkb20ubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZShjaGlsZCwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICBkb20gPSBuZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50KGNoaWxkLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSXQncyBWTm9kZVxyXG4gICAgICAgIGlmICghaXNOdWxsKGRvbSkpIHtcclxuICAgICAgICAgICAgaHlkcmF0ZShjaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgICAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW91bnQoY2hpbGRyZW4sIHBhcmVudERvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2xlYXIgYW55IG90aGVyIERPTSBub2RlcywgdGhlcmUgc2hvdWxkIGJlIG9ubHkgYSBzaW5nbGUgZW50cnkgZm9yIHRoZSByb290XHJcbiAgICB3aGlsZSAoZG9tKSB7XHJcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nJDEgPSBkb20ubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgcGFyZW50RG9tLnJlbW92ZUNoaWxkKGRvbSk7XHJcbiAgICAgICAgZG9tID0gbmV4dFNpYmxpbmckMTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGV4dCh2Tm9kZSwgZG9tKSB7XHJcbiAgICBpZiAoZG9tLm5vZGVUeXBlICE9PSAzKSB7XHJcbiAgICAgICAgdmFyIG5ld0RvbSA9IG1vdW50VGV4dCh2Tm9kZSwgbnVsbCk7XHJcbiAgICAgICAgdk5vZGUuZG9tID0gbmV3RG9tO1xyXG4gICAgICAgIHJlcGxhY2VDaGlsZChkb20ucGFyZW50Tm9kZSwgbmV3RG9tLCBkb20pO1xyXG4gICAgICAgIHJldHVybiBuZXdEb207XHJcbiAgICB9XHJcbiAgICB2YXIgdGV4dCA9IHZOb2RlLmNoaWxkcmVuO1xyXG4gICAgaWYgKGRvbS5ub2RlVmFsdWUgIT09IHRleHQpIHtcclxuICAgICAgICBkb20ubm9kZVZhbHVlID0gdGV4dDtcclxuICAgIH1cclxuICAgIHZOb2RlLmRvbSA9IGRvbTtcclxuICAgIHJldHVybiBkb207XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVZvaWQodk5vZGUsIGRvbSkge1xyXG4gICAgdk5vZGUuZG9tID0gZG9tO1xyXG4gICAgcmV0dXJuIGRvbTtcclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlKHZOb2RlLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpIHtcclxuICAgIHZhciBmbGFncyA9IHZOb2RlLmZsYWdzO1xyXG4gICAgaWYgKGZsYWdzICYgMjggLyogQ29tcG9uZW50ICovKSB7XHJcbiAgICAgICAgaHlkcmF0ZUNvbXBvbmVudCh2Tm9kZSwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCAoZmxhZ3MgJiA0IC8qIENvbXBvbmVudENsYXNzICovKSA+IDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmxhZ3MgJiAzOTcwIC8qIEVsZW1lbnQgKi8pIHtcclxuICAgICAgICBoeWRyYXRlRWxlbWVudCh2Tm9kZSwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsYWdzICYgMSAvKiBUZXh0ICovKSB7XHJcbiAgICAgICAgaHlkcmF0ZVRleHQodk5vZGUsIGRvbSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbGFncyAmIDQwOTYgLyogVm9pZCAqLykge1xyXG4gICAgICAgIGh5ZHJhdGVWb2lkKHZOb2RlLCBkb20pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKChcImh5ZHJhdGUoKSBleHBlY3RzIGEgdmFsaWQgVk5vZGUsIGluc3RlYWQgaXQgcmVjZWl2ZWQgYW4gb2JqZWN0IHdpdGggdGhlIHR5cGUgXFxcIlwiICsgKHR5cGVvZiB2Tm9kZSkgKyBcIlxcXCIuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3dFcnJvcigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVSb290KGlucHV0LCBwYXJlbnREb20sIGxpZmVjeWNsZSkge1xyXG4gICAgaWYgKCFpc051bGwocGFyZW50RG9tKSkge1xyXG4gICAgICAgIHZhciBkb20gPSBwYXJlbnREb20uZmlyc3RDaGlsZDtcclxuICAgICAgICBpZiAoIWlzTnVsbChkb20pKSB7XHJcbiAgICAgICAgICAgIGh5ZHJhdGUoaW5wdXQsIGRvbSwgbGlmZWN5Y2xlLCBFTVBUWV9PQkosIGZhbHNlKTtcclxuICAgICAgICAgICAgZG9tID0gcGFyZW50RG9tLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIGFueSBvdGhlciBET00gbm9kZXMsIHRoZXJlIHNob3VsZCBiZSBvbmx5IGEgc2luZ2xlIGVudHJ5IGZvciB0aGUgcm9vdFxyXG4gICAgICAgICAgICB3aGlsZSAoKGRvbSA9IGRvbS5uZXh0U2libGluZykpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudERvbS5yZW1vdmVDaGlsZChkb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbnZhciBjb21wb25lbnRQb29scyA9IG5ldyBNYXAoKTtcclxudmFyIGVsZW1lbnRQb29scyA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gcmVjeWNsZUVsZW1lbnQodk5vZGUsIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpIHtcclxuICAgIHZhciB0YWcgPSB2Tm9kZS50eXBlO1xyXG4gICAgdmFyIHBvb2xzID0gZWxlbWVudFBvb2xzLmdldCh0YWcpO1xyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChwb29scykpIHtcclxuICAgICAgICB2YXIga2V5ID0gdk5vZGUua2V5O1xyXG4gICAgICAgIHZhciBwb29sID0ga2V5ID09PSBudWxsID8gcG9vbHMubm9uS2V5ZWQgOiBwb29scy5rZXllZC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHBvb2wpKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN5Y2xlZFZOb2RlID0gcG9vbC5wb3AoKTtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZWN5Y2xlZFZOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hFbGVtZW50KHJlY3ljbGVkVk5vZGUsIHZOb2RlLCBudWxsLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2Tm9kZS5kb207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBwb29sRWxlbWVudCh2Tm9kZSkge1xyXG4gICAgdmFyIHRhZyA9IHZOb2RlLnR5cGU7XHJcbiAgICB2YXIga2V5ID0gdk5vZGUua2V5O1xyXG4gICAgdmFyIHBvb2xzID0gZWxlbWVudFBvb2xzLmdldCh0YWcpO1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkKHBvb2xzKSkge1xyXG4gICAgICAgIHBvb2xzID0ge1xyXG4gICAgICAgICAgICBrZXllZDogbmV3IE1hcCgpLFxyXG4gICAgICAgICAgICBub25LZXllZDogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIGVsZW1lbnRQb29scy5zZXQodGFnLCBwb29scyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOdWxsKGtleSkpIHtcclxuICAgICAgICBwb29scy5ub25LZXllZC5wdXNoKHZOb2RlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBwb29sID0gcG9vbHMua2V5ZWQuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHBvb2wpKSB7XHJcbiAgICAgICAgICAgIHBvb2wgPSBbXTtcclxuICAgICAgICAgICAgcG9vbHMua2V5ZWQuc2V0KGtleSwgcG9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvb2wucHVzaCh2Tm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVjeWNsZUNvbXBvbmVudCh2Tm9kZSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRykge1xyXG4gICAgdmFyIHR5cGUgPSB2Tm9kZS50eXBlO1xyXG4gICAgdmFyIHBvb2xzID0gY29tcG9uZW50UG9vbHMuZ2V0KHR5cGUpO1xyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChwb29scykpIHtcclxuICAgICAgICB2YXIga2V5ID0gdk5vZGUua2V5O1xyXG4gICAgICAgIHZhciBwb29sID0ga2V5ID09PSBudWxsID8gcG9vbHMubm9uS2V5ZWQgOiBwb29scy5rZXllZC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHBvb2wpKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN5Y2xlZFZOb2RlID0gcG9vbC5wb3AoKTtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZWN5Y2xlZFZOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gdk5vZGUuZmxhZ3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFpbGVkID0gcGF0Y2hDb21wb25lbnQocmVjeWNsZWRWTm9kZSwgdk5vZGUsIG51bGwsIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIChmbGFncyAmIDQgLyogQ29tcG9uZW50Q2xhc3MgKi8pID4gMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZhaWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2Tm9kZS5kb207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBwb29sQ29tcG9uZW50KHZOb2RlKSB7XHJcbiAgICB2YXIgaG9va3MgPSB2Tm9kZS5yZWY7XHJcbiAgICB2YXIgbm9uUmVjeWNsZUhvb2tzID0gaG9va3MgJiZcclxuICAgICAgICAoaG9va3Mub25Db21wb25lbnRXaWxsTW91bnQgfHxcclxuICAgICAgICAgICAgaG9va3Mub25Db21wb25lbnRXaWxsVW5tb3VudCB8fFxyXG4gICAgICAgICAgICBob29rcy5vbkNvbXBvbmVudERpZE1vdW50IHx8XHJcbiAgICAgICAgICAgIGhvb2tzLm9uQ29tcG9uZW50V2lsbFVwZGF0ZSB8fFxyXG4gICAgICAgICAgICBob29rcy5vbkNvbXBvbmVudERpZFVwZGF0ZSk7XHJcbiAgICBpZiAobm9uUmVjeWNsZUhvb2tzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHR5cGUgPSB2Tm9kZS50eXBlO1xyXG4gICAgdmFyIGtleSA9IHZOb2RlLmtleTtcclxuICAgIHZhciBwb29scyA9IGNvbXBvbmVudFBvb2xzLmdldCh0eXBlKTtcclxuICAgIGlmIChpc1VuZGVmaW5lZChwb29scykpIHtcclxuICAgICAgICBwb29scyA9IHtcclxuICAgICAgICAgICAga2V5ZWQ6IG5ldyBNYXAoKSxcclxuICAgICAgICAgICAgbm9uS2V5ZWQ6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb21wb25lbnRQb29scy5zZXQodHlwZSwgcG9vbHMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVsbChrZXkpKSB7XHJcbiAgICAgICAgcG9vbHMubm9uS2V5ZWQucHVzaCh2Tm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgcG9vbCA9IHBvb2xzLmtleWVkLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChwb29sKSkge1xyXG4gICAgICAgICAgICBwb29sID0gW107XHJcbiAgICAgICAgICAgIHBvb2xzLmtleWVkLnNldChrZXksIHBvb2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb29sLnB1c2godk5vZGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm9cclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuZnVuY3Rpb24gdW5tb3VudCh2Tm9kZSwgcGFyZW50RG9tLCBsaWZlY3ljbGUsIGNhblJlY3ljbGUsIGlzUmVjeWNsaW5nKSB7XHJcbiAgICB2YXIgZmxhZ3MgPSB2Tm9kZS5mbGFncztcclxuICAgIHZhciBkb20gPSB2Tm9kZS5kb207XHJcbiAgICBpZiAoZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSB2Tm9kZS5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgaXNTdGF0ZWZ1bENvbXBvbmVudCQkMSA9IChmbGFncyAmIDQgLyogQ29tcG9uZW50Q2xhc3MgKi8pID4gMDtcclxuICAgICAgICB2YXIgcHJvcHMgPSB2Tm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgdmFyIHJlZiA9IHZOb2RlLnJlZjtcclxuICAgICAgICBpZiAoIWlzUmVjeWNsaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50JCQxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLl91bm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmJlZm9yZVVubW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlVW5tb3VudCh2Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYgJiYgIWlzUmVjeWNsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZihudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX3VubW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmluZERPTU5vZGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFRvRE9NTm9kZU1hcC5kZWxldGUoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGluc3RhbmNlLl9sYXN0SW5wdXQsIG51bGwsIGluc3RhbmNlLl9saWZlY3ljbGUsIGZhbHNlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihyZWYub25Db21wb25lbnRXaWxsVW5tb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLm9uQ29tcG9uZW50V2lsbFVubW91bnQoZG9tLCBwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdW5tb3VudChpbnN0YW5jZSwgbnVsbCwgbGlmZWN5Y2xlLCBmYWxzZSwgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlY3ljbGluZ0VuYWJsZWQgJiZcclxuICAgICAgICAgICAgIWlzU3RhdGVmdWxDb21wb25lbnQkJDEgJiZcclxuICAgICAgICAgICAgKHBhcmVudERvbSB8fCBjYW5SZWN5Y2xlKSkge1xyXG4gICAgICAgICAgICBwb29sQ29tcG9uZW50KHZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbGFncyAmIDM5NzAgLyogRWxlbWVudCAqLykge1xyXG4gICAgICAgIHZhciByZWYkMSA9IHZOb2RlLnJlZjtcclxuICAgICAgICB2YXIgcHJvcHMkMSA9IHZOb2RlLnByb3BzO1xyXG4gICAgICAgIGlmICghaXNSZWN5Y2xpbmcgJiYgaXNGdW5jdGlvbihyZWYkMSkpIHtcclxuICAgICAgICAgICAgcmVmJDEobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW52YWxpZChjaGlsZCkgJiYgaXNPYmplY3QoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIG51bGwsIGxpZmVjeWNsZSwgZmFsc2UsIGlzUmVjeWNsaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNoaWxkcmVuLCBudWxsLCBsaWZlY3ljbGUsIGZhbHNlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc051bGwocHJvcHMkMSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcm9wcyQxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWRkIGEgaGFzT3duUHJvcGVydHkgY2hlY2sgaGVyZSwgaXQgYWZmZWN0cyBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzJDFbbmFtZV0gIT09IG51bGwgJiYgaXNBdHRyQW5FdmVudChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRXZlbnQobmFtZSwgcHJvcHMkMVtuYW1lXSwgbnVsbCwgZG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCB0aGlzIG51bGwsIGJlY2F1c2Ugc2FtZSBwcm9wcyBvdGhlcndpc2UgY29tZSBiYWNrIGlmIFNDVSByZXR1cm5zIGZhbHNlIGFuZCB3ZSBhcmUgcmVjeWxpbmdcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcyQxW25hbWVdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5yZWN5Y2xpbmdFbmFibGVkICYmIChwYXJlbnREb20gfHwgY2FuUmVjeWNsZSkpIHtcclxuICAgICAgICAgICAgcG9vbEVsZW1lbnQodk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNOdWxsKHBhcmVudERvbSkpIHtcclxuICAgICAgICByZW1vdmVDaGlsZChwYXJlbnREb20sIGRvbSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJub1xyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG4vLyByYXRoZXIgdGhhbiB1c2UgYSBNYXAsIGxpa2Ugd2UgZGlkIGJlZm9yZSwgd2UgY2FuIHVzZSBhbiBhcnJheSBoZXJlXHJcbi8vIGdpdmVuIHRoZXJlIHNob3VsZG4ndCBiZSBUSEFUIG1hbnkgcm9vdHMgb24gdGhlIHBhZ2UsIHRoZSBkaWZmZXJlbmNlXHJcbi8vIGluIHBlcmZvcm1hbmNlIGlzIGh1Z2U6IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNTgwMmE2OTEzMzBhYjA5OTAwYTFhMmRhXHJcbnZhciBjb21wb25lbnRUb0RPTU5vZGVNYXAgPSBuZXcgTWFwKCk7XHJcbnZhciByb290cyA9IG9wdGlvbnMucm9vdHM7XHJcbi8qKlxyXG4gKiBXaGVuIGluZmVybm8ub3B0aW9ucy5maW5kRE9NTk9kZUVuYWJsZWQgaXMgdHJ1ZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBET00gTm9kZSBieSBjb21wb25lbnQgaW5zdGFuY2VcclxuICogQHBhcmFtIHJlZiBDb21wb25lbnQgaW5zdGFuY2VcclxuICogQHJldHVybnMgeyp8bnVsbH0gcmV0dXJucyBkb20gbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gZmluZERPTU5vZGUocmVmKSB7XHJcbiAgICBpZiAoIW9wdGlvbnMuZmluZERPTU5vZGVFbmFibGVkKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKFwiZmluZERPTU5vZGUoKSBoYXMgYmVlbiBkaXNhYmxlZCwgdXNlIEluZmVybm8ub3B0aW9ucy5maW5kRE9NTm9kZUVuYWJsZWQgPSB0cnVlOyBlbmFibGVkIGZpbmRET01Ob2RlKCkuIFdhcm5pbmcgdGhpcyBjYW4gc2lnbmlmaWNhbnRseSBpbXBhY3QgcGVyZm9ybWFuY2UhXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvd0Vycm9yKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgZG9tID0gcmVmICYmIHJlZi5ub2RlVHlwZSA/IHJlZiA6IG51bGw7XHJcbiAgICByZXR1cm4gY29tcG9uZW50VG9ET01Ob2RlTWFwLmdldChyZWYpIHx8IGRvbTtcclxufVxyXG5mdW5jdGlvbiBnZXRSb290KGRvbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvb3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHJvb3QgPSByb290c1tpXTtcclxuICAgICAgICBpZiAocm9vdC5kb20gPT09IGRvbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBzZXRSb290KGRvbSwgaW5wdXQsIGxpZmVjeWNsZSkge1xyXG4gICAgdmFyIHJvb3QgPSB7XHJcbiAgICAgICAgZG9tOiBkb20sXHJcbiAgICAgICAgaW5wdXQ6IGlucHV0LFxyXG4gICAgICAgIGxpZmVjeWNsZTogbGlmZWN5Y2xlXHJcbiAgICB9O1xyXG4gICAgcm9vdHMucHVzaChyb290KTtcclxuICAgIHJldHVybiByb290O1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVJvb3Qocm9vdCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvb3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHJvb3RzW2ldID09PSByb290KSB7XHJcbiAgICAgICAgICAgIHJvb3RzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG57XHJcbiAgICBpZiAoaXNCcm93c2VyICYmIGRvY3VtZW50LmJvZHkgPT09IG51bGwpIHtcclxuICAgICAgICB3YXJuaW5nKCdJbmZlcm5vIHdhcm5pbmc6IHlvdSBjYW5ub3QgaW5pdGlhbGl6ZSBpbmZlcm5vIHdpdGhvdXQgXCJkb2N1bWVudC5ib2R5XCIuIFdhaXQgb24gXCJET01Db250ZW50TG9hZGVkXCIgZXZlbnQsIGFkZCBzY3JpcHQgdG8gYm90dG9tIG9mIGJvZHksIG9yIHVzZSBhc3luYy9kZWZlciBhdHRyaWJ1dGVzIG9uIHNjcmlwdCB0YWcuJyk7XHJcbiAgICB9XHJcbn1cclxudmFyIGRvY3VtZW50Qm9keSA9IGlzQnJvd3NlciA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xyXG4vKipcclxuICogUmVuZGVycyB2aXJ0dWFsIG5vZGUgdHJlZSBpbnRvIHBhcmVudCBub2RlLlxyXG4gKiBAcGFyYW0ge1ZOb2RlIHwgbnVsbCB8IHN0cmluZyB8IG51bWJlcn0gaW5wdXQgdk5vZGUgdG8gYmUgcmVuZGVyZWRcclxuICogQHBhcmFtIHBhcmVudERvbSBET00gbm9kZSB3aGljaCBjb250ZW50IHdpbGwgYmUgcmVwbGFjZWQgYnkgdmlydHVhbCBub2RlXHJcbiAqIEByZXR1cm5zIHtJbmZlcm5vQ2hpbGRyZW59IHJlbmRlcmVkIHZpcnR1YWwgbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyKGlucHV0LCBwYXJlbnREb20pIHtcclxuICAgIGlmIChkb2N1bWVudEJvZHkgPT09IHBhcmVudERvbSkge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcigneW91IGNhbm5vdCByZW5kZXIoKSB0byB0aGUgXCJkb2N1bWVudC5ib2R5XCIuIFVzZSBhbiBlbXB0eSBlbGVtZW50IGFzIGEgY29udGFpbmVyIGluc3RlYWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93RXJyb3IoKTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dCA9PT0gTk9fT1ApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgcm9vdCA9IGdldFJvb3QocGFyZW50RG9tKTtcclxuICAgIGlmIChpc051bGwocm9vdCkpIHtcclxuICAgICAgICB2YXIgbGlmZWN5Y2xlID0gbmV3IExpZmVjeWNsZSgpO1xyXG4gICAgICAgIGlmICghaXNJbnZhbGlkKGlucHV0KSkge1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGRpcmVjdENsb25lKGlucHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWh5ZHJhdGVSb290KGlucHV0LCBwYXJlbnREb20sIGxpZmVjeWNsZSkpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50KGlucHV0LCBwYXJlbnREb20sIGxpZmVjeWNsZSwgRU1QVFlfT0JKLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdCA9IHNldFJvb3QocGFyZW50RG9tLCBpbnB1dCwgbGlmZWN5Y2xlKTtcclxuICAgICAgICAgICAgbGlmZWN5Y2xlLnRyaWdnZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbGlmZWN5Y2xlJDEgPSByb290LmxpZmVjeWNsZTtcclxuICAgICAgICBsaWZlY3ljbGUkMS5saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcclxuICAgICAgICAgICAgdW5tb3VudChyb290LmlucHV0LCBwYXJlbnREb20sIGxpZmVjeWNsZSQxLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZW1vdmVSb290KHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmRvbSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBkaXJlY3RDbG9uZShpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGF0Y2gocm9vdC5pbnB1dCwgaW5wdXQsIHBhcmVudERvbSwgbGlmZWN5Y2xlJDEsIEVNUFRZX09CSiwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vdC5pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgIGxpZmVjeWNsZSQxLnRyaWdnZXIoKTtcclxuICAgIH1cclxuICAgIGlmIChyb290KSB7XHJcbiAgICAgICAgdmFyIHJvb3RJbnB1dCA9IHJvb3QuaW5wdXQ7XHJcbiAgICAgICAgaWYgKHJvb3RJbnB1dCAmJiByb290SW5wdXQuZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvb3RJbnB1dC5jaGlsZHJlbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIocGFyZW50RG9tKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVuZGVyZXIobGFzdElucHV0LCBuZXh0SW5wdXQpIHtcclxuICAgICAgICBpZiAoIXBhcmVudERvbSkge1xyXG4gICAgICAgICAgICBwYXJlbnREb20gPSBsYXN0SW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcihuZXh0SW5wdXQsIHBhcmVudERvbSk7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm9cclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuZnVuY3Rpb24gcGF0Y2gobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRywgaXNSZWN5Y2xpbmcpIHtcclxuICAgIGlmIChsYXN0Vk5vZGUgIT09IG5leHRWTm9kZSkge1xyXG4gICAgICAgIHZhciBsYXN0RmxhZ3MgPSBsYXN0Vk5vZGUuZmxhZ3M7XHJcbiAgICAgICAgdmFyIG5leHRGbGFncyA9IG5leHRWTm9kZS5mbGFncztcclxuICAgICAgICBpZiAobmV4dEZsYWdzICYgMjggLyogQ29tcG9uZW50ICovKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0NsYXNzID0gKG5leHRGbGFncyAmIDQgLyogQ29tcG9uZW50Q2xhc3MgKi8pID4gMDtcclxuICAgICAgICAgICAgaWYgKGxhc3RGbGFncyAmIDI4IC8qIENvbXBvbmVudCAqLykge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hDb21wb25lbnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRywgaXNDbGFzcywgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZVZOb2RlKHBhcmVudERvbSwgbW91bnRDb21wb25lbnQobmV4dFZOb2RlLCBudWxsLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc0NsYXNzKSwgbGFzdFZOb2RlLCBsaWZlY3ljbGUsIGlzUmVjeWNsaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXh0RmxhZ3MgJiAzOTcwIC8qIEVsZW1lbnQgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RGbGFncyAmIDM5NzAgLyogRWxlbWVudCAqLykge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hFbGVtZW50KGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VWTm9kZShwYXJlbnREb20sIG1vdW50RWxlbWVudChuZXh0Vk5vZGUsIG51bGwsIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpLCBsYXN0Vk5vZGUsIGxpZmVjeWNsZSwgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5leHRGbGFncyAmIDEgLyogVGV4dCAqLykge1xyXG4gICAgICAgICAgICBpZiAobGFzdEZsYWdzICYgMSAvKiBUZXh0ICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaFRleHQobGFzdFZOb2RlLCBuZXh0Vk5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZVZOb2RlKHBhcmVudERvbSwgbW91bnRUZXh0KG5leHRWTm9kZSwgbnVsbCksIGxhc3RWTm9kZSwgbGlmZWN5Y2xlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmV4dEZsYWdzICYgNDA5NiAvKiBWb2lkICovKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0RmxhZ3MgJiA0MDk2IC8qIFZvaWQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoVm9pZChsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlVk5vZGUocGFyZW50RG9tLCBtb3VudFZvaWQobmV4dFZOb2RlLCBudWxsKSwgbGFzdFZOb2RlLCBsaWZlY3ljbGUsIGlzUmVjeWNsaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRXJyb3IgY2FzZTogbW91bnQgbmV3IG9uZSByZXBsYWNpbmcgb2xkIG9uZVxyXG4gICAgICAgICAgICByZXBsYWNlTGFzdENoaWxkQW5kVW5tb3VudChsYXN0Vk5vZGUsIG5leHRWTm9kZSwgcGFyZW50RG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGlzUmVjeWNsaW5nKSB7XHJcbiAgICBpZiAoaXNWTm9kZShjaGlsZHJlbikpIHtcclxuICAgICAgICB1bm1vdW50KGNoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgdHJ1ZSwgaXNSZWN5Y2xpbmcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICByZW1vdmVBbGxDaGlsZHJlbihkb20sIGNoaWxkcmVuLCBsaWZlY3ljbGUsIGlzUmVjeWNsaW5nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRvbS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hFbGVtZW50KGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nKSB7XHJcbiAgICB2YXIgbmV4dFRhZyA9IG5leHRWTm9kZS50eXBlO1xyXG4gICAgdmFyIGxhc3RUYWcgPSBsYXN0Vk5vZGUudHlwZTtcclxuICAgIGlmIChsYXN0VGFnICE9PSBuZXh0VGFnKSB7XHJcbiAgICAgICAgcmVwbGFjZVdpdGhOZXdOb2RlKGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBkb20gPSBsYXN0Vk5vZGUuZG9tO1xyXG4gICAgICAgIHZhciBsYXN0UHJvcHMgPSBsYXN0Vk5vZGUucHJvcHM7XHJcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IG5leHRWTm9kZS5wcm9wcztcclxuICAgICAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdFZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Vk5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGxhc3RGbGFncyA9IGxhc3RWTm9kZS5mbGFncztcclxuICAgICAgICB2YXIgbmV4dEZsYWdzID0gbmV4dFZOb2RlLmZsYWdzO1xyXG4gICAgICAgIHZhciBuZXh0UmVmID0gbmV4dFZOb2RlLnJlZjtcclxuICAgICAgICB2YXIgbGFzdENsYXNzTmFtZSA9IGxhc3RWTm9kZS5jbGFzc05hbWU7XHJcbiAgICAgICAgdmFyIG5leHRDbGFzc05hbWUgPSBuZXh0Vk5vZGUuY2xhc3NOYW1lO1xyXG4gICAgICAgIG5leHRWTm9kZS5kb20gPSBkb207XHJcbiAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCAobmV4dEZsYWdzICYgMTI4IC8qIFN2Z0VsZW1lbnQgKi8pID4gMDtcclxuICAgICAgICBpZiAobGFzdENoaWxkcmVuICE9PSBuZXh0Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuSXNTVkcgPSBpc1NWRyA9PT0gdHJ1ZSAmJiBuZXh0Vk5vZGUudHlwZSAhPT0gXCJmb3JlaWduT2JqZWN0XCI7XHJcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4obGFzdEZsYWdzLCBuZXh0RmxhZ3MsIGxhc3RDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgY2hpbGRyZW5Jc1NWRywgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmxpbmVkIHBhdGNoUHJvcHMgIC0tIHN0YXJ0cyAtLVxyXG4gICAgICAgIGlmIChsYXN0UHJvcHMgIT09IG5leHRQcm9wcykge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFByb3BzT3JFbXB0eSA9IGxhc3RQcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgICAgIHZhciBuZXh0UHJvcHNPckVtcHR5ID0gbmV4dFByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICAgICAgdmFyIGhhc0NvbnRyb2xsZWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobmV4dFByb3BzT3JFbXB0eSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNGb3JtRWxlbWVudCA9IChuZXh0RmxhZ3MgJiAzNTg0IC8qIEZvcm1FbGVtZW50ICovKSA+IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGb3JtRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbnRyb2xsZWRWYWx1ZSA9IGlzQ29udHJvbGxlZEZvcm1FbGVtZW50KG5leHRQcm9wc09yRW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBuZXh0UHJvcHNPckVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGFkZCBhIGhhc093blByb3BlcnR5IGNoZWNrIGhlcmUsIGl0IGFmZmVjdHMgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gbmV4dFByb3BzT3JFbXB0eVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gbGFzdFByb3BzT3JFbXB0eVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AocHJvcCwgbGFzdFZhbHVlLCBuZXh0VmFsdWUsIGRvbSwgaXNTVkcsIGhhc0NvbnRyb2xsZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGb3JtRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gaW5mZXJubyBpcyByZWN5Y2xpbmcgZm9ybSBlbGVtZW50LCB3ZSBuZWVkIHRvIHByb2Nlc3MgaXQgbGlrZSBpdCB3b3VsZCBiZSBtb3VudGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KG5leHRGbGFncywgbmV4dFZOb2RlLCBkb20sIG5leHRQcm9wc09yRW1wdHksIGlzUmVjeWNsaW5nLCBoYXNDb250cm9sbGVkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcHNPckVtcHR5ICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AkMSBpbiBsYXN0UHJvcHNPckVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGFkZCBhIGhhc093blByb3BlcnR5IGNoZWNrIGhlcmUsIGl0IGFmZmVjdHMgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZihuZXh0UHJvcHNPckVtcHR5W3Byb3AkMV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc051bGxPclVuZGVmKGxhc3RQcm9wc09yRW1wdHlbcHJvcCQxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUHJvcChwcm9wJDEsIGxhc3RQcm9wc09yRW1wdHlbcHJvcCQxXSwgZG9tLCBuZXh0RmxhZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmxpbmVkIHBhdGNoUHJvcHMgIC0tIGVuZHMgLS1cclxuICAgICAgICBpZiAobGFzdENsYXNzTmFtZSAhPT0gbmV4dENsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZihuZXh0Q2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIG5leHRDbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IG5leHRDbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5leHRSZWYpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RWTm9kZS5yZWYgIT09IG5leHRSZWYgfHwgaXNSZWN5Y2xpbmcpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50UmVmKGRvbSwgbmV4dFJlZiwgbGlmZWN5Y2xlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaENoaWxkcmVuKGxhc3RGbGFncywgbmV4dEZsYWdzLCBsYXN0Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZykge1xyXG4gICAgdmFyIHBhdGNoQXJyYXkgPSBmYWxzZTtcclxuICAgIHZhciBwYXRjaEtleWVkID0gZmFsc2U7XHJcbiAgICBpZiAobmV4dEZsYWdzICYgNjQgLyogSGFzTm9uS2V5ZWRDaGlsZHJlbiAqLykge1xyXG4gICAgICAgIHBhdGNoQXJyYXkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKGxhc3RGbGFncyAmIDMyIC8qIEhhc0tleWVkQ2hpbGRyZW4gKi8pID4gMCAmJlxyXG4gICAgICAgIChuZXh0RmxhZ3MgJiAzMiAvKiBIYXNLZXllZENoaWxkcmVuICovKSA+IDApIHtcclxuICAgICAgICBwYXRjaEtleWVkID0gdHJ1ZTtcclxuICAgICAgICBwYXRjaEFycmF5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzSW52YWxpZChuZXh0Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGxhc3RDaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGlzUmVjeWNsaW5nKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzSW52YWxpZChsYXN0Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nT3JOdW1iZXIobmV4dENoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBzZXRUZXh0Q29udGVudChkb20sIG5leHRDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShuZXh0Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudEFycmF5Q2hpbGRyZW4obmV4dENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW91bnQobmV4dENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmdPck51bWJlcihuZXh0Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nT3JOdW1iZXIobGFzdENoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICB1cGRhdGVUZXh0Q29udGVudChkb20sIG5leHRDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4obGFzdENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgICAgICBzZXRUZXh0Q29udGVudChkb20sIG5leHRDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShuZXh0Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkobGFzdENoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBwYXRjaEFycmF5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGlzS2V5ZWQobGFzdENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaEtleWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGxhc3RDaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGlzUmVjeWNsaW5nKTtcclxuICAgICAgICAgICAgbW91bnRBcnJheUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KGxhc3RDaGlsZHJlbikpIHtcclxuICAgICAgICByZW1vdmVBbGxDaGlsZHJlbihkb20sIGxhc3RDaGlsZHJlbiwgbGlmZWN5Y2xlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgbW91bnQobmV4dENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNWTm9kZShuZXh0Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgaWYgKGlzVk5vZGUobGFzdENoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBwYXRjaChsYXN0Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4obGFzdENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgICAgICBtb3VudChuZXh0Q2hpbGRyZW4sIGRvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhdGNoQXJyYXkpIHtcclxuICAgICAgICB2YXIgbGFzdExlbmd0aCA9IGxhc3RDaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG5leHRMZW5ndGggPSBuZXh0Q2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIC8vIEZhc3QgcGF0aCdzIGZvciBib3RoIGFsZ29yaXRobXNcclxuICAgICAgICBpZiAobGFzdExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAobmV4dExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG1vdW50QXJyYXlDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIGRvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmV4dExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZW1vdmVBbGxDaGlsZHJlbihkb20sIGxhc3RDaGlsZHJlbiwgbGlmZWN5Y2xlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGNoS2V5ZWQpIHtcclxuICAgICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKGxhc3RDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nLCBsYXN0TGVuZ3RoLCBuZXh0TGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoTm9uS2V5ZWRDaGlsZHJlbihsYXN0Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZywgbGFzdExlbmd0aCwgbmV4dExlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGNoQ29tcG9uZW50KGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzQ2xhc3MsIGlzUmVjeWNsaW5nKSB7XHJcbiAgICB2YXIgbGFzdFR5cGUgPSBsYXN0Vk5vZGUudHlwZTtcclxuICAgIHZhciBuZXh0VHlwZSA9IG5leHRWTm9kZS50eXBlO1xyXG4gICAgdmFyIGxhc3RLZXkgPSBsYXN0Vk5vZGUua2V5O1xyXG4gICAgdmFyIG5leHRLZXkgPSBuZXh0Vk5vZGUua2V5O1xyXG4gICAgaWYgKGxhc3RUeXBlICE9PSBuZXh0VHlwZSB8fCBsYXN0S2V5ICE9PSBuZXh0S2V5KSB7XHJcbiAgICAgICAgcmVwbGFjZVdpdGhOZXdOb2RlKGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbmV4dFByb3BzID0gbmV4dFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBpZiAoaXNDbGFzcykge1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBsYXN0Vk5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl91cGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5fdW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudERvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VDaGlsZChwYXJlbnREb20sIG1vdW50Q29tcG9uZW50KG5leHRWTm9kZSwgbnVsbCwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRywgKG5leHRWTm9kZS5mbGFncyAmIDQgLyogQ29tcG9uZW50Q2xhc3MgKi8pID4gMCksIGxhc3RWTm9kZS5kb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9ICFpc1VuZGVmaW5lZChpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBjb21wb25lbnQgaGFzIGNvbXBvbmVudERpZFVwZGF0ZSBob29rLCB3ZSBuZWVkIHRvIGNsb25lIGxhc3RTdGF0ZSBvciB3aWxsIGJlIG1vZGlmaWVkIGJ5IHJlZmVyZW5jZSBkdXJpbmcgdXBkYXRlXHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFN0YXRlID0gaGFzQ29tcG9uZW50RGlkVXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjb21iaW5lRnJvbShuZXh0U3RhdGUsIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXh0U3RhdGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFByb3BzID0gaW5zdGFuY2UucHJvcHM7XHJcbiAgICAgICAgICAgICAgICBuZXh0Vk5vZGUuY2hpbGRyZW4gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9pc1NWRyA9IGlzU1ZHO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RJbnB1dCA9IGluc3RhbmNlLl9sYXN0SW5wdXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElucHV0ID0gaW5zdGFuY2UuX3VwZGF0ZUNvbXBvbmVudChsYXN0U3RhdGUsIG5leHRTdGF0ZSwgbGFzdFByb3BzLCBuZXh0UHJvcHMsIGNvbnRleHQsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGJ5IGl0cyBwYXJlbnQgZG8gbm90aGluZywgdGhpcyBpcyBuby1vcFxyXG4gICAgICAgICAgICAgICAgLy8gSXQgY2FuIGhhcHBlbiBieSB1c2luZyBleHRlcm5hbCBjYWxsYmFjayBldGMgZHVyaW5nIHJlbmRlciAvIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl91bm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnQgYmVmb3JlIGdldHRpbmcgY2hpbGQgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ29udGV4dDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZihjaGlsZENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGNvbWJpbmVGcm9tKGNvbnRleHQsIGNoaWxkQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fY2hpbGRDb250ZXh0ID0gY2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW52YWxpZChuZXh0SW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElucHV0ID0gY3JlYXRlVm9pZFZOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0SW5wdXQgPT09IE5PX09QKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElucHV0ID0gbGFzdElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgIGRpZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmdPck51bWJlcihuZXh0SW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElucHV0ID0gY3JlYXRlVGV4dFZOb2RlKG5leHRJbnB1dCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KG5leHRJbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJhIHZhbGlkIEluZmVybm8gVk5vZGUgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQgZnJvbSBhIGNvbXBvbmVudCByZW5kZXIuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCBhbiBhcnJheSBvciBhbiBpbnZhbGlkIG9iamVjdC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG5leHRJbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChuZXh0SW5wdXQuZG9tKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SW5wdXQgPSBkaXJlY3RDbG9uZShuZXh0SW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXh0SW5wdXQuZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0SW5wdXQucGFyZW50Vk5vZGUgPSBuZXh0Vk5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0SW5wdXQuZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5wdXQucGFyZW50Vk5vZGUgPSBuZXh0Vk5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fbGFzdElucHV0ID0gbmV4dElucHV0O1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuX3ZOb2RlID0gbmV4dFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZFVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGxhc3RJbnB1dCwgbmV4dElucHV0LCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY2hpbGRDb250ZXh0LCBpc1NWRywgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUgJiYgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShsYXN0UHJvcHMsIGxhc3RTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuYWZ0ZXJVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWZ0ZXJVcGRhdGUobmV4dFZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmluZERPTU5vZGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFRvRE9NTm9kZU1hcC5zZXQoaW5zdGFuY2UsIG5leHRJbnB1dC5kb20pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHRWTm9kZS5kb20gPSBuZXh0SW5wdXQuZG9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl91cGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBsYXN0UHJvcHMkMSA9IGxhc3RWTm9kZS5wcm9wcztcclxuICAgICAgICAgICAgdmFyIG5leHRIb29rcyA9IG5leHRWTm9kZS5yZWY7XHJcbiAgICAgICAgICAgIHZhciBuZXh0SG9va3NEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobmV4dEhvb2tzKTtcclxuICAgICAgICAgICAgdmFyIGxhc3RJbnB1dCQxID0gbGFzdFZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICB2YXIgbmV4dElucHV0JDEgPSBsYXN0SW5wdXQkMTtcclxuICAgICAgICAgICAgbmV4dFZOb2RlLmRvbSA9IGxhc3RWTm9kZS5kb207XHJcbiAgICAgICAgICAgIG5leHRWTm9kZS5jaGlsZHJlbiA9IGxhc3RJbnB1dCQxO1xyXG4gICAgICAgICAgICBpZiAobGFzdEtleSAhPT0gbmV4dEtleSkge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0SG9va3NEZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzTnVsbE9yVW5kZWYobmV4dEhvb2tzLm9uQ29tcG9uZW50U2hvdWxkVXBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IG5leHRIb29rcy5vbkNvbXBvbmVudFNob3VsZFVwZGF0ZShsYXN0UHJvcHMkMSwgbmV4dFByb3BzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRIb29rc0RlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNOdWxsT3JVbmRlZihuZXh0SG9va3Mub25Db21wb25lbnRXaWxsVXBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRIb29rcy5vbkNvbXBvbmVudFdpbGxVcGRhdGUobGFzdFByb3BzJDEsIG5leHRQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0SW5wdXQkMSA9IG5leHRUeXBlKG5leHRQcm9wcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnZhbGlkKG5leHRJbnB1dCQxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRJbnB1dCQxID0gY3JlYXRlVm9pZFZOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZ09yTnVtYmVyKG5leHRJbnB1dCQxKSAmJiBuZXh0SW5wdXQkMSAhPT0gTk9fT1ApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0SW5wdXQkMSA9IGNyZWF0ZVRleHRWTm9kZShuZXh0SW5wdXQkMSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KG5leHRJbnB1dCQxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcImEgdmFsaWQgSW5mZXJubyBWTm9kZSAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZCBmcm9tIGEgY29tcG9uZW50IHJlbmRlci4gWW91IG1heSBoYXZlIHJldHVybmVkIGFuIGFycmF5IG9yIGFuIGludmFsaWQgb2JqZWN0LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QobmV4dElucHV0JDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobmV4dElucHV0JDEuZG9tKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SW5wdXQkMSA9IGRpcmVjdENsb25lKG5leHRJbnB1dCQxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dElucHV0JDEgIT09IE5PX09QKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobGFzdElucHV0JDEsIG5leHRJbnB1dCQxLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Vk5vZGUuY2hpbGRyZW4gPSBuZXh0SW5wdXQkMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEhvb2tzRGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNOdWxsT3JVbmRlZihuZXh0SG9va3Mub25Db21wb25lbnREaWRVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRIb29rcy5vbkNvbXBvbmVudERpZFVwZGF0ZShsYXN0UHJvcHMkMSwgbmV4dFByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFZOb2RlLmRvbSA9IG5leHRJbnB1dCQxLmRvbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dElucHV0JDEuZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICAgICAgICAgIG5leHRJbnB1dCQxLnBhcmVudFZOb2RlID0gbmV4dFZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RJbnB1dCQxLmZsYWdzICYgMjggLyogQ29tcG9uZW50ICovKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0SW5wdXQkMS5wYXJlbnRWTm9kZSA9IG5leHRWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaFRleHQobGFzdFZOb2RlLCBuZXh0Vk5vZGUpIHtcclxuICAgIHZhciBuZXh0VGV4dCA9IG5leHRWTm9kZS5jaGlsZHJlbjtcclxuICAgIHZhciBkb20gPSBsYXN0Vk5vZGUuZG9tO1xyXG4gICAgbmV4dFZOb2RlLmRvbSA9IGRvbTtcclxuICAgIGlmIChsYXN0Vk5vZGUuY2hpbGRyZW4gIT09IG5leHRUZXh0KSB7XHJcbiAgICAgICAgZG9tLm5vZGVWYWx1ZSA9IG5leHRUZXh0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGNoVm9pZChsYXN0Vk5vZGUsIG5leHRWTm9kZSkge1xyXG4gICAgbmV4dFZOb2RlLmRvbSA9IGxhc3RWTm9kZS5kb207XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hOb25LZXllZENoaWxkcmVuKGxhc3RDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBkb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nLCBsYXN0Q2hpbGRyZW5MZW5ndGgsIG5leHRDaGlsZHJlbkxlbmd0aCkge1xyXG4gICAgdmFyIGNvbW1vbkxlbmd0aCA9IGxhc3RDaGlsZHJlbkxlbmd0aCA+IG5leHRDaGlsZHJlbkxlbmd0aFxyXG4gICAgICAgID8gbmV4dENoaWxkcmVuTGVuZ3RoXHJcbiAgICAgICAgOiBsYXN0Q2hpbGRyZW5MZW5ndGg7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICBmb3IgKDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAobmV4dENoaWxkLmRvbSkge1xyXG4gICAgICAgICAgICBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5baV0gPSBkaXJlY3RDbG9uZShuZXh0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRjaChsYXN0Q2hpbGRyZW5baV0sIG5leHRDaGlsZCwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZyk7XHJcbiAgICB9XHJcbiAgICBpZiAobGFzdENoaWxkcmVuTGVuZ3RoIDwgbmV4dENoaWxkcmVuTGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChpID0gY29tbW9uTGVuZ3RoOyBpIDwgbmV4dENoaWxkcmVuTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG5leHRDaGlsZCQxID0gbmV4dENoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAobmV4dENoaWxkJDEuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0Q2hpbGQkMSA9IG5leHRDaGlsZHJlbltpXSA9IGRpcmVjdENsb25lKG5leHRDaGlsZCQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcHBlbmRDaGlsZChkb20sIG1vdW50KG5leHRDaGlsZCQxLCBudWxsLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFzdENoaWxkcmVuTGVuZ3RoID4gbmV4dENoaWxkcmVuTGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChpID0gY29tbW9uTGVuZ3RoOyBpIDwgbGFzdENoaWxkcmVuTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdW5tb3VudChsYXN0Q2hpbGRyZW5baV0sIGRvbSwgbGlmZWN5Y2xlLCBmYWxzZSwgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaEtleWVkQ2hpbGRyZW4oYSwgYiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZywgYUxlbmd0aCwgYkxlbmd0aCkge1xyXG4gICAgdmFyIGFFbmQgPSBhTGVuZ3RoIC0gMTtcclxuICAgIHZhciBiRW5kID0gYkxlbmd0aCAtIDE7XHJcbiAgICB2YXIgYVN0YXJ0ID0gMDtcclxuICAgIHZhciBiU3RhcnQgPSAwO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBhTm9kZTtcclxuICAgIHZhciBiTm9kZTtcclxuICAgIHZhciBuZXh0Tm9kZTtcclxuICAgIHZhciBuZXh0UG9zO1xyXG4gICAgdmFyIG5vZGU7XHJcbiAgICB2YXIgYVN0YXJ0Tm9kZSA9IGFbYVN0YXJ0XTtcclxuICAgIHZhciBiU3RhcnROb2RlID0gYltiU3RhcnRdO1xyXG4gICAgdmFyIGFFbmROb2RlID0gYVthRW5kXTtcclxuICAgIHZhciBiRW5kTm9kZSA9IGJbYkVuZF07XHJcbiAgICBpZiAoYlN0YXJ0Tm9kZS5kb20pIHtcclxuICAgICAgICBiW2JTdGFydF0gPSBiU3RhcnROb2RlID0gZGlyZWN0Q2xvbmUoYlN0YXJ0Tm9kZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYkVuZE5vZGUuZG9tKSB7XHJcbiAgICAgICAgYltiRW5kXSA9IGJFbmROb2RlID0gZGlyZWN0Q2xvbmUoYkVuZE5vZGUpO1xyXG4gICAgfVxyXG4gICAgLy8gU3RlcCAxXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIG91dGVyOiB7XHJcbiAgICAgICAgLy8gU3luYyBub2RlcyB3aXRoIHRoZSBzYW1lIGtleSBhdCB0aGUgYmVnaW5uaW5nLlxyXG4gICAgICAgIHdoaWxlIChhU3RhcnROb2RlLmtleSA9PT0gYlN0YXJ0Tm9kZS5rZXkpIHtcclxuICAgICAgICAgICAgcGF0Y2goYVN0YXJ0Tm9kZSwgYlN0YXJ0Tm9kZSwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgIGFTdGFydCsrO1xyXG4gICAgICAgICAgICBiU3RhcnQrKztcclxuICAgICAgICAgICAgaWYgKGFTdGFydCA+IGFFbmQgfHwgYlN0YXJ0ID4gYkVuZCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYVN0YXJ0Tm9kZSA9IGFbYVN0YXJ0XTtcclxuICAgICAgICAgICAgYlN0YXJ0Tm9kZSA9IGJbYlN0YXJ0XTtcclxuICAgICAgICAgICAgaWYgKGJTdGFydE5vZGUuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICBiW2JTdGFydF0gPSBiU3RhcnROb2RlID0gZGlyZWN0Q2xvbmUoYlN0YXJ0Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3luYyBub2RlcyB3aXRoIHRoZSBzYW1lIGtleSBhdCB0aGUgZW5kLlxyXG4gICAgICAgIHdoaWxlIChhRW5kTm9kZS5rZXkgPT09IGJFbmROb2RlLmtleSkge1xyXG4gICAgICAgICAgICBwYXRjaChhRW5kTm9kZSwgYkVuZE5vZGUsIGRvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRywgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgICAgICBhRW5kLS07XHJcbiAgICAgICAgICAgIGJFbmQtLTtcclxuICAgICAgICAgICAgaWYgKGFTdGFydCA+IGFFbmQgfHwgYlN0YXJ0ID4gYkVuZCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYUVuZE5vZGUgPSBhW2FFbmRdO1xyXG4gICAgICAgICAgICBiRW5kTm9kZSA9IGJbYkVuZF07XHJcbiAgICAgICAgICAgIGlmIChiRW5kTm9kZS5kb20pIHtcclxuICAgICAgICAgICAgICAgIGJbYkVuZF0gPSBiRW5kTm9kZSA9IGRpcmVjdENsb25lKGJFbmROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhU3RhcnQgPiBhRW5kKSB7XHJcbiAgICAgICAgaWYgKGJTdGFydCA8PSBiRW5kKSB7XHJcbiAgICAgICAgICAgIG5leHRQb3MgPSBiRW5kICsgMTtcclxuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0UG9zIDwgYkxlbmd0aCA/IGJbbmV4dFBvc10uZG9tIDogbnVsbDtcclxuICAgICAgICAgICAgd2hpbGUgKGJTdGFydCA8PSBiRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gYltiU3RhcnRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYltiU3RhcnRdID0gbm9kZSA9IGRpcmVjdENsb25lKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYlN0YXJ0Kys7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRPckFwcGVuZChkb20sIG1vdW50KG5vZGUsIG51bGwsIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpLCBuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiU3RhcnQgPiBiRW5kKSB7XHJcbiAgICAgICAgd2hpbGUgKGFTdGFydCA8PSBhRW5kKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoYVthU3RhcnQrK10sIGRvbSwgbGlmZWN5Y2xlLCBmYWxzZSwgaXNSZWN5Y2xpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBhTGVmdCA9IGFFbmQgLSBhU3RhcnQgKyAxO1xyXG4gICAgICAgIHZhciBiTGVmdCA9IGJFbmQgLSBiU3RhcnQgKyAxO1xyXG4gICAgICAgIHZhciBzb3VyY2VzID0gbmV3IEFycmF5KGJMZWZ0KTtcclxuICAgICAgICAvLyBNYXJrIGFsbCBub2RlcyBhcyBpbnNlcnRlZC5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYkxlZnQ7IGkrKykge1xyXG4gICAgICAgICAgICBzb3VyY2VzW2ldID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBwb3MgPSAwO1xyXG4gICAgICAgIHZhciBwYXRjaGVkID0gMDtcclxuICAgICAgICAvLyBXaGVuIHNpemVzIGFyZSBzbWFsbCwganVzdCBsb29wIHRoZW0gdGhyb3VnaFxyXG4gICAgICAgIGlmIChiTGVmdCA8PSA0IHx8IGFMZWZ0ICogYkxlZnQgPD0gMTYpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gYVN0YXJ0OyBpIDw9IGFFbmQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYU5vZGUgPSBhW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoZWQgPCBiTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGJTdGFydDsgaiA8PSBiRW5kOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYk5vZGUgPSBiW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYU5vZGUua2V5ID09PSBiTm9kZS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNbaiAtIGJTdGFydF0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJOb2RlLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJbal0gPSBiTm9kZSA9IGRpcmVjdENsb25lKGJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoKGFOb2RlLCBiTm9kZSwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVkKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIga2V5SW5kZXggPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIC8vIE1hcCBrZXlzIGJ5IHRoZWlyIGluZGV4IGluIGFycmF5XHJcbiAgICAgICAgICAgIGZvciAoaSA9IGJTdGFydDsgaSA8PSBiRW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGtleUluZGV4LnNldChiW2ldLmtleSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIHBhdGNoIHNhbWUga2V5c1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBhU3RhcnQ7IGkgPD0gYUVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhTm9kZSA9IGFbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA8IGJMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaiA9IGtleUluZGV4LmdldChhTm9kZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYk5vZGUgPSBiW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzW2ogLSBiU3RhcnRdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJOb2RlLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYltqXSA9IGJOb2RlID0gZGlyZWN0Q2xvbmUoYk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoKGFOb2RlLCBiTm9kZSwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoZWQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhc3QtcGF0aDogaWYgbm90aGluZyBwYXRjaGVkIHJlbW92ZSBhbGwgb2xkIGFuZCBhZGQgYWxsIG5ld1xyXG4gICAgICAgIGlmIChhTGVmdCA9PT0gYUxlbmd0aCAmJiBwYXRjaGVkID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUFsbENoaWxkcmVuKGRvbSwgYSwgbGlmZWN5Y2xlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgIHdoaWxlIChiU3RhcnQgPCBiTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGJbYlN0YXJ0XTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJbYlN0YXJ0XSA9IG5vZGUgPSBkaXJlY3RDbG9uZShub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJTdGFydCsrO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmQoZG9tLCBtb3VudChub2RlLCBudWxsLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSBhTGVmdCAtIHBhdGNoZWQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYU5vZGUgPSBhW2FTdGFydCsrXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGFOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoYU5vZGUsIGRvbSwgbGlmZWN5Y2xlLCB0cnVlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IGxpc19hbGdvcml0aG0oc291cmNlcyk7XHJcbiAgICAgICAgICAgICAgICBqID0gc2VxLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBiTGVmdCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNbaV0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGkgKyBiU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiW3Bvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYltwb3NdID0gbm9kZSA9IGRpcmVjdENsb25lKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3MgPSBwb3MgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRPckFwcGVuZChkb20sIG1vdW50KG5vZGUsIG51bGwsIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpLCBuZXh0UG9zIDwgYkxlbmd0aCA/IGJbbmV4dFBvc10uZG9tIDogbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gc2VxW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpICsgYlN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJbcG9zXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3MgPSBwb3MgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmQoZG9tLCBub2RlLmRvbSwgbmV4dFBvcyA8IGJMZW5ndGggPyBiW25leHRQb3NdLmRvbSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGNoZWQgIT09IGJMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHBhdGNoZWQgY291bnQgZG9lc24ndCBtYXRjaCBiIGxlbmd0aCB3ZSBuZWVkIHRvIGluc2VydCB0aG9zZSBuZXcgb25lc1xyXG4gICAgICAgICAgICAgICAgLy8gbG9vcCBiYWNrd2FyZHMgc28gd2UgY2FuIHVzZSBpbnNlcnRCZWZvcmVcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGJMZWZ0IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlc1tpXSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaSArIGJTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJbcG9zXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiW3Bvc10gPSBub2RlID0gZGlyZWN0Q2xvbmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvcyA9IHBvcyArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydE9yQXBwZW5kKGRvbSwgbW91bnQobm9kZSwgbnVsbCwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyksIG5leHRQb3MgPCBiTGVuZ3RoID8gYltuZXh0UG9zXS5kb20gOiBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXHJcbmZ1bmN0aW9uIGxpc19hbGdvcml0aG0oYXJyKSB7XHJcbiAgICB2YXIgcCA9IGFyci5zbGljZSgwKTtcclxuICAgIHZhciByZXN1bHQgPSBbMF07XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIHU7XHJcbiAgICB2YXIgdjtcclxuICAgIHZhciBjO1xyXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2YXIgYXJySSA9IGFycltpXTtcclxuICAgICAgICBpZiAoYXJySSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gKCh1ICsgdikgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gaXNBdHRyQW5FdmVudChhdHRyKSB7XHJcbiAgICByZXR1cm4gYXR0clswXSA9PT0gXCJvXCIgJiYgYXR0clsxXSA9PT0gXCJuXCI7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hQcm9wKHByb3AsIGxhc3RWYWx1ZSwgbmV4dFZhbHVlLCBkb20sIGlzU1ZHLCBoYXNDb250cm9sbGVkVmFsdWUpIHtcclxuICAgIGlmIChsYXN0VmFsdWUgIT09IG5leHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChza2lwUHJvcHMuaGFzKHByb3ApIHx8IChoYXNDb250cm9sbGVkVmFsdWUgJiYgcHJvcCA9PT0gXCJ2YWx1ZVwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5Qcm9wcy5oYXMocHJvcCkpIHtcclxuICAgICAgICAgICAgcHJvcCA9IHByb3AgPT09IFwiYXV0b0ZvY3VzXCIgPyBwcm9wLnRvTG93ZXJDYXNlKCkgOiBwcm9wO1xyXG4gICAgICAgICAgICBkb21bcHJvcF0gPSAhIW5leHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RyaWN0UHJvcHMuaGFzKHByb3ApKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlzTnVsbE9yVW5kZWYobmV4dFZhbHVlKSA/IFwiXCIgOiBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChkb21bcHJvcF0gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkb21bcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0F0dHJBbkV2ZW50KHByb3ApKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRXZlbnQocHJvcCwgbGFzdFZhbHVlLCBuZXh0VmFsdWUsIGRvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbE9yVW5kZWYobmV4dFZhbHVlKSkge1xyXG4gICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9wID09PSBcInN0eWxlXCIpIHtcclxuICAgICAgICAgICAgcGF0Y2hTdHlsZShsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWUuX19odG1sO1xyXG4gICAgICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0VmFsdWUgJiYgbmV4dFZhbHVlLl9faHRtbDtcclxuICAgICAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5leHRIdG1sKSAmJiAhaXNTYW1lSW5uZXJIVE1MKGRvbSwgbmV4dEh0bWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLmlubmVySFRNTCA9IG5leHRIdG1sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZSBvcHRpbWl6ZSBmb3IgTlMgYmVpbmcgYm9vbGVhbi4gSXRzIDk5LjklIHRpbWUgZmFsc2VcclxuICAgICAgICAgICAgaWYgKGlzU1ZHICYmIG5hbWVzcGFjZXMuaGFzKHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBlbmQgdXAgaW4gdGhpcyBwYXRoIHdlIGNhbiByZWFkIHByb3BlcnR5IGFnYWluXHJcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlcy5nZXQocHJvcCksIHByb3AsIG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKHByb3AsIG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hFdmVudChuYW1lLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKSB7XHJcbiAgICBpZiAobGFzdFZhbHVlICE9PSBuZXh0VmFsdWUpIHtcclxuICAgICAgICBpZiAoZGVsZWdhdGVkRXZlbnRzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICBoYW5kbGVFdmVudChuYW1lLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lTG93ZXJDYXNlID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBkb21bbmFtZUxvd2VyQ2FzZV07XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmdW5jdGlvbiBpcyB3cmFwcGVkLCB0aGF0IG1lYW5zIGl0J3MgYmVlbiBjb250cm9sbGVkIGJ5IGEgd3JhcHBlclxyXG4gICAgICAgICAgICBpZiAoZG9tRXZlbnQgJiYgZG9tRXZlbnQud3JhcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihuZXh0VmFsdWUpICYmICFpc051bGxPclVuZGVmKG5leHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5rRXZlbnQgPSBuZXh0VmFsdWUuZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlua0V2ZW50ICYmIGlzRnVuY3Rpb24obGlua0V2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbVtuYW1lTG93ZXJDYXNlXSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtFdmVudChuZXh0VmFsdWUuZGF0YSwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcigoXCJhbiBldmVudCBvbiBhIFZOb2RlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuIHdhcyBub3QgYSBmdW5jdGlvbiBvciBhIHZhbGlkIGxpbmtFdmVudC5cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb21bbmFtZUxvd2VyQ2FzZV0gPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gV2UgYXJlIGFzc3VtaW5nIGhlcmUgdGhhdCB3ZSBjb21lIGZyb20gcGF0Y2hQcm9wIHJvdXRpbmVcclxuLy8gLW5leHRBdHRyVmFsdWUgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkXHJcbmZ1bmN0aW9uIHBhdGNoU3R5bGUobGFzdEF0dHJWYWx1ZSwgbmV4dEF0dHJWYWx1ZSwgZG9tKSB7XHJcbiAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XHJcbiAgICB2YXIgc3R5bGU7XHJcbiAgICB2YXIgdmFsdWU7XHJcbiAgICBpZiAoaXNTdHJpbmcobmV4dEF0dHJWYWx1ZSkpIHtcclxuICAgICAgICBkb21TdHlsZS5jc3NUZXh0ID0gbmV4dEF0dHJWYWx1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFzdEF0dHJWYWx1ZSkgJiYgIWlzU3RyaW5nKGxhc3RBdHRyVmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChzdHlsZSBpbiBuZXh0QXR0clZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBhZGQgYSBoYXNPd25Qcm9wZXJ0eSBjaGVjayBoZXJlLCBpdCBhZmZlY3RzIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICAgIHZhbHVlID0gbmV4dEF0dHJWYWx1ZVtzdHlsZV07XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdEF0dHJWYWx1ZVtzdHlsZV0pIHtcclxuICAgICAgICAgICAgICAgIGRvbVN0eWxlW3N0eWxlXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgIWlzTnVtYmVyKHZhbHVlKSB8fCBpc1VuaXRsZXNzTnVtYmVyLmhhcyhzdHlsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoc3R5bGUgaW4gbGFzdEF0dHJWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZihuZXh0QXR0clZhbHVlW3N0eWxlXSkpIHtcclxuICAgICAgICAgICAgICAgIGRvbVN0eWxlW3N0eWxlXSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKHN0eWxlIGluIG5leHRBdHRyVmFsdWUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBuZXh0QXR0clZhbHVlW3N0eWxlXTtcclxuICAgICAgICAgICAgZG9tU3R5bGVbc3R5bGVdID1cclxuICAgICAgICAgICAgICAgICFpc051bWJlcih2YWx1ZSkgfHwgaXNVbml0bGVzc051bWJlci5oYXMoc3R5bGUpID8gdmFsdWUgOiB2YWx1ZSArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlUHJvcChwcm9wLCBsYXN0VmFsdWUsIGRvbSwgbmV4dEZsYWdzKSB7XHJcbiAgICBpZiAocHJvcCA9PT0gXCJ2YWx1ZVwiKSB7XHJcbiAgICAgICAgLy8gV2hlbiByZW1vdmluZyB2YWx1ZSBvZiBzZWxlY3QgZWxlbWVudCwgaXQgbmVlZHMgdG8gYmUgc2V0IHRvIG51bGwgaW5zdGVhZCBlbXB0eSBzdHJpbmcsIGJlY2F1c2UgZW1wdHkgc3RyaW5nIGlzIHZhbGlkIHZhbHVlIGZvciBvcHRpb24gd2hpY2ggbWFrZXMgdGhhdCBvcHRpb24gc2VsZWN0ZWRcclxuICAgICAgICAvLyBNUyBJRS9FZGdlIGRvbid0IGZvbGxvdyBodG1sIHNwZWMgZm9yIHRleHRBcmVhIGFuZCBpbnB1dCBlbGVtZW50cyBhbmQgd2UgbmVlZCB0byBzZXQgZW1wdHkgc3RyaW5nIHRvIHZhbHVlIGluIHRob3NlIGNhc2VzIHRvIGF2b2lkIFwibnVsbFwiIGFuZCBcInVuZGVmaW5lZFwiIHRleHRzXHJcbiAgICAgICAgZG9tLnZhbHVlID0gbmV4dEZsYWdzICYgMjA0OCAvKiBTZWxlY3RFbGVtZW50ICovID8gbnVsbCA6IFwiXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wID09PSBcInN0eWxlXCIpIHtcclxuICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0F0dHJBbkV2ZW50KHByb3ApKSB7XHJcbiAgICAgICAgaGFuZGxlRXZlbnQocHJvcCwgbGFzdFZhbHVlLCBudWxsLCBkb20pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbmZ1bmN0aW9uIG1vdW50KHZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpIHtcclxuICAgIHZhciBmbGFncyA9IHZOb2RlLmZsYWdzO1xyXG4gICAgaWYgKGZsYWdzICYgMzk3MCAvKiBFbGVtZW50ICovKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vdW50RWxlbWVudCh2Tm9kZSwgcGFyZW50RG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsYWdzICYgMjggLyogQ29tcG9uZW50ICovKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIChmbGFncyAmIDQgLyogQ29tcG9uZW50Q2xhc3MgKi8pID4gMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbGFncyAmIDQwOTYgLyogVm9pZCAqLykge1xyXG4gICAgICAgIHJldHVybiBtb3VudFZvaWQodk5vZGUsIHBhcmVudERvbSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbGFncyAmIDEgLyogVGV4dCAqLykge1xyXG4gICAgICAgIHJldHVybiBtb3VudFRleHQodk5vZGUsIHBhcmVudERvbSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdk5vZGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoKFwibW91bnQoKSByZWNlaXZlZCBhbiBvYmplY3QgdGhhdCdzIG5vdCBhIHZhbGlkIFZOb2RlLCB5b3Ugc2hvdWxkIHN0cmluZ2lmeSBpdCBmaXJzdC4gT2JqZWN0OiBcXFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkodk5vZGUpKSArIFwiXFxcIi5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcigoXCJtb3VudCgpIGV4cGVjdHMgYSB2YWxpZCBWTm9kZSwgaW5zdGVhZCBpdCByZWNlaXZlZCBhbiBvYmplY3Qgd2l0aCB0aGUgdHlwZSBcXFwiXCIgKyAodHlwZW9mIHZOb2RlKSArIFwiXFxcIi5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93RXJyb3IoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtb3VudFRleHQodk5vZGUsIHBhcmVudERvbSkge1xyXG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZOb2RlLmNoaWxkcmVuKTtcclxuICAgIHZOb2RlLmRvbSA9IGRvbTtcclxuICAgIGlmICghaXNOdWxsKHBhcmVudERvbSkpIHtcclxuICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnREb20sIGRvbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9tO1xyXG59XHJcbmZ1bmN0aW9uIG1vdW50Vm9pZCh2Tm9kZSwgcGFyZW50RG9tKSB7XHJcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XHJcbiAgICB2Tm9kZS5kb20gPSBkb207XHJcbiAgICBpZiAoIWlzTnVsbChwYXJlbnREb20pKSB7XHJcbiAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50RG9tLCBkb20pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvbTtcclxufVxyXG5mdW5jdGlvbiBtb3VudEVsZW1lbnQodk5vZGUsIHBhcmVudERvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRykge1xyXG4gICAgdmFyIGRvbTtcclxuICAgIGlmIChvcHRpb25zLnJlY3ljbGluZ0VuYWJsZWQpIHtcclxuICAgICAgICBkb20gPSByZWN5Y2xlRWxlbWVudCh2Tm9kZSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgaWYgKCFpc051bGwoZG9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnREb20pKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnREb20sIGRvbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRvbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgZmxhZ3MgPSB2Tm9kZS5mbGFncztcclxuICAgIGlzU1ZHID0gaXNTVkcgfHwgKGZsYWdzICYgMTI4IC8qIFN2Z0VsZW1lbnQgKi8pID4gMDtcclxuICAgIGRvbSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCh2Tm9kZS50eXBlLCBpc1NWRyk7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbjtcclxuICAgIHZhciBwcm9wcyA9IHZOb2RlLnByb3BzO1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IHZOb2RlLmNsYXNzTmFtZTtcclxuICAgIHZhciByZWYgPSB2Tm9kZS5yZWY7XHJcbiAgICB2Tm9kZS5kb20gPSBkb207XHJcbiAgICBpZiAoIWlzSW52YWxpZChjaGlsZHJlbikpIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmdPck51bWJlcihjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5Jc1NWRyA9IGlzU1ZHID09PSB0cnVlICYmIHZOb2RlLnR5cGUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50QXJyYXlDaGlsZHJlbihjaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGNoaWxkcmVuSXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudChjaGlsZHJlbiwgZG9tLCBsaWZlY3ljbGUsIGNvbnRleHQsIGNoaWxkcmVuSXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc051bGwocHJvcHMpKSB7XHJcbiAgICAgICAgdmFyIGhhc0NvbnRyb2xsZWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpc0Zvcm1FbGVtZW50ID0gKGZsYWdzICYgMzU4NCAvKiBGb3JtRWxlbWVudCAqLykgPiAwO1xyXG4gICAgICAgIGlmIChpc0Zvcm1FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGhhc0NvbnRyb2xsZWRWYWx1ZSA9IGlzQ29udHJvbGxlZEZvcm1FbGVtZW50KHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAvLyBkbyBub3QgYWRkIGEgaGFzT3duUHJvcGVydHkgY2hlY2sgaGVyZSwgaXQgYWZmZWN0cyBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICBwYXRjaFByb3AocHJvcCwgbnVsbCwgcHJvcHNbcHJvcF0sIGRvbSwgaXNTVkcsIGhhc0NvbnRyb2xsZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Zvcm1FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KGZsYWdzLCB2Tm9kZSwgZG9tLCBwcm9wcywgdHJ1ZSwgaGFzQ29udHJvbGxlZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoY2xhc3NOYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTnVsbChyZWYpKSB7XHJcbiAgICAgICAgbW91bnRSZWYoZG9tLCByZWYsIGxpZmVjeWNsZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTnVsbChwYXJlbnREb20pKSB7XHJcbiAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50RG9tLCBkb20pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvbTtcclxufVxyXG5mdW5jdGlvbiBtb3VudEFycmF5Q2hpbGRyZW4oY2hpbGRyZW4sIGRvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRykge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgLy8gVmVyaWZ5IGNhbiBzdHJpbmcvbnVtYmVyIGJlIGhlcmUuIG1pZ2h0IGNhdXNlIGRlLW9wdC4gLSBOb3JtYWxpemF0aW9uIHRha2VzIGNhcmUgb2YgaXQuXHJcbiAgICAgICAgaWYgKCFpc0ludmFsaWQoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20pIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gY2hpbGQgPSBkaXJlY3RDbG9uZShjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW91bnQoY2hpbGRyZW5baV0sIGRvbSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KHZOb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzQ2xhc3MpIHtcclxuICAgIHZhciBkb207XHJcbiAgICBpZiAob3B0aW9ucy5yZWN5Y2xpbmdFbmFibGVkKSB7XHJcbiAgICAgICAgZG9tID0gcmVjeWNsZUNvbXBvbmVudCh2Tm9kZSwgbGlmZWN5Y2xlLCBjb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgaWYgKCFpc051bGwoZG9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnREb20pKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnREb20sIGRvbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRvbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgdHlwZSA9IHZOb2RlLnR5cGU7XHJcbiAgICB2YXIgcHJvcHMgPSB2Tm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICB2YXIgcmVmID0gdk5vZGUucmVmO1xyXG4gICAgaWYgKGlzQ2xhc3MpIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVDbGFzc0NvbXBvbmVudEluc3RhbmNlKHZOb2RlLCB0eXBlLCBwcm9wcywgY29udGV4dCwgaXNTVkcsIGxpZmVjeWNsZSk7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gaW5zdGFuY2UuX2xhc3RJbnB1dDtcclxuICAgICAgICBpbnN0YW5jZS5fdk5vZGUgPSB2Tm9kZTtcclxuICAgICAgICB2Tm9kZS5kb20gPSBkb20gPSBtb3VudChpbnB1dCwgbnVsbCwgbGlmZWN5Y2xlLCBpbnN0YW5jZS5fY2hpbGRDb250ZXh0LCBpc1NWRyk7XHJcbiAgICAgICAgaWYgKCFpc051bGwocGFyZW50RG9tKSkge1xyXG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnREb20sIGRvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vdW50Q2xhc3NDb21wb25lbnRDYWxsYmFja3Modk5vZGUsIHJlZiwgaW5zdGFuY2UsIGxpZmVjeWNsZSk7XHJcbiAgICAgICAgaW5zdGFuY2UuX3VwZGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZmluZERPTU5vZGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFRvRE9NTm9kZU1hcC5zZXQoaW5zdGFuY2UsIGRvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGlucHV0JDEgPSBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50SW5wdXQodk5vZGUsIHR5cGUsIHByb3BzLCBjb250ZXh0KTtcclxuICAgICAgICB2Tm9kZS5kb20gPSBkb20gPSBtb3VudChpbnB1dCQxLCBudWxsLCBsaWZlY3ljbGUsIGNvbnRleHQsIGlzU1ZHKTtcclxuICAgICAgICB2Tm9kZS5jaGlsZHJlbiA9IGlucHV0JDE7XHJcbiAgICAgICAgbW91bnRGdW5jdGlvbmFsQ29tcG9uZW50Q2FsbGJhY2tzKHByb3BzLCByZWYsIGRvbSwgbGlmZWN5Y2xlKTtcclxuICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnREb20pKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZENoaWxkKHBhcmVudERvbSwgZG9tKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9tO1xyXG59XHJcbmZ1bmN0aW9uIG1vdW50Q2xhc3NDb21wb25lbnRDYWxsYmFja3Modk5vZGUsIHJlZiwgaW5zdGFuY2UsIGxpZmVjeWNsZSkge1xyXG4gICAgaWYgKHJlZikge1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcclxuICAgICAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZ09yTnVtYmVyKHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKCdzdHJpbmcgXCJyZWZzXCIgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gSW5mZXJubyAxLjAuIFVzZSBjYWxsYmFjayBcInJlZnNcIiBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QocmVmKSAmJiB2Tm9kZS5mbGFncyAmIDQgLyogQ29tcG9uZW50Q2xhc3MgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiZnVuY3Rpb25hbCBjb21wb25lbnQgbGlmZWN5Y2xlIGV2ZW50cyBhcmUgbm90IHN1cHBvcnRlZCBvbiBFUzIwMTUgY2xhc3MgY29tcG9uZW50cy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKChcImEgYmFkIHZhbHVlIGZvciBcXFwicmVmXFxcIiB3YXMgdXNlZCBvbiBjb21wb25lbnQ6IFxcXCJcIiArIChKU09OLnN0cmluZ2lmeShyZWYpKSArIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3dFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBoYXNEaWRNb3VudCA9ICFpc1VuZGVmaW5lZChpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCk7XHJcbiAgICB2YXIgYWZ0ZXJNb3VudCA9IG9wdGlvbnMuYWZ0ZXJNb3VudDtcclxuICAgIGlmIChoYXNEaWRNb3VudCB8fCAhaXNOdWxsKGFmdGVyTW91bnQpKSB7XHJcbiAgICAgICAgbGlmZWN5Y2xlLmFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuX3VwZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGFmdGVyTW91bnQpIHtcclxuICAgICAgICAgICAgICAgIGFmdGVyTW91bnQodk5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNEaWRNb3VudCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbnN0YW5jZS5fdXBkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtb3VudEZ1bmN0aW9uYWxDb21wb25lbnRDYWxsYmFja3MocHJvcHMsIHJlZiwgZG9tLCBsaWZlY3ljbGUpIHtcclxuICAgIGlmIChyZWYpIHtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYocmVmLm9uQ29tcG9uZW50V2lsbE1vdW50KSkge1xyXG4gICAgICAgICAgICByZWYub25Db21wb25lbnRXaWxsTW91bnQocHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYocmVmLm9uQ29tcG9uZW50RGlkTW91bnQpKSB7XHJcbiAgICAgICAgICAgIGxpZmVjeWNsZS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7IHJldHVybiByZWYub25Db21wb25lbnREaWRNb3VudChkb20sIHByb3BzKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1vdW50UmVmKGRvbSwgdmFsdWUsIGxpZmVjeWNsZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgbGlmZWN5Y2xlLmFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlKGRvbSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzSW52YWxpZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoJ3N0cmluZyBcInJlZnNcIiBhcmUgbm90IHN1cHBvcnRlZCBpbiBJbmZlcm5vIDEuMC4gVXNlIGNhbGxiYWNrIFwicmVmc1wiIGluc3RlYWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93RXJyb3IoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbi8vIFdlIG5lZWQgRU1QVFlfT0JKIGRlZmluZWQgaW4gb25lIHBsYWNlLlxyXG4vLyBJdHMgdXNlZCBmb3IgY29tcGFyaXNvbiBzbyB3ZSBjYW50IGlubGluZSBpdCBpbnRvIHNoYXJlZFxyXG52YXIgRU1QVFlfT0JKID0ge307XHJcbntcclxuICAgIE9iamVjdC5mcmVlemUoRU1QVFlfT0JKKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0NvbXBvbmVudEluc3RhbmNlKHZOb2RlLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCBpc1NWRywgbGlmZWN5Y2xlKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWQoY29udGV4dCkpIHtcclxuICAgICAgICBjb250ZXh0ID0gRU1QVFlfT0JKOyAvLyBDb250ZXh0IHNob3VsZCBub3QgYmUgbXV0YWJsZVxyXG4gICAgfVxyXG4gICAgdmFyIGluc3RhbmNlID0gbmV3IENvbXBvbmVudChwcm9wcywgY29udGV4dCk7XHJcbiAgICB2Tm9kZS5jaGlsZHJlbiA9IGluc3RhbmNlO1xyXG4gICAgaW5zdGFuY2UuX2Jsb2NrU2V0U3RhdGUgPSBmYWxzZTtcclxuICAgIGluc3RhbmNlLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgaWYgKGluc3RhbmNlLnByb3BzID09PSBFTVBUWV9PQkopIHtcclxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0U3RhdGUgY2FsbGJhY2tzIG11c3QgZmlyZSBhZnRlciByZW5kZXIgaXMgZG9uZSB3aGVuIGNhbGxlZCBmcm9tIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgb3IgY29tcG9uZW50V2lsbE1vdW50XHJcbiAgICBpbnN0YW5jZS5fbGlmZWN5Y2xlID0gbGlmZWN5Y2xlO1xyXG4gICAgaW5zdGFuY2UuX3VubW91bnRlZCA9IGZhbHNlO1xyXG4gICAgaW5zdGFuY2UuX2lzU1ZHID0gaXNTVkc7XHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSkge1xyXG4gICAgICAgIGluc3RhbmNlLl9ibG9ja1JlbmRlciA9IHRydWU7XHJcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLl9wZW5kaW5nU2V0U3RhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XHJcbiAgICAgICAgICAgIHZhciBwZW5kaW5nID0gaW5zdGFuY2UuX3BlbmRpbmdTdGF0ZTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IHBlbmRpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBwZW5kaW5nW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5zdGFuY2UuX3BlbmRpbmdTZXRTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5fcGVuZGluZ1N0YXRlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UuX2Jsb2NrUmVuZGVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xyXG4gICAgaWYgKCFpc051bGxPclVuZGVmKGluc3RhbmNlLmdldENoaWxkQ29udGV4dCkpIHtcclxuICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcclxuICAgIH1cclxuICAgIGlmIChpc051bGxPclVuZGVmKGNoaWxkQ29udGV4dCkpIHtcclxuICAgICAgICBpbnN0YW5jZS5fY2hpbGRDb250ZXh0ID0gY29udGV4dDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLl9jaGlsZENvbnRleHQgPSBjb21iaW5lRnJvbShjb250ZXh0LCBjaGlsZENvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc051bGwob3B0aW9ucy5iZWZvcmVSZW5kZXIpKSB7XHJcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVSZW5kZXIoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgdmFyIGlucHV0ID0gaW5zdGFuY2UucmVuZGVyKHByb3BzLCBpbnN0YW5jZS5zdGF0ZSwgY29udGV4dCk7XHJcbiAgICBpZiAoIWlzTnVsbChvcHRpb25zLmFmdGVyUmVuZGVyKSkge1xyXG4gICAgICAgIG9wdGlvbnMuYWZ0ZXJSZW5kZXIoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKFwiYSB2YWxpZCBJbmZlcm5vIFZOb2RlIChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkIGZyb20gYSBjb21wb25lbnQgcmVuZGVyLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgYW4gYXJyYXkgb3IgYW4gaW52YWxpZCBvYmplY3QuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvd0Vycm9yKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0ludmFsaWQoaW5wdXQpKSB7XHJcbiAgICAgICAgaW5wdXQgPSBjcmVhdGVWb2lkVk5vZGUoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nT3JOdW1iZXIoaW5wdXQpKSB7XHJcbiAgICAgICAgaW5wdXQgPSBjcmVhdGVUZXh0Vk5vZGUoaW5wdXQsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGlucHV0LmRvbSkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IGRpcmVjdENsb25lKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0LmZsYWdzICYgMjggLyogQ29tcG9uZW50ICovKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYW4gaW5wdXQgdGhhdCBpcyBhbHNvIGEgY29tcG9uZW50LCB3ZSBydW4gaW50byBhIHRyaWNreSBzaXR1YXRpb25cclxuICAgICAgICAgICAgLy8gd2hlcmUgdGhlIHJvb3Qgdk5vZGUgbmVlZHMgdG8gYWx3YXlzIGhhdmUgdGhlIGNvcnJlY3QgRE9NIGVudHJ5XHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGJyZWFrIG1vbm9tb3JwaGlzbSBvbiBvdXIgaW5wdXQgYW5kIHN1cHBseSBpdCBvdXIgdk5vZGUgYXMgcGFyZW50Vk5vZGVcclxuICAgICAgICAgICAgLy8gd2UgY2FuIG9wdGltaXNlIHRoaXMgaW4gdGhlIGZ1dHVyZSwgYnV0IHRoaXMgZ2V0cyB1cyBvdXQgb2YgYSBsb3Qgb2YgaXNzdWVzXHJcbiAgICAgICAgICAgIGlucHV0LnBhcmVudFZOb2RlID0gdk5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UuX2xhc3RJbnB1dCA9IGlucHV0O1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VMYXN0Q2hpbGRBbmRVbm1vdW50KGxhc3RJbnB1dCwgbmV4dElucHV0LCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nKSB7XHJcbiAgICByZXBsYWNlVk5vZGUocGFyZW50RG9tLCBtb3VudChuZXh0SW5wdXQsIG51bGwsIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpLCBsYXN0SW5wdXQsIGxpZmVjeWNsZSwgaXNSZWN5Y2xpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VWTm9kZShwYXJlbnREb20sIGRvbSwgdk5vZGUsIGxpZmVjeWNsZSwgaXNSZWN5Y2xpbmcpIHtcclxuICAgIHVubW91bnQodk5vZGUsIG51bGwsIGxpZmVjeWNsZSwgZmFsc2UsIGlzUmVjeWNsaW5nKTtcclxuICAgIHJlcGxhY2VDaGlsZChwYXJlbnREb20sIGRvbSwgdk5vZGUuZG9tKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50SW5wdXQodk5vZGUsIGNvbXBvbmVudCwgcHJvcHMsIGNvbnRleHQpIHtcclxuICAgIHZhciBpbnB1dCA9IGNvbXBvbmVudChwcm9wcywgY29udGV4dCk7XHJcbiAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoXCJhIHZhbGlkIEluZmVybm8gVk5vZGUgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQgZnJvbSBhIGNvbXBvbmVudCByZW5kZXIuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCBhbiBhcnJheSBvciBhbiBpbnZhbGlkIG9iamVjdC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93RXJyb3IoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzSW52YWxpZChpbnB1dCkpIHtcclxuICAgICAgICBpbnB1dCA9IGNyZWF0ZVZvaWRWTm9kZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmdPck51bWJlcihpbnB1dCkpIHtcclxuICAgICAgICBpbnB1dCA9IGNyZWF0ZVRleHRWTm9kZShpbnB1dCwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaW5wdXQuZG9tKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gZGlyZWN0Q2xvbmUoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5wdXQuZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBpbnB1dCB0aGF0IGlzIGFsc28gYSBjb21wb25lbnQsIHdlIHJ1biBpbnRvIGEgdHJpY2t5IHNpdHVhdGlvblxyXG4gICAgICAgICAgICAvLyB3aGVyZSB0aGUgcm9vdCB2Tm9kZSBuZWVkcyB0byBhbHdheXMgaGF2ZSB0aGUgY29ycmVjdCBET00gZW50cnlcclxuICAgICAgICAgICAgLy8gc28gd2UgYnJlYWsgbW9ub21vcnBoaXNtIG9uIG91ciBpbnB1dCBhbmQgc3VwcGx5IGl0IG91ciB2Tm9kZSBhcyBwYXJlbnRWTm9kZVxyXG4gICAgICAgICAgICAvLyB3ZSBjYW4gb3B0aW1pc2UgdGhpcyBpbiB0aGUgZnV0dXJlLCBidXQgdGhpcyBnZXRzIHVzIG91dCBvZiBhIGxvdCBvZiBpc3N1ZXNcclxuICAgICAgICAgICAgaW5wdXQucGFyZW50Vk5vZGUgPSB2Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5wdXQ7XHJcbn1cclxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQoZG9tLCB0ZXh0KSB7XHJcbiAgICBpZiAodGV4dCAhPT0gXCJcIikge1xyXG4gICAgICAgIGRvbS50ZXh0Q29udGVudCA9IHRleHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIikpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVRleHRDb250ZW50KGRvbSwgdGV4dCkge1xyXG4gICAgZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcclxufVxyXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnREb20sIGRvbSkge1xyXG4gICAgcGFyZW50RG9tLmFwcGVuZENoaWxkKGRvbSk7XHJcbn1cclxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmQocGFyZW50RG9tLCBuZXdOb2RlLCBuZXh0Tm9kZSkge1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYobmV4dE5vZGUpKSB7XHJcbiAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50RG9tLCBuZXdOb2RlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgbmV4dE5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRvY3VtZW50Q3JlYXRlRWxlbWVudCh0YWcsIGlzU1ZHKSB7XHJcbiAgICBpZiAoaXNTVkcgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBsYWNlV2l0aE5ld05vZGUobGFzdE5vZGUsIG5leHROb2RlLCBwYXJlbnREb20sIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcsIGlzUmVjeWNsaW5nKSB7XHJcbiAgICB1bm1vdW50KGxhc3ROb2RlLCBudWxsLCBsaWZlY3ljbGUsIGZhbHNlLCBpc1JlY3ljbGluZyk7XHJcbiAgICB2YXIgZG9tID0gbW91bnQobmV4dE5vZGUsIG51bGwsIGxpZmVjeWNsZSwgY29udGV4dCwgaXNTVkcpO1xyXG4gICAgbmV4dE5vZGUuZG9tID0gZG9tO1xyXG4gICAgcmVwbGFjZUNoaWxkKHBhcmVudERvbSwgZG9tLCBsYXN0Tm9kZS5kb20pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZChwYXJlbnREb20sIG5ld0RvbSwgbGFzdERvbSkge1xyXG4gICAgaWYgKCFwYXJlbnREb20pIHtcclxuICAgICAgICBwYXJlbnREb20gPSBsYXN0RG9tLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcbiAgICBwYXJlbnREb20ucmVwbGFjZUNoaWxkKG5ld0RvbSwgbGFzdERvbSk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50RG9tLCBkb20pIHtcclxuICAgIHBhcmVudERvbS5yZW1vdmVDaGlsZChkb20pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUFsbENoaWxkcmVuKGRvbSwgY2hpbGRyZW4sIGxpZmVjeWNsZSwgaXNSZWN5Y2xpbmcpIHtcclxuICAgIGlmICghb3B0aW9ucy5yZWN5Y2xpbmdFbmFibGVkIHx8IChvcHRpb25zLnJlY3ljbGluZ0VuYWJsZWQgJiYgIWlzUmVjeWNsaW5nKSkge1xyXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKG51bGwsIGNoaWxkcmVuLCBsaWZlY3ljbGUsIGlzUmVjeWNsaW5nKTtcclxuICAgIH1cclxuICAgIGRvbS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oZG9tLCBjaGlsZHJlbiwgbGlmZWN5Y2xlLCBpc1JlY3ljbGluZykge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKCFpc0ludmFsaWQoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIGRvbSwgbGlmZWN5Y2xlLCB0cnVlLCBpc1JlY3ljbGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzS2V5ZWQobGFzdENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pIHtcclxuICAgIHJldHVybiAobmV4dENoaWxkcmVuLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAhaXNOdWxsT3JVbmRlZihuZXh0Q2hpbGRyZW5bMF0pICYmXHJcbiAgICAgICAgIWlzTnVsbE9yVW5kZWYobmV4dENoaWxkcmVuWzBdLmtleSkgJiZcclxuICAgICAgICBsYXN0Q2hpbGRyZW4ubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICFpc051bGxPclVuZGVmKGxhc3RDaGlsZHJlblswXSkgJiZcclxuICAgICAgICAhaXNOdWxsT3JVbmRlZihsYXN0Q2hpbGRyZW5bMF0ua2V5KSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lSW5uZXJIVE1MKGRvbSwgaW5uZXJIVE1MKSB7XHJcbiAgICB2YXIgdGVtcGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gICAgdGVtcGRvbS5pbm5lckhUTUwgPSBpbm5lckhUTUw7XHJcbiAgICByZXR1cm4gdGVtcGRvbS5pbm5lckhUTUwgPT09IGRvbS5pbm5lckhUTUw7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lUHJvcHNJbm5lckhUTUwoZG9tLCBwcm9wcykge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4ocHJvcHMgJiZcclxuICAgICAgICBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJlxyXG4gICAgICAgIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCAmJlxyXG4gICAgICAgIGlzU2FtZUlubmVySFRNTChkb20sIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm9cclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgdmlydHVhbCBub2RlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xyXG4gKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbnxudWxsfSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGw9fSBjbGFzc05hbWVcclxuICogQHBhcmFtIHtvYmplY3Q9fSBjaGlsZHJlblxyXG4gKiBAcGFyYW0ge29iamVjdD19IHByb3BzXHJcbiAqIEBwYXJhbSB7Kj19IGtleVxyXG4gKiBAcGFyYW0ge29iamVjdHxGdW5jdGlvbj19IHJlZlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub05vcm1hbGlzZVxyXG4gKiBAcmV0dXJucyB7Vk5vZGV9IHJldHVybnMgbmV3IHZpcnR1YWwgbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlVk5vZGUoZmxhZ3MsIHR5cGUsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHByb3BzLCBrZXksIHJlZiwgbm9Ob3JtYWxpc2UpIHtcclxuICAgIGlmIChmbGFncyAmIDE2IC8qIENvbXBvbmVudFVua25vd24gKi8pIHtcclxuICAgICAgICBmbGFncyA9IGlzU3RhdGVmdWxDb21wb25lbnQodHlwZSlcclxuICAgICAgICAgICAgPyA0IC8qIENvbXBvbmVudENsYXNzICovXHJcbiAgICAgICAgICAgIDogOCAvKiBDb21wb25lbnRGdW5jdGlvbiAqLztcclxuICAgIH1cclxuICAgIHZhciB2Tm9kZSA9IHtcclxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4gPT09IHZvaWQgMCA/IG51bGwgOiBjaGlsZHJlbixcclxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IGNsYXNzTmFtZSxcclxuICAgICAgICBkb206IG51bGwsXHJcbiAgICAgICAgZmxhZ3M6IGZsYWdzLFxyXG4gICAgICAgIGtleToga2V5ID09PSB2b2lkIDAgPyBudWxsIDoga2V5LFxyXG4gICAgICAgIHByb3BzOiBwcm9wcyA9PT0gdm9pZCAwID8gbnVsbCA6IHByb3BzLFxyXG4gICAgICAgIHJlZjogcmVmID09PSB2b2lkIDAgPyBudWxsIDogcmVmLFxyXG4gICAgICAgIHR5cGU6IHR5cGVcclxuICAgIH07XHJcbiAgICBpZiAobm9Ob3JtYWxpc2UgIT09IHRydWUpIHtcclxuICAgICAgICBub3JtYWxpemUodk5vZGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlVk5vZGUgIT09IG51bGwpIHtcclxuICAgICAgICBvcHRpb25zLmNyZWF0ZVZOb2RlKHZOb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2Tm9kZTtcclxufVxyXG5mdW5jdGlvbiBkaXJlY3RDbG9uZSh2Tm9kZVRvQ2xvbmUpIHtcclxuICAgIHZhciBuZXdWTm9kZTtcclxuICAgIHZhciBmbGFncyA9IHZOb2RlVG9DbG9uZS5mbGFncztcclxuICAgIGlmIChmbGFncyAmIDI4IC8qIENvbXBvbmVudCAqLykge1xyXG4gICAgICAgIHZhciBwcm9wcztcclxuICAgICAgICB2YXIgcHJvcHNUb0Nsb25lID0gdk5vZGVUb0Nsb25lLnByb3BzO1xyXG4gICAgICAgIGlmIChpc051bGwocHJvcHNUb0Nsb25lKSkge1xyXG4gICAgICAgICAgICBwcm9wcyA9IEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByb3BzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvQ2xvbmUpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSBwcm9wc1RvQ2xvbmVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdWTm9kZSA9IGNyZWF0ZVZOb2RlKGZsYWdzLCB2Tm9kZVRvQ2xvbmUudHlwZSwgbnVsbCwgbnVsbCwgcHJvcHMsIHZOb2RlVG9DbG9uZS5rZXksIHZOb2RlVG9DbG9uZS5yZWYsIHRydWUpO1xyXG4gICAgICAgIHZhciBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xyXG4gICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYWxzbyBjbG9uZSBjb21wb25lbnQgY2hpbGRyZW4gdGhhdCBhcmUgaW4gcHJvcHNcclxuICAgICAgICAvLyBhcyB0aGUgY2hpbGRyZW4gbWF5IGFsc28gaGF2ZSBiZWVuIGhvaXN0ZWRcclxuICAgICAgICBpZiAobmV3Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gbmV3Q2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmdPck51bWJlcihjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEFycmF5LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ludmFsaWQoY2hpbGQpICYmIGlzVk5vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBBcnJheS5wdXNoKGRpcmVjdENsb25lKGNoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMuY2hpbGRyZW4gPSB0bXBBcnJheTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1ZOb2RlKG5ld0NoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvcHMuY2hpbGRyZW4gPSBkaXJlY3RDbG9uZShuZXdDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3Vk5vZGUuY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmxhZ3MgJiAzOTcwIC8qIEVsZW1lbnQgKi8pIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZVRvQ2xvbmUuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIHByb3BzJDE7XHJcbiAgICAgICAgdmFyIHByb3BzVG9DbG9uZSQxID0gdk5vZGVUb0Nsb25lLnByb3BzO1xyXG4gICAgICAgIGlmIChwcm9wc1RvQ2xvbmUkMSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcm9wcyQxID0gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJvcHMkMSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkkMSBpbiBwcm9wc1RvQ2xvbmUkMSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMkMVtrZXkkMV0gPSBwcm9wc1RvQ2xvbmUkMVtrZXkkMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3Vk5vZGUgPSBjcmVhdGVWTm9kZShmbGFncywgdk5vZGVUb0Nsb25lLnR5cGUsIHZOb2RlVG9DbG9uZS5jbGFzc05hbWUsIGNoaWxkcmVuLCBwcm9wcyQxLCB2Tm9kZVRvQ2xvbmUua2V5LCB2Tm9kZVRvQ2xvbmUucmVmLCAhY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmxhZ3MgJiAxIC8qIFRleHQgKi8pIHtcclxuICAgICAgICBuZXdWTm9kZSA9IGNyZWF0ZVRleHRWTm9kZSh2Tm9kZVRvQ2xvbmUuY2hpbGRyZW4sIHZOb2RlVG9DbG9uZS5rZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1ZOb2RlO1xyXG59XHJcbi8qXHJcbiBkaXJlY3RDbG9uZSBpcyBwcmVmZXJyZWQgb3ZlciBjbG9uZVZOb2RlIGFuZCB1c2VkIGludGVybmFsbHkgYWxzby5cclxuIFRoaXMgZnVuY3Rpb24gbWFrZXMgSW5mZXJubyBiYWNrd2FyZHMgY29tcGF0aWJsZS5cclxuIEFuZCBjYW4gYmUgdHJlZS1zaGFrZWQgYnkgbW9kZXJuIGJ1bmRsZXJzXHJcblxuIFdvdWxkIGJlIG5pY2UgdG8gY29tYmluZSB0aGlzIHdpdGggZGlyZWN0Q2xvbmUgYnV0IGNvdWxkIG5vdCBkbyBpdCB3aXRob3V0IGJyZWFraW5nIGNoYW5nZVxyXG4gKi9cclxuLyoqXHJcbiAqIENsb25lcyBnaXZlbiB2aXJ0dWFsIG5vZGUgYnkgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIGl0XHJcbiAqIEBwYXJhbSB7Vk5vZGV9IHZOb2RlVG9DbG9uZSB2aXJ0dWFsIG5vZGUgdG8gYmUgY2xvbmVkXHJcbiAqIEBwYXJhbSB7UHJvcHM9fSBwcm9wcyBhZGRpdGlvbmFsIHByb3BzIGZvciBuZXcgdmlydHVhbCBub2RlXHJcbiAqIEBwYXJhbSB7Li4uKn0gX2NoaWxkcmVuIG5ldyBjaGlsZHJlbiBmb3IgbmV3IHZpcnR1YWwgbm9kZVxyXG4gKiBAcmV0dXJucyB7Vk5vZGV9IG5ldyB2aXJ0dWFsIG5vZGVcclxuICovXHJcbmZ1bmN0aW9uIGNsb25lVk5vZGUodk5vZGVUb0Nsb25lLCBwcm9wcykge1xuICAgIHZhciBfY2hpbGRyZW4gPSBbXSwgbGVuJDIgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICB3aGlsZSAoIGxlbiQyLS0gPiAwICkgX2NoaWxkcmVuWyBsZW4kMiBdID0gYXJndW1lbnRzWyBsZW4kMiArIDIgXTtcblxyXG4gICAgdmFyIGNoaWxkcmVuID0gX2NoaWxkcmVuO1xyXG4gICAgdmFyIGNoaWxkcmVuTGVuID0gX2NoaWxkcmVuLmxlbmd0aDtcclxuICAgIGlmIChjaGlsZHJlbkxlbiA+IDAgJiYgIWlzVW5kZWZpbmVkKF9jaGlsZHJlblswXSkpIHtcclxuICAgICAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgICAgIHByb3BzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGlsZHJlbkxlbiA9PT0gMSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IF9jaGlsZHJlblswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgbmV3Vk5vZGU7XHJcbiAgICBpZiAoaXNBcnJheSh2Tm9kZVRvQ2xvbmUpKSB7XHJcbiAgICAgICAgdmFyIHRtcEFycmF5ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZOb2RlVG9DbG9uZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0bXBBcnJheS5wdXNoKGRpcmVjdENsb25lKHZOb2RlVG9DbG9uZVtpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdWTm9kZSA9IHRtcEFycmF5O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGZsYWdzID0gdk5vZGVUb0Nsb25lLmZsYWdzO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB2Tm9kZVRvQ2xvbmUuY2xhc3NOYW1lO1xyXG4gICAgICAgIHZhciBrZXkgPSB2Tm9kZVRvQ2xvbmUua2V5O1xyXG4gICAgICAgIHZhciByZWYgPSB2Tm9kZVRvQ2xvbmUucmVmO1xyXG4gICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoXCJjbGFzc05hbWVcIikpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoXCJyZWZcIikpIHtcclxuICAgICAgICAgICAgICAgIHJlZiA9IHByb3BzLnJlZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IHByb3BzLmtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICAgICAgbmV3Vk5vZGUgPSBjcmVhdGVWTm9kZShmbGFncywgdk5vZGVUb0Nsb25lLnR5cGUsIGNsYXNzTmFtZSwgbnVsbCwgIXZOb2RlVG9DbG9uZS5wcm9wcyAmJiAhcHJvcHNcclxuICAgICAgICAgICAgICAgID8gRU1QVFlfT0JKXHJcbiAgICAgICAgICAgICAgICA6IGNvbWJpbmVGcm9tKHZOb2RlVG9DbG9uZS5wcm9wcywgcHJvcHMpLCBrZXksIHJlZiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xyXG4gICAgICAgICAgICBpZiAobmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhbHNvIGNsb25lIGNvbXBvbmVudCBjaGlsZHJlbiB0aGF0IGFyZSBpbiBwcm9wc1xyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNoaWxkcmVuIG1heSBhbHNvIGhhdmUgYmVlbiBob2lzdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShuZXdDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiQxID0gbmV3Q2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuJDEgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wQXJyYXkkMSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGVuJDE7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baSQxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmdPck51bWJlcihjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wQXJyYXkkMS5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzSW52YWxpZChjaGlsZCkgJiYgaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wQXJyYXkkMS5wdXNoKGRpcmVjdENsb25lKGNoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMuY2hpbGRyZW4gPSB0bXBBcnJheSQxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVk5vZGUobmV3Q2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLmNoaWxkcmVuID0gZGlyZWN0Q2xvbmUobmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdWTm9kZS5jaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZsYWdzICYgMzk3MCAvKiBFbGVtZW50ICovKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID1cclxuICAgICAgICAgICAgICAgIHByb3BzICYmICFpc1VuZGVmaW5lZChwcm9wcy5jaGlsZHJlbilcclxuICAgICAgICAgICAgICAgICAgICA/IHByb3BzLmNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgICAgOiB2Tm9kZVRvQ2xvbmUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIG5ld1ZOb2RlID0gY3JlYXRlVk5vZGUoZmxhZ3MsIHZOb2RlVG9DbG9uZS50eXBlLCBjbGFzc05hbWUsIGNoaWxkcmVuLCAhdk5vZGVUb0Nsb25lLnByb3BzICYmICFwcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBFTVBUWV9PQkpcclxuICAgICAgICAgICAgICAgIDogY29tYmluZUZyb20odk5vZGVUb0Nsb25lLnByb3BzLCBwcm9wcyksIGtleSwgcmVmLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZsYWdzICYgMSAvKiBUZXh0ICovKSB7XHJcbiAgICAgICAgICAgIG5ld1ZOb2RlID0gY3JlYXRlVGV4dFZOb2RlKHZOb2RlVG9DbG9uZS5jaGlsZHJlbiwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3Vk5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVm9pZFZOb2RlKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKDQwOTYgLyogVm9pZCAqLywgbnVsbCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQsIGtleSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKDEgLyogVGV4dCAqLywgbnVsbCwgbnVsbCwgdGV4dCwgbnVsbCwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZOb2RlKG8pIHtcclxuICAgIHJldHVybiAhIW8uZmxhZ3M7XHJcbn1cblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJub1xyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG5mdW5jdGlvbiBhcHBseUtleShrZXksIHZOb2RlKSB7XHJcbiAgICB2Tm9kZS5rZXkgPSBrZXk7XHJcbiAgICByZXR1cm4gdk5vZGU7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlLZXlJZk1pc3Npbmcoa2V5LCB2Tm9kZSkge1xyXG4gICAgaWYgKGlzTnVtYmVyKGtleSkpIHtcclxuICAgICAgICBrZXkgPSBcIi5cIiArIGtleTtcclxuICAgIH1cclxuICAgIGlmIChpc051bGwodk5vZGUua2V5KSB8fCB2Tm9kZS5rZXlbMF0gPT09IFwiLlwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5S2V5KGtleSwgdk5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZOb2RlO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5S2V5UHJlZml4KGtleSwgdk5vZGUpIHtcclxuICAgIHZOb2RlLmtleSA9IGtleSArIHZOb2RlLmtleTtcclxuICAgIHJldHVybiB2Tm9kZTtcclxufVxyXG5mdW5jdGlvbiBfbm9ybWFsaXplVk5vZGVzKG5vZGVzLCByZXN1bHQsIGluZGV4LCBjdXJyZW50S2V5KSB7XHJcbiAgICBmb3IgKHZhciBsZW4gPSBub2Rlcy5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XHJcbiAgICAgICAgdmFyIG4gPSBub2Rlc1tpbmRleF07XHJcbiAgICAgICAgdmFyIGtleSA9IGN1cnJlbnRLZXkgKyBcIi5cIiArIGluZGV4O1xyXG4gICAgICAgIGlmICghaXNJbnZhbGlkKG4pKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG4pKSB7XHJcbiAgICAgICAgICAgICAgICBfbm9ybWFsaXplVk5vZGVzKG4sIHJlc3VsdCwgMCwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZ09yTnVtYmVyKG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGNyZWF0ZVRleHRWTm9kZShuLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChpc1ZOb2RlKG4pICYmIG4uZG9tKSB8fCAobi5rZXkgJiYgbi5rZXlbMF0gPT09IFwiLlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBkaXJlY3RDbG9uZShuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwobi5rZXkpIHx8IG4ua2V5WzBdID09PSBcIi5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBhcHBseUtleShrZXksIG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGFwcGx5S2V5UHJlZml4KGN1cnJlbnRLZXksIG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGVzKG5vZGVzKSB7XHJcbiAgICB2YXIgbmV3Tm9kZXM7XHJcbiAgICAvLyB3ZSBhc3NpZ24gJCB3aGljaCBiYXNpY2FsbHkgbWVhbnMgd2UndmUgZmxhZ2dlZCB0aGlzIGFycmF5IGZvciBmdXR1cmUgbm90ZVxyXG4gICAgLy8gaWYgaXQgY29tZXMgYmFjayBhZ2Fpbiwgd2UgbmVlZCB0byBjbG9uZSBpdCwgYXMgcGVvcGxlIGFyZSB1c2luZyBpdFxyXG4gICAgLy8gaW4gYW4gaW1tdXRhYmxlIHdheVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGVcclxuICAgIGlmIChub2Rlc1tcIiRcIl0gPT09IHRydWUpIHtcclxuICAgICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBub2Rlc1tcIiRcIl0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gdHNsaW50OmVuYWJsZVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcclxuICAgICAgICBpZiAoaXNJbnZhbGlkKG4pIHx8IGlzQXJyYXkobikpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IChuZXdOb2RlcyB8fCBub2Rlcykuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgICAgIF9ub3JtYWxpemVWTm9kZXMobm9kZXMsIHJlc3VsdCwgaSwgXCJcIik7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nT3JOdW1iZXIobikpIHtcclxuICAgICAgICAgICAgaWYgKCFuZXdOb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMgPSBub2Rlcy5zbGljZSgwLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGFwcGx5S2V5SWZNaXNzaW5nKGksIGNyZWF0ZVRleHRWTm9kZShuLCBudWxsKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoaXNWTm9kZShuKSAmJiBuLmRvbSAhPT0gbnVsbCkgfHxcclxuICAgICAgICAgICAgKGlzTnVsbChuLmtleSkgJiYgKG4uZmxhZ3MgJiA2NCAvKiBIYXNOb25LZXllZENoaWxkcmVuICovKSA9PT0gMCkpIHtcclxuICAgICAgICAgICAgaWYgKCFuZXdOb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMgPSBub2Rlcy5zbGljZSgwLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGFwcGx5S2V5SWZNaXNzaW5nKGksIGRpcmVjdENsb25lKG4pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld05vZGVzKSB7XHJcbiAgICAgICAgICAgIG5ld05vZGVzLnB1c2goYXBwbHlLZXlJZk1pc3NpbmcoaSwgZGlyZWN0Q2xvbmUobikpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3Tm9kZXMgfHwgbm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcclxuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVWTm9kZXMoY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNWTm9kZShjaGlsZHJlbikgJiYgY2hpbGRyZW4uZG9tICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdENsb25lKGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyh2Tm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XHJcbiAgICBpZiAodk5vZGUuZmxhZ3MgJiAzOTcwIC8qIEVsZW1lbnQgKi8pIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZihjaGlsZHJlbikgJiYgcHJvcHMuaGFzT3duUHJvcGVydHkoXCJjaGlsZHJlblwiKSkge1xyXG4gICAgICAgICAgICB2Tm9kZS5jaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoXCJjbGFzc05hbWVcIikpIHtcclxuICAgICAgICAgICAgdk5vZGUuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lIHx8IG51bGw7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wcy5jbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KFwicmVmXCIpKSB7XHJcbiAgICAgICAgdk5vZGUucmVmID0gcHJvcHMucmVmO1xyXG4gICAgICAgIGRlbGV0ZSBwcm9wcy5yZWY7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpIHtcclxuICAgICAgICB2Tm9kZS5rZXkgPSBwcm9wcy5rZXk7XHJcbiAgICAgICAgZGVsZXRlIHByb3BzLmtleTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRGbGFnc0ZvckVsZW1lbnRWbm9kZSh0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gXCJzdmdcIikge1xyXG4gICAgICAgIHJldHVybiAxMjggLyogU3ZnRWxlbWVudCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiaW5wdXRcIikge1xyXG4gICAgICAgIHJldHVybiA1MTIgLyogSW5wdXRFbGVtZW50ICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJzZWxlY3RcIikge1xyXG4gICAgICAgIHJldHVybiAyMDQ4IC8qIFNlbGVjdEVsZW1lbnQgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSBcInRleHRhcmVhXCIpIHtcclxuICAgICAgICByZXR1cm4gMTAyNCAvKiBUZXh0YXJlYUVsZW1lbnQgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSBcIm1lZGlhXCIpIHtcclxuICAgICAgICByZXR1cm4gMjU2IC8qIE1lZGlhRWxlbWVudCAqLztcclxuICAgIH1cclxuICAgIHJldHVybiAyIC8qIEh0bWxFbGVtZW50ICovO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZSh2Tm9kZSkge1xyXG4gICAgdmFyIHByb3BzID0gdk5vZGUucHJvcHM7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbjtcclxuICAgIC8vIGNvbnZlcnQgYSB3cm9uZ2x5IGNyZWF0ZWQgdHlwZSBiYWNrIHRvIGVsZW1lbnRcclxuICAgIC8vIFByaW1pdGl2ZSBub2RlIGRvZXNuJ3QgaGF2ZSBkZWZhdWx0UHJvcHMsIG9ubHkgQ29tcG9uZW50XHJcbiAgICBpZiAodk5vZGUuZmxhZ3MgJiAyOCAvKiBDb21wb25lbnQgKi8pIHtcclxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBwcm9wc1xyXG4gICAgICAgIHZhciB0eXBlID0gdk5vZGUudHlwZTtcclxuICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XHJcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKGRlZmF1bHRQcm9wcykpIHtcclxuICAgICAgICAgICAgaWYgKCFwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB2Tm9kZS5wcm9wcyA9IGRlZmF1bHRQcm9wczsgLy8gQ3JlYXRlIG5ldyBvYmplY3QgaWYgb25seSBkZWZhdWx0UHJvcHMgZ2l2ZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHByb3BzW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twcm9wXSA9IGRlZmF1bHRQcm9wc1twcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHZOb2RlLmZsYWdzID0gZ2V0RmxhZ3NGb3JFbGVtZW50Vm5vZGUodHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgdk5vZGUuY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICBub3JtYWxpemVQcm9wcyh2Tm9kZSwgcHJvcHMsIGNoaWxkcmVuKTtcclxuICAgICAgICBpZiAoIWlzSW52YWxpZChwcm9wcy5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc0ludmFsaWQoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdk5vZGUuY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICB7XHJcbiAgICAgICAgLy8gVGhpcyBjb2RlIHdpbGwgYmUgc3RyaXBwZWQgb3V0IGZyb20gcHJvZHVjdGlvbiBDT0RFXHJcbiAgICAgICAgLy8gSXQgaGVscHMgdXNlcnMgdG8gdHJhY2sgZXJyb3JzIGluIHRoZWlyIGFwcGxpY2F0aW9ucy5cclxuICAgICAgICB2YXIgdmVyaWZ5S2V5cyA9IGZ1bmN0aW9uICh2Tm9kZXMpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlcyA9IHZOb2Rlcy5tYXAoZnVuY3Rpb24gKHZub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGUua2V5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAga2V5VmFsdWVzLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0R1cGxpY2F0ZSA9IGtleVZhbHVlcy5pbmRleE9mKGl0ZW0pICE9PSBpZHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHVwbGljYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZyhcIkluZmVybm8gbm9ybWFsaXNhdGlvbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCBzYW1lIGtleSwgYWxsIGtleXMgbXVzdCBiZSB1bmlxdWUgd2l0aGluIGl0cyBzaWJsaW5ncy4gRHVwbGljYXRlZCBrZXkgaXM6XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNEdXBsaWNhdGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHZOb2RlLmNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkodk5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIHZlcmlmeUtleXModk5vZGUuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbi8qKlxyXG4gKiBMaW5rcyBnaXZlbiBkYXRhIHRvIGV2ZW50IGFzIGZpcnN0IHBhcmFtZXRlclxyXG4gKiBAcGFyYW0geyp9IGRhdGEgZGF0YSB0byBiZSBsaW5rZWQsIGl0IHdpbGwgYmUgYXZhaWxhYmxlIGluIGZ1bmN0aW9uIGFzIGZpcnN0IHBhcmFtZXRlclxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudCBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBldmVudCBvY2N1cnNcclxuICogQHJldHVybnMge3tkYXRhOiAqLCBldmVudDogRnVuY3Rpb259fVxyXG4gKi9cclxuZnVuY3Rpb24gbGlua0V2ZW50KGRhdGEsIGV2ZW50KSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihldmVudCkpIHtcclxuICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBldmVudDogZXZlbnQgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsOyAvLyBSZXR1cm4gbnVsbCB3aGVuIGV2ZW50IGlzIGludmFsaWQsIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzXHJcbn1cblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJub1xyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXMgKi9cclxue1xyXG4gICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5ICovXHJcbiAgICB2YXIgdGVzdEZ1bmMgPSBmdW5jdGlvbiB0ZXN0Rm4oKSB7IH07XHJcbiAgICBpZiAoKHRlc3RGdW5jLm5hbWUgfHwgdGVzdEZ1bmMudG9TdHJpbmcoKSkuaW5kZXhPZihcInRlc3RGblwiKSA9PT1cclxuICAgICAgICAtMSkge1xyXG4gICAgICAgIHdhcm5pbmcoXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyBhIG1pbmlmaWVkIGNvcHkgb2YgdGhlIGRldmVsb3BtZW50IGJ1aWxkIFwiICtcclxuICAgICAgICAgICAgXCJvZiBJbmZlcm5vLiBXaGVuIGRlcGxveWluZyBJbmZlcm5vIGFwcHMgdG8gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRvIHVzZSBcIiArXHJcbiAgICAgICAgICAgIFwidGhlIHByb2R1Y3Rpb24gYnVpbGQgd2hpY2ggc2tpcHMgZGV2ZWxvcG1lbnQgd2FybmluZ3MgYW5kIGlzIGZhc3Rlci4gXCIgK1xyXG4gICAgICAgICAgICBcIlNlZSBodHRwOi8vaW5mZXJub2pzLm9yZyBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcclxuICAgIH1cclxufVxyXG52YXIgdmVyc2lvbiA9IFwiMy45LjBcIjtcclxuLy8gd2UgZHVwbGljYXRlIGl0IHNvIGl0IHBsYXlzIG5pY2VseSB3aXRoIGRpZmZlcmVudCBtb2R1bGUgbG9hZGluZyBzeXN0ZW1zXHJcbnZhciBpbmRleCA9IHtcclxuICAgIEVNUFRZX09CSjogRU1QVFlfT0JKLFxyXG4gICAgTk9fT1A6IE5PX09QLFxyXG4gICAgY2xvbmVWTm9kZTogY2xvbmVWTm9kZSxcclxuICAgIGNyZWF0ZVJlbmRlcmVyOiBjcmVhdGVSZW5kZXJlcixcclxuICAgIGNyZWF0ZVZOb2RlOiBjcmVhdGVWTm9kZSxcclxuICAgIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcclxuICAgIGdldEZsYWdzRm9yRWxlbWVudFZub2RlOiBnZXRGbGFnc0ZvckVsZW1lbnRWbm9kZSxcclxuICAgIGludGVybmFsX0RPTU5vZGVNYXA6IGNvbXBvbmVudFRvRE9NTm9kZU1hcCxcclxuICAgIGludGVybmFsX2lzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXHJcbiAgICBpbnRlcm5hbF9ub3JtYWxpemU6IG5vcm1hbGl6ZSxcclxuICAgIGludGVybmFsX3BhdGNoOiBwYXRjaCxcclxuICAgIGxpbmtFdmVudDogbGlua0V2ZW50LFxyXG4gICAgb3B0aW9uczogb3B0aW9ucyxcclxuICAgIHJlbmRlcjogcmVuZGVyLFxyXG4gICAgdmVyc2lvbjogdmVyc2lvblxyXG59O1xuXG5leHBvcnQgeyBFTVBUWV9PQkosIE5PX09QLCBjbG9uZVZOb2RlLCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlVk5vZGUsIGZpbmRET01Ob2RlLCBnZXRGbGFnc0ZvckVsZW1lbnRWbm9kZSwgY29tcG9uZW50VG9ET01Ob2RlTWFwIGFzIGludGVybmFsX0RPTU5vZGVNYXAsIGlzVW5pdGxlc3NOdW1iZXIgYXMgaW50ZXJuYWxfaXNVbml0bGVzc051bWJlciwgbm9ybWFsaXplIGFzIGludGVybmFsX25vcm1hbGl6ZSwgcGF0Y2ggYXMgaW50ZXJuYWxfcGF0Y2gsIGxpbmtFdmVudCwgb3B0aW9ucywgcmVuZGVyLCB2ZXJzaW9uIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsImltcG9ydCB7IEVNUFRZX09CSiwgY3JlYXRlVk5vZGUsIGludGVybmFsX0RPTU5vZGVNYXAsIGludGVybmFsX3BhdGNoLCBvcHRpb25zIH0gZnJvbSAnaW5mZXJubyc7XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tU2hhcmVkXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbnZhciBOT19PUCA9IFwiJE5PX09QXCI7XHJcbnZhciBFUlJPUl9NU0cgPSBcImEgcnVudGltZSBlcnJvciBvY2N1cmVkISBVc2UgSW5mZXJubyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudCB0byBmaW5kIHRoZSBlcnJvci5cIjtcclxuLy8gdGhpcyBpcyBNVUNIIGZhc3RlciB0aGFuIC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgYW5kIGluc3RhbmNlb2YgQXJyYXlcclxuLy8gaW4gTm9kZSA3IGFuZCB0aGUgbGF0ZXIgdmVyc2lvbnMgb2YgVjgsIHNsb3dlciBpbiBvbGRlciB2ZXJzaW9ucyB0aG91Z2hcclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5mdW5jdGlvbiBpc1N0cmluZ09yTnVtYmVyKG8pIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIG87XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYobykge1xyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKG8pIHx8IGlzTnVsbChvKTtcclxufVxyXG5mdW5jdGlvbiBpc0ludmFsaWQobykge1xyXG4gICAgcmV0dXJuIGlzTnVsbChvKSB8fCBvID09PSBmYWxzZSB8fCBpc1RydWUobykgfHwgaXNVbmRlZmluZWQobyk7XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihvKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5mdW5jdGlvbiBpc051bGwobykge1xyXG4gICAgcmV0dXJuIG8gPT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNUcnVlKG8pIHtcclxuICAgIHJldHVybiBvID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcclxuICAgIHJldHVybiBvID09PSB2b2lkIDA7XHJcbn1cclxuZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlKSB7XHJcbiAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgICBtZXNzYWdlID0gRVJST1JfTVNHO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKChcIkluZmVybm8gRXJyb3I6IFwiICsgbWVzc2FnZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbWJpbmVGcm9tKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgIHZhciBvdXQgPSB7fTtcclxuICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xyXG4gICAgICAgICAgICBvdXRba2V5XSA9IGZpcnN0W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlY29uZCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSQxIGluIHNlY29uZCkge1xyXG4gICAgICAgICAgICBvdXRba2V5JDFdID0gc2Vjb25kW2tleSQxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tQ29tcG9uZW50XHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbi8vIE1ha2Ugc3VyZSB1IHVzZSBFTVBUWV9PQkogZnJvbSAnaW5mZXJubycsIG90aGVyd2lzZSBpdCdsbCBiZSBhIGRpZmZlcmVudCByZWZlcmVuY2VcclxudmFyIG5vT3AgPSBFUlJPUl9NU0c7XHJcbntcclxuICAgIG5vT3AgPVxyXG4gICAgICAgIFwiSW5mZXJubyBFcnJvcjogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkIHNldFN0YXRlKCkgb3IgZm9yY2VVcGRhdGUoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiBUaGlzIGlzIGEgbm8tb3AuXCI7XHJcbn1cclxudmFyIGNvbXBvbmVudENhbGxiYWNrUXVldWUgPSBuZXcgTWFwKCk7XHJcbi8vIHdoZW4gYSBjb21wb25lbnRzIHJvb3QgVk5vZGUgaXMgYWxzbyBhIGNvbXBvbmVudCwgd2UgY2FuIHJ1biBpbnRvIGlzc3Vlc1xyXG4vLyB0aGlzIHdpbGwgcmVjdXJzaXZlbHkgbG9vayBmb3Igdk5vZGUucGFyZW50Tm9kZSBpZiB0aGUgVk5vZGUgaXMgYSBjb21wb25lbnRcclxuZnVuY3Rpb24gdXBkYXRlUGFyZW50Q29tcG9uZW50Vk5vZGVzKHZOb2RlLCBkb20pIHtcclxuICAgIGlmICh2Tm9kZS5mbGFncyAmIDI4IC8qIENvbXBvbmVudCAqLykge1xyXG4gICAgICAgIHZhciBwYXJlbnRWTm9kZSA9IHZOb2RlLnBhcmVudFZOb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnRWTm9kZSkge1xyXG4gICAgICAgICAgICBwYXJlbnRWTm9kZS5kb20gPSBkb207XHJcbiAgICAgICAgICAgIHVwZGF0ZVBhcmVudENvbXBvbmVudFZOb2RlcyhwYXJlbnRWTm9kZSwgZG9tKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxudmFyIHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5mdW5jdGlvbiBhZGRUb1F1ZXVlKGNvbXBvbmVudCwgZm9yY2UsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgcXVldWUgPSBjb21wb25lbnRDYWxsYmFja1F1ZXVlLmdldChjb21wb25lbnQpO1xyXG4gICAgaWYgKHF1ZXVlID09PSB2b2lkIDApIHtcclxuICAgICAgICBxdWV1ZSA9IFtdO1xyXG4gICAgICAgIGNvbXBvbmVudENhbGxiYWNrUXVldWUuc2V0KGNvbXBvbmVudCwgcXVldWUpO1xyXG4gICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50Q2FsbGJhY2tRdWV1ZS5kZWxldGUoY29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29tcG9uZW50Ll91cGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGFwcGx5U3RhdGUoY29tcG9uZW50LCBmb3JjZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHF1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uY2FsbChjb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29tcG9uZW50Ll91cGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc051bGxPclVuZGVmKGNhbGxiYWNrKSkge1xyXG4gICAgICAgIHF1ZXVlLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlU3RhdGVDaGFuZ2VzKGNvbXBvbmVudCwgbmV3U3RhdGUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcclxuICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlKGNvbXBvbmVudC5zdGF0ZSwgY29tcG9uZW50LnByb3BzLCBjb21wb25lbnQuY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGVuZGluZyA9IGNvbXBvbmVudC5fcGVuZGluZ1N0YXRlO1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocGVuZGluZykpIHtcclxuICAgICAgICBjb21wb25lbnQuX3BlbmRpbmdTdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgc3RhdGVLZXkgaW4gbmV3U3RhdGUpIHtcclxuICAgICAgICAgICAgcGVuZGluZ1tzdGF0ZUtleV0gPSBuZXdTdGF0ZVtzdGF0ZUtleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFjb21wb25lbnQuX3BlbmRpbmdTZXRTdGF0ZSAmJiAhY29tcG9uZW50Ll9ibG9ja1JlbmRlcikge1xyXG4gICAgICAgIGlmICghY29tcG9uZW50Ll91cGRhdGluZykge1xyXG4gICAgICAgICAgICBjb21wb25lbnQuX3BlbmRpbmdTZXRTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5fdXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBhcHBseVN0YXRlKGNvbXBvbmVudCwgZmFsc2UsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgY29tcG9uZW50Ll91cGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkVG9RdWV1ZShjb21wb25lbnQsIGZhbHNlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29tcG9uZW50Ll9wZW5kaW5nU2V0U3RhdGUgPSB0cnVlO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihjYWxsYmFjaykgJiYgY29tcG9uZW50Ll9ibG9ja1JlbmRlcikge1xyXG4gICAgICAgICAgICBjb21wb25lbnQuX2xpZmVjeWNsZS5hZGRMaXN0ZW5lcihjYWxsYmFjay5iaW5kKGNvbXBvbmVudCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseVN0YXRlKGNvbXBvbmVudCwgZm9yY2UsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoY29tcG9uZW50Ll91bm1vdW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoZm9yY2UgfHwgIWNvbXBvbmVudC5fYmxvY2tSZW5kZXIpIHtcclxuICAgICAgICBjb21wb25lbnQuX3BlbmRpbmdTZXRTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBwZW5kaW5nU3RhdGUgPSBjb21wb25lbnQuX3BlbmRpbmdTdGF0ZTtcclxuICAgICAgICB2YXIgcHJldlN0YXRlID0gY29tcG9uZW50LnN0YXRlO1xyXG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBjb21iaW5lRnJvbShwcmV2U3RhdGUsIHBlbmRpbmdTdGF0ZSk7XHJcbiAgICAgICAgdmFyIHByb3BzID0gY29tcG9uZW50LnByb3BzO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgY29tcG9uZW50Ll9wZW5kaW5nU3RhdGUgPSBudWxsO1xyXG4gICAgICAgIHZhciBuZXh0SW5wdXQ7XHJcbiAgICAgICAgdmFyIHJlbmRlck91dHB1dCA9IGNvbXBvbmVudC5fdXBkYXRlQ29tcG9uZW50KHByZXZTdGF0ZSwgbmV4dFN0YXRlLCBwcm9wcywgcHJvcHMsIGNvbnRleHQsIGZvcmNlLCB0cnVlKTtcclxuICAgICAgICB2YXIgZGlkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoaXNJbnZhbGlkKHJlbmRlck91dHB1dCkpIHtcclxuICAgICAgICAgICAgbmV4dElucHV0ID0gY3JlYXRlVk5vZGUoNDA5NiAvKiBWb2lkICovLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVuZGVyT3V0cHV0ID09PSBOT19PUCkge1xyXG4gICAgICAgICAgICBuZXh0SW5wdXQgPSBjb21wb25lbnQuX2xhc3RJbnB1dDtcclxuICAgICAgICAgICAgZGlkVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nT3JOdW1iZXIocmVuZGVyT3V0cHV0KSkge1xyXG4gICAgICAgICAgICBuZXh0SW5wdXQgPSBjcmVhdGVWTm9kZSgxIC8qIFRleHQgKi8sIG51bGwsIG51bGwsIHJlbmRlck91dHB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkocmVuZGVyT3V0cHV0KSkge1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiYSB2YWxpZCBJbmZlcm5vIFZOb2RlIChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkIGZyb20gYSBjb21wb25lbnQgcmVuZGVyLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgYW4gYXJyYXkgb3IgYW4gaW52YWxpZCBvYmplY3QuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0SW5wdXQgPSByZW5kZXJPdXRwdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsYXN0SW5wdXQgPSBjb21wb25lbnQuX2xhc3RJbnB1dDtcclxuICAgICAgICB2YXIgdk5vZGUgPSBjb21wb25lbnQuX3ZOb2RlO1xyXG4gICAgICAgIHZhciBwYXJlbnREb20gPSAobGFzdElucHV0LmRvbSAmJiBsYXN0SW5wdXQuZG9tLnBhcmVudE5vZGUpIHx8XHJcbiAgICAgICAgICAgIChsYXN0SW5wdXQuZG9tID0gdk5vZGUuZG9tKTtcclxuICAgICAgICBpZiAobmV4dElucHV0LmZsYWdzICYgMjggLyogQ29tcG9uZW50ICovKSB7XHJcbiAgICAgICAgICAgIG5leHRJbnB1dC5wYXJlbnRWTm9kZSA9IHZOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnQuX2xhc3RJbnB1dCA9IG5leHRJbnB1dDtcclxuICAgICAgICBpZiAoZGlkVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZENvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ID0gY29tcG9uZW50LmdldENoaWxkQ29udGV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmKGNoaWxkQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGNvbXBvbmVudC5fY2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ID0gY29tYmluZUZyb20oY29udGV4dCwgY2hpbGRDb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGlmZUN5Y2xlID0gY29tcG9uZW50Ll9saWZlY3ljbGU7XHJcbiAgICAgICAgICAgIGludGVybmFsX3BhdGNoKGxhc3RJbnB1dCwgbmV4dElucHV0LCBwYXJlbnREb20sIGxpZmVDeWNsZSwgY2hpbGRDb250ZXh0LCBjb21wb25lbnQuX2lzU1ZHLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IHdhcyB1bm1vdW50ZWQgYnkgaXRzIHBhcmVudCwgZG8gbm90aGluZy4gVGhpcyBpcyBuby1vcFxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Ll91bm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaWZlQ3ljbGUudHJpZ2dlcigpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYoY29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUocHJvcHMsIHByZXZTdGF0ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5hZnRlclVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWZ0ZXJVcGRhdGUodk5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkb20gPSAodk5vZGUuZG9tID0gbmV4dElucHV0LmRvbSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZmluZERPTU5vZGVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGludGVybmFsX0RPTU5vZGVNYXAuc2V0KGNvbXBvbmVudCwgbmV4dElucHV0LmRvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVBhcmVudENvbXBvbmVudFZOb2Rlcyh2Tm9kZSwgZG9tKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbXBvbmVudC5zdGF0ZSA9IGNvbXBvbmVudC5fcGVuZGluZ1N0YXRlO1xyXG4gICAgICAgIGNvbXBvbmVudC5fcGVuZGluZ1N0YXRlID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICghaXNOdWxsT3JVbmRlZihjYWxsYmFjaykpIHtcclxuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbn1cclxudmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XHJcbiAgICB0aGlzLl9ibG9ja1JlbmRlciA9IGZhbHNlO1xyXG4gICAgdGhpcy5fYmxvY2tTZXRTdGF0ZSA9IHRydWU7XHJcbiAgICB0aGlzLl9wZW5kaW5nU2V0U3RhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZSA9IG51bGw7XHJcbiAgICB0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xyXG4gICAgdGhpcy5fdk5vZGUgPSBudWxsO1xyXG4gICAgdGhpcy5fdW5tb3VudGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9saWZlY3ljbGUgPSBudWxsO1xyXG4gICAgdGhpcy5fY2hpbGRDb250ZXh0ID0gbnVsbDtcclxuICAgIHRoaXMuX2lzU1ZHID0gZmFsc2U7XHJcbiAgICB0aGlzLl91cGRhdGluZyA9IHRydWU7XHJcbiAgICAvKiogQHR5cGUge29iamVjdH0gKi9cclxuICAgIHRoaXMucHJvcHMgPSBwcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICAvKiogQHR5cGUge29iamVjdH0gKi9cclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgRU1QVFlfT0JKOyAvLyBjb250ZXh0IHNob3VsZCBub3QgYmUgbXV0YWJsZVxyXG59O1xyXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZm9yY2VVcGRhdGUgKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGhpcy5fdW5tb3VudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgYXBwbHlTdGF0ZSh0aGlzLCB0cnVlLCBjYWxsYmFjayk7XHJcbn07XHJcbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZSAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGhpcy5fdW5tb3VudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9ibG9ja1NldFN0YXRlKSB7XHJcbiAgICAgICAgcXVldWVTdGF0ZUNoYW5nZXModGhpcywgbmV3U3RhdGUsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihcImNhbm5vdCB1cGRhdGUgc3RhdGUgdmlhIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVwZGF0ZSgpIG9yIGNvbnN0cnVjdG9yLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3dFcnJvcigpO1xyXG4gICAgfVxyXG59O1xyXG5Db21wb25lbnQucHJvdG90eXBlLl91cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiBfdXBkYXRlQ29tcG9uZW50IChwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcHJldlByb3BzLCBuZXh0UHJvcHMsIGNvbnRleHQsIGZvcmNlLCBmcm9tU2V0U3RhdGUpIHtcclxuICAgIGlmICh0aGlzLl91bm1vdW50ZWQgPT09IHRydWUpIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3Iobm9PcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93RXJyb3IoKTtcclxuICAgIH1cclxuICAgIGlmIChwcmV2UHJvcHMgIT09IG5leHRQcm9wcyB8fFxyXG4gICAgICAgIG5leHRQcm9wcyA9PT0gRU1QVFlfT0JKIHx8XHJcbiAgICAgICAgcHJldlN0YXRlICE9PSBuZXh0U3RhdGUgfHxcclxuICAgICAgICBmb3JjZSkge1xyXG4gICAgICAgIGlmIChwcmV2UHJvcHMgIT09IG5leHRQcm9wcyB8fCBuZXh0UHJvcHMgPT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSAmJiAhZnJvbVNldFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1JlbmRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IHdhcyByZW1vdmVkIGR1cmluZyBpdHMgb3duIHVwZGF0ZSBkbyBub3RoaW5nLi4uXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5PX09QO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1NldFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSBjb21iaW5lRnJvbShuZXh0U3RhdGUsIHRoaXMuX3BlbmRpbmdTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nU2V0U3RhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyogVXBkYXRlIGlmIHNjdSBpcyBub3QgZGVmaW5lZCwgb3IgaXQgcmV0dXJucyB0cnV0aHkgdmFsdWUgb3IgZm9yY2UgKi9cclxuICAgICAgICBpZiAoZm9yY2UgfHxcclxuICAgICAgICAgICAgaXNOdWxsT3JVbmRlZih0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSkgfHxcclxuICAgICAgICAgICAgKHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgY29udGV4dCkpKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLmNvbXBvbmVudFdpbGxVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1NldFN0YXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1NldFN0YXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlUmVuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJlZm9yZVJlbmRlcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVuZGVyID0gdGhpcy5yZW5kZXIobmV4dFByb3BzLCBuZXh0U3RhdGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlclJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hZnRlclJlbmRlcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTk9fT1A7XHJcbn07XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1lbXB0eVxyXG5Db21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7IH07XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBpbmZlcm5vID0gcmVxdWlyZSgnaW5mZXJubycpO1xudmFyIENvbXBvbmVudCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdpbmZlcm5vLWNvbXBvbmVudCcpKTtcblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJuby1TaGFyZWRcclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxudmFyIEVSUk9SX01TRyA9IFwiYSBydW50aW1lIGVycm9yIG9jY3VyZWQhIFVzZSBJbmZlcm5vIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50IHRvIGZpbmQgdGhlIGVycm9yLlwiO1xyXG5mdW5jdGlvbiBpc051bGxPclVuZGVmKG8pIHtcclxuICAgIHJldHVybiBpc1VuZGVmaW5lZChvKSB8fCBpc051bGwobyk7XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihvKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5mdW5jdGlvbiBpc051bGwobykge1xyXG4gICAgcmV0dXJuIG8gPT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNVbmRlZmluZWQobykge1xyXG4gICAgcmV0dXJuIG8gPT09IHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiBpc09iamVjdChvKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09IFwib2JqZWN0XCI7XHJcbn1cclxuZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlKSB7XHJcbiAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgICBtZXNzYWdlID0gRVJST1JfTVNHO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKChcIkluZmVybm8gRXJyb3I6IFwiICsgbWVzc2FnZSkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tQ3JlYXRlLUNsYXNzXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbi8vIGRvbid0IGF1dG9iaW5kIHRoZXNlIG1ldGhvZHMgc2luY2UgdGhleSBhbHJlYWR5IGhhdmUgZ3VhcmFudGVlZCBjb250ZXh0LlxyXG52YXIgQVVUT0JJTkRfQkxBQ0tMSVNUID0gbmV3IFNldCgpO1xyXG5BVVRPQklORF9CTEFDS0xJU1QuYWRkKFwiY29uc3RydWN0b3JcIik7XHJcbkFVVE9CSU5EX0JMQUNLTElTVC5hZGQoXCJyZW5kZXJcIik7XHJcbkFVVE9CSU5EX0JMQUNLTElTVC5hZGQoXCJzaG91bGRDb21wb25lbnRVcGRhdGVcIik7XHJcbkFVVE9CSU5EX0JMQUNLTElTVC5hZGQoXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xyXG5BVVRPQklORF9CTEFDS0xJU1QuYWRkKFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcclxuQVVUT0JJTkRfQkxBQ0tMSVNULmFkZChcImNvbXBvbmVudERpZFVwZGF0ZVwiKTtcclxuQVVUT0JJTkRfQkxBQ0tMSVNULmFkZChcImNvbXBvbmVudFdpbGxNb3VudFwiKTtcclxuQVVUT0JJTkRfQkxBQ0tMSVNULmFkZChcImNvbXBvbmVudERpZE1vdW50XCIpO1xyXG5BVVRPQklORF9CTEFDS0xJU1QuYWRkKFwiY29tcG9uZW50V2lsbFVubW91bnRcIik7XHJcbkFVVE9CSU5EX0JMQUNLTElTVC5hZGQoXCJjb21wb25lbnREaWRVbm1vdW50XCIpO1xyXG5mdW5jdGlvbiBleHRlbmQoYmFzZSwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihwcm9wc1trZXldKSkge1xyXG4gICAgICAgICAgICBiYXNlW2tleV0gPSBwcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlO1xyXG59XHJcbmZ1bmN0aW9uIGJpbmRBbGwoY3R4KSB7XHJcbiAgICBmb3IgKHZhciBpIGluIGN0eCkge1xyXG4gICAgICAgIHZhciB2ID0gY3R4W2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiICYmICF2Ll9fYm91bmQgJiYgIUFVVE9CSU5EX0JMQUNLTElTVC5oYXMoaSkpIHtcclxuICAgICAgICAgICAgKGN0eFtpXSA9IHYuYmluZChjdHgpKS5fX2JvdW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29sbGF0ZU1peGlucyhtaXhpbnMsIGtleWVkKSB7XG4gICAgaWYgKCBrZXllZCA9PT0gdm9pZCAwICkgeyBrZXllZCA9IHt9OyB9XG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtaXhpbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2YXIgbWl4aW4gPSBtaXhpbnNbaV07XHJcbiAgICAgICAgLy8gU3VycHJpc2U6IE1peGlucyBjYW4gaGF2ZSBtaXhpbnNcclxuICAgICAgICBpZiAobWl4aW4ubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbGxhdGUgc3ViLW1peGluc1xyXG4gICAgICAgICAgICBjb2xsYXRlTWl4aW5zKG1peGluLm1peGlucywga2V5ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWl4aW4pIHtcclxuICAgICAgICAgICAgaWYgKG1peGluLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIG1peGluW2tleV0gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgKGtleWVkW2tleV0gfHwgKGtleWVkW2tleV0gPSBbXSkpLnB1c2gobWl4aW5ba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5ZWQ7XHJcbn1cclxuZnVuY3Rpb24gbXVsdGlob29rKGhvb2tzLCBtZXJnZUZuKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAgICAgdmFyIHJldDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGhvb2sgPSBob29rc1tpXTtcclxuICAgICAgICAgICAgdmFyIHIgPSBob29rLmFwcGx5KHRoaXMkMSwgYXJndW1lbnRzJDEpO1xyXG4gICAgICAgICAgICBpZiAobWVyZ2VGbikge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gbWVyZ2VGbihyZXQsIHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZChyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU5vRHVwZXMocHJldmlvdXMsIGN1cnJlbnQpIHtcclxuICAgIGlmICghaXNVbmRlZmluZWQoY3VycmVudCkpIHtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoXCJFeHBlY3RlZCBNaXhpbiB0byByZXR1cm4gdmFsdWUgdG8gYmUgYW4gb2JqZWN0IG9yIG51bGwuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcigoXCJNaXhpbnMgcmV0dXJuIGR1cGxpY2F0ZSBrZXkgXCIgKyBrZXkgKyBcIiBpbiB0aGVpciByZXR1cm4gdmFsdWVzXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzW2tleV0gPSBjdXJyZW50W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJldmlvdXM7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlNaXhpbihrZXksIGluc3QsIG1peGluKSB7XHJcbiAgICB2YXIgaG9va3MgPSBpc1VuZGVmaW5lZChpbnN0W2tleV0pID8gbWl4aW4gOiBtaXhpbi5jb25jYXQoaW5zdFtrZXldKTtcclxuICAgIGlmIChrZXkgPT09IFwiZ2V0RGVmYXVsdFByb3BzXCIgfHxcclxuICAgICAgICBrZXkgPT09IFwiZ2V0SW5pdGlhbFN0YXRlXCIgfHxcclxuICAgICAgICBrZXkgPT09IFwiZ2V0Q2hpbGRDb250ZXh0XCIpIHtcclxuICAgICAgICBpbnN0W2tleV0gPSBtdWx0aWhvb2soaG9va3MsIG1lcmdlTm9EdXBlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0W2tleV0gPSBtdWx0aWhvb2soaG9va3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5TWl4aW5zKENsLCBtaXhpbnMpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBtaXhpbnMpIHtcclxuICAgICAgICBpZiAobWl4aW5zLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgdmFyIG1peGluID0gbWl4aW5zW2tleV07XHJcbiAgICAgICAgICAgIHZhciBpbnN0ID0gKHZvaWQgMCk7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2V0RGVmYXVsdFByb3BzXCIpIHtcclxuICAgICAgICAgICAgICAgIGluc3QgPSBDbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluc3QgPSBDbC5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obWl4aW5bMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBseU1peGluKGtleSwgaW5zdCwgbWl4aW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5zdFtrZXldID0gbWl4aW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2xhc3Mob2JqKSB7XHJcbiAgICB2YXIgQ2wgPSAoZnVuY3Rpb24gKENvbXBvbmVudCQkMSkge1xuICAgICAgICBmdW5jdGlvbiBDbChwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgICAgICBDb21wb25lbnQkJDEuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJpbmRBbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEluaXRpYWxTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBDb21wb25lbnQkJDEgKSB7IENsLl9fcHJvdG9fXyA9IENvbXBvbmVudCQkMTsgfVxuICAgICAgICBDbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb21wb25lbnQkJDEgJiYgQ29tcG9uZW50JCQxLnByb3RvdHlwZSApO1xuICAgICAgICBDbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbDtcclxuICAgICAgICBDbC5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlIChuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDbC5wcm90b3R5cGUuaXNNb3VudGVkID0gZnVuY3Rpb24gaXNNb3VudGVkICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl91bm1vdW50ZWQ7XHJcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ2w7XG4gICAgfShDb21wb25lbnQpKTtcclxuICAgIENsLmRpc3BsYXlOYW1lID0gb2JqLmRpc3BsYXlOYW1lIHx8IFwiQ29tcG9uZW50XCI7XHJcbiAgICBDbC5wcm9wVHlwZXMgPSBvYmoucHJvcFR5cGVzO1xyXG4gICAgQ2wubWl4aW5zID0gb2JqLm1peGlucyAmJiBjb2xsYXRlTWl4aW5zKG9iai5taXhpbnMpO1xyXG4gICAgQ2wuZ2V0RGVmYXVsdFByb3BzID0gb2JqLmdldERlZmF1bHRQcm9wcztcclxuICAgIGV4dGVuZChDbC5wcm90b3R5cGUsIG9iaik7XHJcbiAgICBpZiAob2JqLnN0YXRpY3MpIHtcclxuICAgICAgICBleHRlbmQoQ2wsIG9iai5zdGF0aWNzKTtcclxuICAgIH1cclxuICAgIGlmIChvYmoubWl4aW5zKSB7XHJcbiAgICAgICAgYXBwbHlNaXhpbnMoQ2wsIGNvbGxhdGVNaXhpbnMob2JqLm1peGlucykpO1xyXG4gICAgfVxyXG4gICAgQ2wuZGVmYXVsdFByb3BzID0gaXNVbmRlZmluZWQoQ2wuZ2V0RGVmYXVsdFByb3BzKVxyXG4gICAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgICAgOiBDbC5nZXREZWZhdWx0UHJvcHMoKTtcclxuICAgIHJldHVybiBDbDtcclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vLVNoYXJlZFxyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG5mdW5jdGlvbiBpc051bGxPclVuZGVmJDEobykge1xyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkJDEobykgfHwgaXNOdWxsJDEobyk7XHJcbn1cclxuZnVuY3Rpb24gaXNJbnZhbGlkKG8pIHtcclxuICAgIHJldHVybiBpc051bGwkMShvKSB8fCBvID09PSBmYWxzZSB8fCBpc1RydWUobykgfHwgaXNVbmRlZmluZWQkMShvKTtcclxufVxyXG5mdW5jdGlvbiBpc1N0cmluZyhvKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XHJcbn1cclxuZnVuY3Rpb24gaXNOdWxsJDEobykge1xyXG4gICAgcmV0dXJuIG8gPT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNUcnVlKG8pIHtcclxuICAgIHJldHVybiBvID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkJDEobykge1xyXG4gICAgcmV0dXJuIG8gPT09IHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiBpc09iamVjdCQxKG8pIHtcclxuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIjtcclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vLUNyZWF0ZS1FbGVtZW50XHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbnZhciBjb21wb25lbnRIb29rcyA9IG5ldyBTZXQoKTtcclxuY29tcG9uZW50SG9va3MuYWRkKFwib25Db21wb25lbnRXaWxsTW91bnRcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50RGlkTW91bnRcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50V2lsbFVubW91bnRcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50U2hvdWxkVXBkYXRlXCIpO1xyXG5jb21wb25lbnRIb29rcy5hZGQoXCJvbkNvbXBvbmVudFdpbGxVcGRhdGVcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50RGlkVXBkYXRlXCIpO1xyXG4vKipcclxuICogQ3JlYXRlcyB2aXJ0dWFsIG5vZGVcclxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb258Q29tcG9uZW50PGFueSwgYW55Pn0gdHlwZSBUeXBlIG9mIG5vZGVcclxuICogQHBhcmFtIHtvYmplY3Q9fSBwcm9wcyBPcHRpb25hbCBwcm9wcyBmb3IgdmlydHVhbCBub2RlXHJcbiAqIEBwYXJhbSB7Li4ue29iamVjdH09fSBfY2hpbGRyZW4gT3B0aW9uYWwgY2hpbGRyZW4gZm9yIHZpcnR1YWwgbm9kZVxyXG4gKiBAcmV0dXJucyB7Vk5vZGV9IG5ldyB2aXJ0dWFsIG5kb2VcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSh0eXBlLCBwcm9wcykge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBfY2hpbGRyZW4gPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSB7IF9jaGlsZHJlblsgbGVuIF0gPSBhcmd1bWVudHMkMVsgbGVuICsgMiBdOyB9XG5cclxuICAgIGlmIChpc0ludmFsaWQodHlwZSkgfHwgaXNPYmplY3QkMSh0eXBlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZmVybm8gRXJyb3I6IGNyZWF0ZUVsZW1lbnQoKSBuYW1lIHBhcmFtZXRlciBjYW5ub3QgYmUgdW5kZWZpbmVkLCBudWxsLCBmYWxzZSBvciB0cnVlLCBJdCBtdXN0IGJlIGEgc3RyaW5nLCBjbGFzcyBvciBmdW5jdGlvbi5cIik7XHJcbiAgICB9XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfY2hpbGRyZW47XHJcbiAgICB2YXIgcmVmID0gbnVsbDtcclxuICAgIHZhciBrZXkgPSBudWxsO1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IG51bGw7XHJcbiAgICB2YXIgZmxhZ3MgPSAwO1xyXG4gICAgdmFyIG5ld1Byb3BzO1xyXG4gICAgaWYgKF9jaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChfY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gX2NoaWxkcmVuWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc1N0cmluZyh0eXBlKSkge1xyXG4gICAgICAgIGZsYWdzID0gaW5mZXJuby5nZXRGbGFnc0ZvckVsZW1lbnRWbm9kZSh0eXBlKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYkMShwcm9wcykpIHtcclxuICAgICAgICAgICAgbmV3UHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwiY2xhc3NOYW1lXCIgfHwgcHJvcCA9PT0gXCJjbGFzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJvcHNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSBcImtleVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJvcHMua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gXCJjaGlsZHJlblwiICYmIGlzVW5kZWZpbmVkJDEoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjsgLy8gYWx3YXlzIGZhdm91ciBjaGlsZHJlbiBhcmdzLCBkZWZhdWx0IHRvIHByb3BzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSBcInJlZlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gcHJvcHMucmVmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbcHJvcF0gPSBwcm9wc1twcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZsYWdzID0gMTYgLyogQ29tcG9uZW50VW5rbm93biAqLztcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkJDEoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYkMShwcm9wcykpIHtcclxuICAgICAgICAgICAgbmV3UHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCQxIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50SG9va3MuaGFzKHByb3AkMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmW3Byb3AkMV0gPSBwcm9wc1twcm9wJDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcCQxID09PSBcImtleVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJvcHMua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbcHJvcCQxXSA9IHByb3BzW3Byb3AkMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5mZXJuby5jcmVhdGVWTm9kZShmbGFncywgdHlwZSwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgbmV3UHJvcHMsIGtleSwgcmVmKTtcclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vLVNoYXJlZFxyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG52YXIgTk9fT1AgPSBcIiROT19PUFwiO1xyXG4vLyBUaGlzIHNob3VsZCBiZSBib29sZWFuIGFuZCBub3QgcmVmZXJlbmNlIHRvIHdpbmRvdy5kb2N1bWVudFxyXG52YXIgaXNCcm93c2VyID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQpO1xyXG4vLyB0aGlzIGlzIE1VQ0ggZmFzdGVyIHRoYW4gLmNvbnN0cnVjdG9yID09PSBBcnJheSBhbmQgaW5zdGFuY2VvZiBBcnJheVxyXG4vLyBpbiBOb2RlIDcgYW5kIHRoZSBsYXRlciB2ZXJzaW9ucyBvZiBWOCwgc2xvd2VyIGluIG9sZGVyIHZlcnNpb25zIHRob3VnaFxyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYkMihvKSB7XHJcbiAgICByZXR1cm4gaXNVbmRlZmluZWQkMihvKSB8fCBpc051bGwkMihvKTtcclxufVxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uJDEobykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuZnVuY3Rpb24gaXNTdHJpbmckMShvKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XHJcbn1cclxuZnVuY3Rpb24gaXNOdWxsJDIobykge1xyXG4gICAgcmV0dXJuIG8gPT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNVbmRlZmluZWQkMihvKSB7XHJcbiAgICByZXR1cm4gbyA9PT0gdm9pZCAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0JDIobykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm9iamVjdFwiO1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tQ29tcGF0XHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iaikge1xyXG4gICAgdmFyIGlzTm90QU51bGxPYmplY3QgPSBpc09iamVjdCQyKG9iaikgJiYgaXNOdWxsJDIob2JqKSA9PT0gZmFsc2U7XHJcbiAgICBpZiAoaXNOb3RBTnVsbE9iamVjdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgZmxhZ3MgPSBvYmouZmxhZ3M7XHJcbiAgICByZXR1cm4gKGZsYWdzICYgKDI4IC8qIENvbXBvbmVudCAqLyB8IDM5NzAgLyogRWxlbWVudCAqLykpID4gMDtcclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vLUNvbXBhdFxyXG4gKi9cclxuLyoqXHJcbiAqIElubGluZWQgUHJvcFR5cGVzLCB0aGVyZSBpcyBwcm9wVHlwZSBjaGVja2luZyBBVE0uXHJcbiAqL1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcclxuZnVuY3Rpb24gcHJvcHR5cGUoKSB7IH1cclxucHJvcHR5cGUuaXNSZXF1aXJlZCA9IHByb3B0eXBlO1xyXG52YXIgZ2V0UHJvcHR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wdHlwZTsgfTtcclxudmFyIFByb3BUeXBlcyA9IHtcclxuICAgIGFueTogZ2V0UHJvcHR5cGUsXHJcbiAgICBhcnJheTogcHJvcHR5cGUsXHJcbiAgICBhcnJheU9mOiBnZXRQcm9wdHlwZSxcclxuICAgIGJvb2w6IHByb3B0eXBlLFxyXG4gICAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXHJcbiAgICBlbGVtZW50OiBnZXRQcm9wdHlwZSxcclxuICAgIGZ1bmM6IHByb3B0eXBlLFxyXG4gICAgaW5zdGFuY2VPZjogZ2V0UHJvcHR5cGUsXHJcbiAgICBub2RlOiBnZXRQcm9wdHlwZSxcclxuICAgIG51bWJlcjogcHJvcHR5cGUsXHJcbiAgICBvYmplY3Q6IHByb3B0eXBlLFxyXG4gICAgb2JqZWN0T2Y6IGdldFByb3B0eXBlLFxyXG4gICAgb25lT2Y6IGdldFByb3B0eXBlLFxyXG4gICAgb25lT2ZUeXBlOiBnZXRQcm9wdHlwZSxcclxuICAgIHNoYXBlOiBnZXRQcm9wdHlwZSxcclxuICAgIHN0cmluZzogcHJvcHR5cGUsXHJcbiAgICBzeW1ib2w6IHByb3B0eXBlXHJcbn07XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tQ29tcGF0XHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbi8qKlxyXG4gKiBib3Jyb3dlZCBSZWFjdCBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xyXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9jNzg0NjRmOGVhOWE1YjAwZWM4MDI1MmQyMGE3MWExNDgyMjEwZTU3L3NyYy9yZW5kZXJlcnMvZG9tL3NoYXJlZC9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qc1xyXG4gKi9cclxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xyXG4gICAgYWNjZW50SGVpZ2h0OiBcImFjY2VudC1oZWlnaHRcIixcclxuICAgIGFjY3VtdWxhdGU6IDAsXHJcbiAgICBhZGRpdGl2ZTogMCxcclxuICAgIGFsaWdubWVudEJhc2VsaW5lOiBcImFsaWdubWVudC1iYXNlbGluZVwiLFxyXG4gICAgYWxsb3dSZW9yZGVyOiBcImFsbG93UmVvcmRlclwiLFxyXG4gICAgYWxwaGFiZXRpYzogMCxcclxuICAgIGFtcGxpdHVkZTogMCxcclxuICAgIGFyYWJpY0Zvcm06IFwiYXJhYmljLWZvcm1cIixcclxuICAgIGFzY2VudDogMCxcclxuICAgIGF0dHJpYnV0ZU5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLFxyXG4gICAgYXR0cmlidXRlVHlwZTogXCJhdHRyaWJ1dGVUeXBlXCIsXHJcbiAgICBhdXRvUmV2ZXJzZTogXCJhdXRvUmV2ZXJzZVwiLFxyXG4gICAgYXppbXV0aDogMCxcclxuICAgIGJhc2VGcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLFxyXG4gICAgYmFzZVByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcclxuICAgIGJhc2VsaW5lU2hpZnQ6IFwiYmFzZWxpbmUtc2hpZnRcIixcclxuICAgIGJib3g6IDAsXHJcbiAgICBiZWdpbjogMCxcclxuICAgIGJpYXM6IDAsXHJcbiAgICBieTogMCxcclxuICAgIGNhbGNNb2RlOiBcImNhbGNNb2RlXCIsXHJcbiAgICBjYXBIZWlnaHQ6IFwiY2FwLWhlaWdodFwiLFxyXG4gICAgY2xpcDogMCxcclxuICAgIGNsaXBQYXRoOiBcImNsaXAtcGF0aFwiLFxyXG4gICAgY2xpcFBhdGhVbml0czogXCJjbGlwUGF0aFVuaXRzXCIsXHJcbiAgICBjbGlwUnVsZTogXCJjbGlwLXJ1bGVcIixcclxuICAgIGNvbG9ySW50ZXJwb2xhdGlvbjogXCJjb2xvci1pbnRlcnBvbGF0aW9uXCIsXHJcbiAgICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLFxyXG4gICAgY29sb3JQcm9maWxlOiBcImNvbG9yLXByb2ZpbGVcIixcclxuICAgIGNvbG9yUmVuZGVyaW5nOiBcImNvbG9yLXJlbmRlcmluZ1wiLFxyXG4gICAgY29udGVudFNjcmlwdFR5cGU6IFwiY29udGVudFNjcmlwdFR5cGVcIixcclxuICAgIGNvbnRlbnRTdHlsZVR5cGU6IFwiY29udGVudFN0eWxlVHlwZVwiLFxyXG4gICAgY3Vyc29yOiAwLFxyXG4gICAgY3g6IDAsXHJcbiAgICBjeTogMCxcclxuICAgIGQ6IDAsXHJcbiAgICBkZWNlbGVyYXRlOiAwLFxyXG4gICAgZGVzY2VudDogMCxcclxuICAgIGRpZmZ1c2VDb25zdGFudDogXCJkaWZmdXNlQ29uc3RhbnRcIixcclxuICAgIGRpcmVjdGlvbjogMCxcclxuICAgIGRpc3BsYXk6IDAsXHJcbiAgICBkaXZpc29yOiAwLFxyXG4gICAgZG9taW5hbnRCYXNlbGluZTogXCJkb21pbmFudC1iYXNlbGluZVwiLFxyXG4gICAgZHVyOiAwLFxyXG4gICAgZHg6IDAsXHJcbiAgICBkeTogMCxcclxuICAgIGVkZ2VNb2RlOiBcImVkZ2VNb2RlXCIsXHJcbiAgICBlbGV2YXRpb246IDAsXHJcbiAgICBlbmFibGVCYWNrZ3JvdW5kOiBcImVuYWJsZS1iYWNrZ3JvdW5kXCIsXHJcbiAgICBlbmQ6IDAsXHJcbiAgICBleHBvbmVudDogMCxcclxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6IFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFxyXG4gICAgZmlsbDogMCxcclxuICAgIGZpbGxPcGFjaXR5OiBcImZpbGwtb3BhY2l0eVwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZmlsbC1ydWxlXCIsXHJcbiAgICBmaWx0ZXI6IDAsXHJcbiAgICBmaWx0ZXJSZXM6IFwiZmlsdGVyUmVzXCIsXHJcbiAgICBmaWx0ZXJVbml0czogXCJmaWx0ZXJVbml0c1wiLFxyXG4gICAgZmxvb2RDb2xvcjogXCJmbG9vZC1jb2xvclwiLFxyXG4gICAgZmxvb2RPcGFjaXR5OiBcImZsb29kLW9wYWNpdHlcIixcclxuICAgIGZvY3VzYWJsZTogMCxcclxuICAgIGZvbnRGYW1pbHk6IFwiZm9udC1mYW1pbHlcIixcclxuICAgIGZvbnRTaXplOiBcImZvbnQtc2l6ZVwiLFxyXG4gICAgZm9udFNpemVBZGp1c3Q6IFwiZm9udC1zaXplLWFkanVzdFwiLFxyXG4gICAgZm9udFN0cmV0Y2g6IFwiZm9udC1zdHJldGNoXCIsXHJcbiAgICBmb250U3R5bGU6IFwiZm9udC1zdHlsZVwiLFxyXG4gICAgZm9udFZhcmlhbnQ6IFwiZm9udC12YXJpYW50XCIsXHJcbiAgICBmb250V2VpZ2h0OiBcImZvbnQtd2VpZ2h0XCIsXHJcbiAgICBmb3JtYXQ6IDAsXHJcbiAgICBmcm9tOiAwLFxyXG4gICAgZng6IDAsXHJcbiAgICBmeTogMCxcclxuICAgIGcxOiAwLFxyXG4gICAgZzI6IDAsXHJcbiAgICBnbHlwaE5hbWU6IFwiZ2x5cGgtbmFtZVwiLFxyXG4gICAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6IFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiLFxyXG4gICAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCIsXHJcbiAgICBnbHlwaFJlZjogXCJnbHlwaFJlZlwiLFxyXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcclxuICAgIGdyYWRpZW50VW5pdHM6IFwiZ3JhZGllbnRVbml0c1wiLFxyXG4gICAgaGFuZ2luZzogMCxcclxuICAgIGhvcml6QWR2WDogXCJob3Jpei1hZHYteFwiLFxyXG4gICAgaG9yaXpPcmlnaW5YOiBcImhvcml6LW9yaWdpbi14XCIsXHJcbiAgICBpZGVvZ3JhcGhpYzogMCxcclxuICAgIGltYWdlUmVuZGVyaW5nOiBcImltYWdlLXJlbmRlcmluZ1wiLFxyXG4gICAgaW46IDAsXHJcbiAgICBpbjI6IDAsXHJcbiAgICBpbnRlcmNlcHQ6IDAsXHJcbiAgICBrOiAwLFxyXG4gICAgazE6IDAsXHJcbiAgICBrMjogMCxcclxuICAgIGszOiAwLFxyXG4gICAgazQ6IDAsXHJcbiAgICBrZXJuZWxNYXRyaXg6IFwia2VybmVsTWF0cml4XCIsXHJcbiAgICBrZXJuZWxVbml0TGVuZ3RoOiBcImtlcm5lbFVuaXRMZW5ndGhcIixcclxuICAgIGtlcm5pbmc6IDAsXHJcbiAgICBrZXlQb2ludHM6IFwia2V5UG9pbnRzXCIsXHJcbiAgICBrZXlTcGxpbmVzOiBcImtleVNwbGluZXNcIixcclxuICAgIGtleVRpbWVzOiBcImtleVRpbWVzXCIsXHJcbiAgICBsZW5ndGhBZGp1c3Q6IFwibGVuZ3RoQWRqdXN0XCIsXHJcbiAgICBsZXR0ZXJTcGFjaW5nOiBcImxldHRlci1zcGFjaW5nXCIsXHJcbiAgICBsaWdodGluZ0NvbG9yOiBcImxpZ2h0aW5nLWNvbG9yXCIsXHJcbiAgICBsaW1pdGluZ0NvbmVBbmdsZTogXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxyXG4gICAgbG9jYWw6IDAsXHJcbiAgICBtYXJrZXJFbmQ6IFwibWFya2VyLWVuZFwiLFxyXG4gICAgbWFya2VySGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLFxyXG4gICAgbWFya2VyTWlkOiBcIm1hcmtlci1taWRcIixcclxuICAgIG1hcmtlclN0YXJ0OiBcIm1hcmtlci1zdGFydFwiLFxyXG4gICAgbWFya2VyVW5pdHM6IFwibWFya2VyVW5pdHNcIixcclxuICAgIG1hcmtlcldpZHRoOiBcIm1hcmtlcldpZHRoXCIsXHJcbiAgICBtYXNrOiAwLFxyXG4gICAgbWFza0NvbnRlbnRVbml0czogXCJtYXNrQ29udGVudFVuaXRzXCIsXHJcbiAgICBtYXNrVW5pdHM6IFwibWFza1VuaXRzXCIsXHJcbiAgICBtYXRoZW1hdGljYWw6IDAsXHJcbiAgICBtb2RlOiAwLFxyXG4gICAgbnVtT2N0YXZlczogXCJudW1PY3RhdmVzXCIsXHJcbiAgICBvZmZzZXQ6IDAsXHJcbiAgICBvcGFjaXR5OiAwLFxyXG4gICAgb3BlcmF0b3I6IDAsXHJcbiAgICBvcmRlcjogMCxcclxuICAgIG9yaWVudDogMCxcclxuICAgIG9yaWVudGF0aW9uOiAwLFxyXG4gICAgb3JpZ2luOiAwLFxyXG4gICAgb3ZlcmZsb3c6IDAsXHJcbiAgICBvdmVybGluZVBvc2l0aW9uOiBcIm92ZXJsaW5lLXBvc2l0aW9uXCIsXHJcbiAgICBvdmVybGluZVRoaWNrbmVzczogXCJvdmVybGluZS10aGlja25lc3NcIixcclxuICAgIHBhaW50T3JkZXI6IFwicGFpbnQtb3JkZXJcIixcclxuICAgIHBhbm9zZTE6IFwicGFub3NlLTFcIixcclxuICAgIHBhdGhMZW5ndGg6IFwicGF0aExlbmd0aFwiLFxyXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXHJcbiAgICBwYXR0ZXJuVHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIixcclxuICAgIHBhdHRlcm5Vbml0czogXCJwYXR0ZXJuVW5pdHNcIixcclxuICAgIHBvaW50ZXJFdmVudHM6IFwicG9pbnRlci1ldmVudHNcIixcclxuICAgIHBvaW50czogMCxcclxuICAgIHBvaW50c0F0WDogXCJwb2ludHNBdFhcIixcclxuICAgIHBvaW50c0F0WTogXCJwb2ludHNBdFlcIixcclxuICAgIHBvaW50c0F0WjogXCJwb2ludHNBdFpcIixcclxuICAgIHByZXNlcnZlQWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxyXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsXHJcbiAgICBwcmltaXRpdmVVbml0czogXCJwcmltaXRpdmVVbml0c1wiLFxyXG4gICAgcjogMCxcclxuICAgIHJhZGl1czogMCxcclxuICAgIHJlZlg6IFwicmVmWFwiLFxyXG4gICAgcmVmWTogXCJyZWZZXCIsXHJcbiAgICByZW5kZXJpbmdJbnRlbnQ6IFwicmVuZGVyaW5nLWludGVudFwiLFxyXG4gICAgcmVwZWF0Q291bnQ6IFwicmVwZWF0Q291bnRcIixcclxuICAgIHJlcGVhdER1cjogXCJyZXBlYXREdXJcIixcclxuICAgIHJlcXVpcmVkRXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcclxuICAgIHJlcXVpcmVkRmVhdHVyZXM6IFwicmVxdWlyZWRGZWF0dXJlc1wiLFxyXG4gICAgcmVzdGFydDogMCxcclxuICAgIHJlc3VsdDogMCxcclxuICAgIHJvdGF0ZTogMCxcclxuICAgIHJ4OiAwLFxyXG4gICAgcnk6IDAsXHJcbiAgICBzY2FsZTogMCxcclxuICAgIHNlZWQ6IDAsXHJcbiAgICBzaGFwZVJlbmRlcmluZzogXCJzaGFwZS1yZW5kZXJpbmdcIixcclxuICAgIHNsb3BlOiAwLFxyXG4gICAgc3BhY2luZzogMCxcclxuICAgIHNwZWN1bGFyQ29uc3RhbnQ6IFwic3BlY3VsYXJDb25zdGFudFwiLFxyXG4gICAgc3BlY3VsYXJFeHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsXHJcbiAgICBzcGVlZDogMCxcclxuICAgIHNwcmVhZE1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcclxuICAgIHN0YXJ0T2Zmc2V0OiBcInN0YXJ0T2Zmc2V0XCIsXHJcbiAgICBzdGREZXZpYXRpb246IFwic3RkRGV2aWF0aW9uXCIsXHJcbiAgICBzdGVtaDogMCxcclxuICAgIHN0ZW12OiAwLFxyXG4gICAgc3RpdGNoVGlsZXM6IFwic3RpdGNoVGlsZXNcIixcclxuICAgIHN0b3BDb2xvcjogXCJzdG9wLWNvbG9yXCIsXHJcbiAgICBzdG9wT3BhY2l0eTogXCJzdG9wLW9wYWNpdHlcIixcclxuICAgIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCIsXHJcbiAgICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCIsXHJcbiAgICBzdHJpbmc6IDAsXHJcbiAgICBzdHJva2U6IDAsXHJcbiAgICBzdHJva2VEYXNoYXJyYXk6IFwic3Ryb2tlLWRhc2hhcnJheVwiLFxyXG4gICAgc3Ryb2tlRGFzaG9mZnNldDogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxyXG4gICAgc3Ryb2tlTGluZWNhcDogXCJzdHJva2UtbGluZWNhcFwiLFxyXG4gICAgc3Ryb2tlTGluZWpvaW46IFwic3Ryb2tlLWxpbmVqb2luXCIsXHJcbiAgICBzdHJva2VNaXRlcmxpbWl0OiBcInN0cm9rZS1taXRlcmxpbWl0XCIsXHJcbiAgICBzdHJva2VPcGFjaXR5OiBcInN0cm9rZS1vcGFjaXR5XCIsXHJcbiAgICBzdHJva2VXaWR0aDogXCJzdHJva2Utd2lkdGhcIixcclxuICAgIHN1cmZhY2VTY2FsZTogXCJzdXJmYWNlU2NhbGVcIixcclxuICAgIHN5c3RlbUxhbmd1YWdlOiBcInN5c3RlbUxhbmd1YWdlXCIsXHJcbiAgICB0YWJsZVZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxyXG4gICAgdGFyZ2V0WDogXCJ0YXJnZXRYXCIsXHJcbiAgICB0YXJnZXRZOiBcInRhcmdldFlcIixcclxuICAgIHRleHRBbmNob3I6IFwidGV4dC1hbmNob3JcIixcclxuICAgIHRleHREZWNvcmF0aW9uOiBcInRleHQtZGVjb3JhdGlvblwiLFxyXG4gICAgdGV4dExlbmd0aDogXCJ0ZXh0TGVuZ3RoXCIsXHJcbiAgICB0ZXh0UmVuZGVyaW5nOiBcInRleHQtcmVuZGVyaW5nXCIsXHJcbiAgICB0bzogMCxcclxuICAgIHRyYW5zZm9ybTogMCxcclxuICAgIHUxOiAwLFxyXG4gICAgdTI6IDAsXHJcbiAgICB1bmRlcmxpbmVQb3NpdGlvbjogXCJ1bmRlcmxpbmUtcG9zaXRpb25cIixcclxuICAgIHVuZGVybGluZVRoaWNrbmVzczogXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCIsXHJcbiAgICB1bmljb2RlOiAwLFxyXG4gICAgdW5pY29kZUJpZGk6IFwidW5pY29kZS1iaWRpXCIsXHJcbiAgICB1bmljb2RlUmFuZ2U6IFwidW5pY29kZS1yYW5nZVwiLFxyXG4gICAgdW5pdHNQZXJFbTogXCJ1bml0cy1wZXItZW1cIixcclxuICAgIHZBbHBoYWJldGljOiBcInYtYWxwaGFiZXRpY1wiLFxyXG4gICAgdkhhbmdpbmc6IFwidi1oYW5naW5nXCIsXHJcbiAgICB2SWRlb2dyYXBoaWM6IFwidi1pZGVvZ3JhcGhpY1wiLFxyXG4gICAgdk1hdGhlbWF0aWNhbDogXCJ2LW1hdGhlbWF0aWNhbFwiLFxyXG4gICAgdmFsdWVzOiAwLFxyXG4gICAgdmVjdG9yRWZmZWN0OiBcInZlY3Rvci1lZmZlY3RcIixcclxuICAgIHZlcnNpb246IDAsXHJcbiAgICB2ZXJ0QWR2WTogXCJ2ZXJ0LWFkdi15XCIsXHJcbiAgICB2ZXJ0T3JpZ2luWDogXCJ2ZXJ0LW9yaWdpbi14XCIsXHJcbiAgICB2ZXJ0T3JpZ2luWTogXCJ2ZXJ0LW9yaWdpbi15XCIsXHJcbiAgICB2aWV3Qm94OiBcInZpZXdCb3hcIixcclxuICAgIHZpZXdUYXJnZXQ6IFwidmlld1RhcmdldFwiLFxyXG4gICAgdmlzaWJpbGl0eTogMCxcclxuICAgIHdpZHRoczogMCxcclxuICAgIHdvcmRTcGFjaW5nOiBcIndvcmQtc3BhY2luZ1wiLFxyXG4gICAgd3JpdGluZ01vZGU6IFwid3JpdGluZy1tb2RlXCIsXHJcbiAgICB4OiAwLFxyXG4gICAgeDE6IDAsXHJcbiAgICB4MjogMCxcclxuICAgIHhDaGFubmVsU2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxyXG4gICAgeEhlaWdodDogXCJ4LWhlaWdodFwiLFxyXG4gICAgeGxpbmtBY3R1YXRlOiBcInhsaW5rOmFjdHVhdGVcIixcclxuICAgIHhsaW5rQXJjcm9sZTogXCJ4bGluazphcmNyb2xlXCIsXHJcbiAgICB4bGlua0hyZWY6IFwieGxpbms6aHJlZlwiLFxyXG4gICAgeGxpbmtSb2xlOiBcInhsaW5rOnJvbGVcIixcclxuICAgIHhsaW5rU2hvdzogXCJ4bGluazpzaG93XCIsXHJcbiAgICB4bGlua1RpdGxlOiBcInhsaW5rOnRpdGxlXCIsXHJcbiAgICB4bGlua1R5cGU6IFwieGxpbms6dHlwZVwiLFxyXG4gICAgeG1sQmFzZTogXCJ4bWw6YmFzZVwiLFxyXG4gICAgLy8geG1sbnM6IDAsXHJcbiAgICB4bWxMYW5nOiBcInhtbDpsYW5nXCIsXHJcbiAgICB4bWxTcGFjZTogXCJ4bWw6c3BhY2VcIixcclxuICAgIHhtbG5zWGxpbms6IFwieG1sbnM6eGxpbmtcIixcclxuICAgIHk6IDAsXHJcbiAgICB5MTogMCxcclxuICAgIHkyOiAwLFxyXG4gICAgeUNoYW5uZWxTZWxlY3RvcjogXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXHJcbiAgICB6OiAwLFxyXG4gICAgem9vbUFuZFBhbjogXCJ6b29tQW5kUGFuXCJcclxufTtcblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJuby1Db21wYXRcclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuaW5mZXJuby5vcHRpb25zLmZpbmRET01Ob2RlRW5hYmxlZCA9IHRydWU7XHJcbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XHJcbiAgICBpbmZlcm5vLnJlbmRlcihudWxsLCBjb250YWluZXIpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxudmFyIEFSUiA9IFtdO1xyXG52YXIgQ2hpbGRyZW4gPSB7XHJcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChjaGlsZHJlbiwgZm4sIGN0eCkge1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmJDIoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hpbGRyZW4gPSBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcclxuICAgICAgICBpZiAoY3R4ICYmIGN0eCAhPT0gY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgZm4gPSBmbi5iaW5kKGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoZm4pO1xyXG4gICAgfSxcclxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2hpbGRyZW4sIGZuLCBjdHgpIHtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZiQyKGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkcmVuID0gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XHJcbiAgICAgICAgaWYgKGN0eCAmJiBjdHggIT09IGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGZuID0gZm4uYmluZChjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgZm4oY2hpbGRyZW5baV0sIGksIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY291bnQ6IGZ1bmN0aW9uIGNvdW50KGNoaWxkcmVuKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcclxuICAgICAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgfSxcclxuICAgIG9ubHk6IGZ1bmN0aW9uIG9ubHkoY2hpbGRyZW4pIHtcclxuICAgICAgICBjaGlsZHJlbiA9IENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGRyZW4ub25seSgpIGV4cGVjdHMgb25seSBvbmUgY2hpbGQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XHJcbiAgICB9LFxyXG4gICAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSQkMShjaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmJDIoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBBUlIuY29uY2F0KGNoaWxkcmVuKTtcclxuICAgIH1cclxufTtcclxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XHJcbnZhciBjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcclxuaW5mZXJuby5vcHRpb25zLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgIGN1cnJlbnRDb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbn07XHJcbmluZmVybm8ub3B0aW9ucy5hZnRlclJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xyXG59O1xyXG52YXIgdmVyc2lvbiA9IFwiMTUuNC4yXCI7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKG5hbWUsIHByb3BzKSB7XHJcbiAgICBpZiAoKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcInRleHRhcmVhXCIpICYmXHJcbiAgICAgICAgcHJvcHMudHlwZSAhPT0gXCJyYWRpb1wiICYmXHJcbiAgICAgICAgcHJvcHMub25DaGFuZ2UpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XHJcbiAgICAgICAgdmFyIGV2ZW50TmFtZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib25jbGlja1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcImZpbGVcIikge1xyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uY2hhbmdlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uaW5wdXRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwcm9wc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2V2ZW50TmFtZV0gPSBwcm9wcy5vbkNoYW5nZTtcclxuICAgICAgICAgICAgZGVsZXRlIHByb3BzLm9uQ2hhbmdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcclxuICAgICAgICBpZiAocHJvcCA9PT0gXCJvbkRvdWJsZUNsaWNrXCIpIHtcclxuICAgICAgICAgICAgcHJvcHMub25EYmxDbGljayA9IHByb3BzW3Byb3BdO1xyXG4gICAgICAgICAgICBkZWxldGUgcHJvcHNbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wID09PSBcImh0bWxGb3JcIikge1xyXG4gICAgICAgICAgICBwcm9wcy5mb3IgPSBwcm9wc1twcm9wXTtcclxuICAgICAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWFwcGVkUHJvcCA9IFNWR0RPTVByb3BlcnR5Q29uZmlnW3Byb3BdO1xyXG4gICAgICAgIGlmIChtYXBwZWRQcm9wICYmIG1hcHBlZFByb3AgIT09IHByb3ApIHtcclxuICAgICAgICAgICAgcHJvcHNbbWFwcGVkUHJvcF0gPSBwcm9wc1twcm9wXTtcclxuICAgICAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyB3ZSBuZWVkIHRvIGFkZCBwZXJzaXN0KCkgdG8gRXZlbnQgKGFzIFJlYWN0IGhhcyBpdCBmb3Igc3ludGhldGljIGV2ZW50cylcclxuLy8gdGhpcyBpcyBhIGhhY2sgYW5kIHdlIHJlYWxseSBzaG91bGRuJ3QgYmUgbW9kaWZ5aW5nIGEgZ2xvYmFsIG9iamVjdCB0aGlzIHdheSxcclxuLy8gYnV0IHRoZXJlIGlzbid0IGEgcGVyZm9ybWFudCB3YXkgb2YgZG9pbmcgdGhpcyBhcGFydCBmcm9tIHRyeWluZyB0byBwcm94eVxyXG4vLyBldmVyeSBwcm9wIGV2ZW50IHRoYXQgc3RhcnRzIHdpdGggXCJvblwiLCBpLmUuIG9uQ2xpY2sgb3Igb25LZXlQcmVzc1xyXG4vLyBidXQgaW4gcmVhbGl0eSBkZXZzIHVzZSBvblNvbWV0aGluZyBmb3IgbWFueSB0aGluZ3MsIG5vdCBvbmx5IGZvclxyXG4vLyBpbnB1dCBldmVudHNcclxuaWYgKHR5cGVvZiBFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhRXZlbnQucHJvdG90eXBlLnBlcnNpc3QpIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1lbXB0eVxyXG4gICAgRXZlbnQucHJvdG90eXBlLnBlcnNpc3QgPSBmdW5jdGlvbiAoKSB7IH07XHJcbn1cclxuZnVuY3Rpb24gaXRlcmFibGVUb0FycmF5KGl0ZXJhYmxlKSB7XHJcbiAgICB2YXIgaXRlclN0ZXA7XHJcbiAgICB2YXIgdG1wQXJyID0gW107XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaXRlclN0ZXAgPSBpdGVyYWJsZS5uZXh0KCk7XHJcbiAgICAgICAgaWYgKGl0ZXJTdGVwLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRtcEFyci5wdXNoKGl0ZXJTdGVwLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9IHdoaWxlICghaXRlclN0ZXAuZG9uZSk7XHJcbiAgICByZXR1cm4gdG1wQXJyO1xyXG59XHJcbnZhciBoYXNTeW1ib2xTdXBwb3J0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIjtcclxudmFyIGluamVjdFN0cmluZ1JlZnMgPSBmdW5jdGlvbiAob3JpZ2luYWxGdW5jdGlvbikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBfcHJvcHMpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW10sIGxlbiQxID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICAgIHdoaWxlICggbGVuJDEtLSA+IDAgKSBjaGlsZHJlblsgbGVuJDEgXSA9IGFyZ3VtZW50c1sgbGVuJDEgKyAyIF07XG5cclxuICAgICAgICB2YXIgcHJvcHMgPSBfcHJvcHMgfHwge307XHJcbiAgICAgICAgdmFyIHJlZiA9IHByb3BzLnJlZjtcclxuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJzdHJpbmdcIiAmJiAhaXNOdWxsJDIoY3VycmVudENvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgY3VycmVudENvbXBvbmVudC5yZWZzID0gY3VycmVudENvbXBvbmVudC5yZWZzIHx8IHt9O1xyXG4gICAgICAgICAgICBwcm9wcy5yZWYgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnNbcmVmXSA9IHZhbDtcclxuICAgICAgICAgICAgfS5iaW5kKGN1cnJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplUHJvcHMobmFtZSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZWFjdCBzdXBwb3J0cyBpdGVyYWJsZSBjaGlsZHJlbiwgaW4gYWRkaXRpb24gdG8gQXJyYXktbGlrZVxyXG4gICAgICAgIGlmIChoYXNTeW1ib2xTdXBwb3J0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNBcnJheShjaGlsZCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNTdHJpbmckMShjaGlsZCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uJDEoY2hpbGRbU3ltYm9sLml0ZXJhdG9yXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGl0ZXJhYmxlVG9BcnJheShjaGlsZFtTeW1ib2wuaXRlcmF0b3JdKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2bm9kZSA9IG9yaWdpbmFsRnVuY3Rpb24uYXBwbHkodm9pZCAwLCBbIG5hbWUsIHByb3BzIF0uY29uY2F0KCBjaGlsZHJlbiApKTtcclxuICAgICAgICBpZiAodm5vZGUuY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHZub2RlLnByb3BzID0gdm5vZGUucHJvcHMgfHwge307XHJcbiAgICAgICAgICAgIHZub2RlLnByb3BzLmNsYXNzTmFtZSA9IHZub2RlLmNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfTtcclxufTtcclxudmFyIGNyZWF0ZUVsZW1lbnQgPSBpbmplY3RTdHJpbmdSZWZzKGNyZWF0ZUVsZW1lbnQkMSk7XHJcbnZhciBjbG9uZUVsZW1lbnQgPSBpbmplY3RTdHJpbmdSZWZzKGluZmVybm8uY2xvbmVWTm9kZSk7XHJcbnZhciBvbGRDcmVhdGVWTm9kZSA9IGluZmVybm8ub3B0aW9ucy5jcmVhdGVWTm9kZTtcclxuaW5mZXJuby5vcHRpb25zLmNyZWF0ZVZOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbjtcclxuICAgIHZhciBwcm9wcyA9IHZOb2RlLnByb3BzO1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYkMihwcm9wcykpIHtcclxuICAgICAgICBwcm9wcyA9IHZOb2RlLnByb3BzID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYkMihjaGlsZHJlbikgJiYgaXNOdWxsT3JVbmRlZiQyKHByb3BzLmNoaWxkcmVuKSkge1xyXG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBpZiAob2xkQ3JlYXRlVk5vZGUpIHtcclxuICAgICAgICBvbGRDcmVhdGVWTm9kZSh2Tm9kZSk7XHJcbiAgICB9XHJcbn07XHJcbi8vIENyZWRpdDogcHJlYWN0LWNvbXBhdCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0LWNvbXBhdCA6KVxyXG5mdW5jdGlvbiBzaGFsbG93RGlmZmVycyhhLCBiKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIGEpIHtcclxuICAgICAgICBpZiAoIShpIGluIGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkkMSBpbiBiKSB7XHJcbiAgICAgICAgaWYgKGFbaSQxXSAhPT0gYltpJDFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICBDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XHJcbn1cclxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KHt9LCB7fSk7XHJcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChwcm9wcywgc3RhdGUpIHtcclxuICAgIHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBwcm9wcykgfHwgc2hhbGxvd0RpZmZlcnModGhpcy5zdGF0ZSwgc3RhdGUpO1xyXG59O1xyXG52YXIgV3JhcHBlckNvbXBvbmVudCA9IChmdW5jdGlvbiAoQ29tcG9uZW50JCQxKSB7XG4gICAgZnVuY3Rpb24gV3JhcHBlckNvbXBvbmVudCAoKSB7XG4gICAgICAgIENvbXBvbmVudCQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGlmICggQ29tcG9uZW50JCQxICkgV3JhcHBlckNvbXBvbmVudC5fX3Byb3RvX18gPSBDb21wb25lbnQkJDE7XG4gICAgV3JhcHBlckNvbXBvbmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb21wb25lbnQkJDEgJiYgQ29tcG9uZW50JCQxLnByb3RvdHlwZSApO1xuICAgIFdyYXBwZXJDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV3JhcHBlckNvbXBvbmVudDtcblxuICAgIFdyYXBwZXJDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCAoKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHNbXCJjb250ZXh0XCJdO1xyXG4gICAgfTtcclxuICAgIFdyYXBwZXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciQkMSAocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XHJcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdyYXBwZXJDb21wb25lbnQ7XG59KENvbXBvbmVudCkpO1xyXG5mdW5jdGlvbiB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIHZOb2RlLCBjb250YWluZXIsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgd3JhcHBlclZOb2RlID0gaW5mZXJuby5jcmVhdGVWTm9kZSg0LCBXcmFwcGVyQ29tcG9uZW50LCBudWxsLCBudWxsLCB7XHJcbiAgICAgICAgY2hpbGRyZW46IHZOb2RlLFxyXG4gICAgICAgIGNvbnRleHQ6IHBhcmVudENvbXBvbmVudC5jb250ZXh0XHJcbiAgICB9KTtcclxuICAgIHZhciBjb21wb25lbnQgPSBpbmZlcm5vLnJlbmRlcih3cmFwcGVyVk5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBjYWxsYmFjayBnZXRzIHRoZSBjb21wb25lbnQgYXMgY29udGV4dCwgbm8gb3RoZXIgYXJndW1lbnQuXHJcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcclxufVxyXG4vLyBDcmVkaXQ6IHByZWFjdC1jb21wYXQgLSBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC1jb21wYXRcclxudmFyIEVMRU1FTlRTID0gXCJhIGFiYnIgYWRkcmVzcyBhcmVhIGFydGljbGUgYXNpZGUgYXVkaW8gYiBiYXNlIGJkaSBiZG8gYmlnIGJsb2NrcXVvdGUgYm9keSBiciBidXR0b24gY2FudmFzIGNhcHRpb24gY2l0ZSBjb2RlIGNvbCBjb2xncm91cCBkYXRhIGRhdGFsaXN0IGRkIGRlbCBkZXRhaWxzIGRmbiBkaWFsb2cgZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWQgaGVhZGVyIGhncm91cCBociBodG1sIGkgaWZyYW1lIGltZyBpbnB1dCBpbnMga2JkIGtleWdlbiBsYWJlbCBsZWdlbmQgbGkgbGluayBtYWluIG1hcCBtYXJrIG1lbnUgbWVudWl0ZW0gbWV0YSBtZXRlciBuYXYgbm9zY3JpcHQgb2JqZWN0IG9sIG9wdGdyb3VwIG9wdGlvbiBvdXRwdXQgcCBwYXJhbSBwaWN0dXJlIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbCBzb3VyY2Ugc3BhbiBzdHJvbmcgc3R5bGUgc3ViIHN1bW1hcnkgc3VwIHRhYmxlIHRib2R5IHRkIHRleHRhcmVhIHRmb290IHRoIHRoZWFkIHRpbWUgdGl0bGUgdHIgdHJhY2sgdSB1bCB2YXIgdmlkZW8gd2JyIGNpcmNsZSBjbGlwUGF0aCBkZWZzIGVsbGlwc2UgZyBpbWFnZSBsaW5lIGxpbmVhckdyYWRpZW50IG1hc2sgcGF0aCBwYXR0ZXJuIHBvbHlnb24gcG9seWxpbmUgcmFkaWFsR3JhZGllbnQgcmVjdCBzdG9wIHN2ZyB0ZXh0IHRzcGFuXCIuc3BsaXQoXCIgXCIpO1xyXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5KHR5cGUpIHtcclxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XHJcbn1cclxudmFyIERPTSA9IHt9O1xyXG5mb3IgKHZhciBpID0gRUxFTUVOVFMubGVuZ3RoOyBpLS07KSB7XHJcbiAgICBET01bRUxFTUVOVFNbaV1dID0gY3JlYXRlRmFjdG9yeShFTEVNRU5UU1tpXSk7XHJcbn1cclxuLy8gTWFzayBSZWFjdCBnbG9iYWwgaW4gYnJvd3NlciBlbnZpb3JubWVudHMgd2hlbiBSZWFjdCBpcyBub3QgdXNlZC5cclxuaWYgKGlzQnJvd3NlciAmJiB0eXBlb2Ygd2luZG93LlJlYWN0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICB2YXIgZXhwb3J0cyQxID0ge1xyXG4gICAgICAgIENoaWxkcmVuOiBDaGlsZHJlbixcclxuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICBET006IERPTSxcclxuICAgICAgICBFTVBUWV9PQko6IGluZmVybm8uRU1QVFlfT0JKLFxyXG4gICAgICAgIE5PX09QOiBOT19PUCxcclxuICAgICAgICBQcm9wVHlwZXM6IFByb3BUeXBlcyxcclxuICAgICAgICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxyXG4gICAgICAgIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxyXG4gICAgICAgIGNsb25lVk5vZGU6IGluZmVybm8uY2xvbmVWTm9kZSxcclxuICAgICAgICBjcmVhdGVDbGFzczogY3JlYXRlQ2xhc3MsXHJcbiAgICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcclxuICAgICAgICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxyXG4gICAgICAgIGNyZWF0ZVZOb2RlOiBpbmZlcm5vLmNyZWF0ZVZOb2RlLFxyXG4gICAgICAgIGZpbmRET01Ob2RlOiBpbmZlcm5vLmZpbmRET01Ob2RlLFxyXG4gICAgICAgIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcclxuICAgICAgICByZW5kZXI6IGluZmVybm8ucmVuZGVyLFxyXG4gICAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGU6IHVubW91bnRDb21wb25lbnRBdE5vZGUsXHJcbiAgICAgICAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLFxyXG4gICAgICAgIHZlcnNpb246IHZlcnNpb25cclxuICAgIH07XHJcbiAgICB3aW5kb3cuUmVhY3QgPSBleHBvcnRzJDE7XHJcbiAgICB3aW5kb3cuUmVhY3RET00gPSBleHBvcnRzJDE7XHJcbn1cclxudmFyIGluZGV4ID0ge1xyXG4gICAgQ2hpbGRyZW46IENoaWxkcmVuLFxyXG4gICAgQ29tcG9uZW50OiBDb21wb25lbnQsXHJcbiAgICBET006IERPTSxcclxuICAgIEVNUFRZX09CSjogaW5mZXJuby5FTVBUWV9PQkosXHJcbiAgICBOT19PUDogTk9fT1AsXHJcbiAgICBQcm9wVHlwZXM6IFByb3BUeXBlcyxcclxuICAgIFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXHJcbiAgICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcclxuICAgIGNsb25lVk5vZGU6IGluZmVybm8uY2xvbmVWTm9kZSxcclxuICAgIGNyZWF0ZUNsYXNzOiBjcmVhdGVDbGFzcyxcclxuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXHJcbiAgICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxyXG4gICAgY3JlYXRlVk5vZGU6IGluZmVybm8uY3JlYXRlVk5vZGUsXHJcbiAgICBmaW5kRE9NTm9kZTogaW5mZXJuby5maW5kRE9NTm9kZSxcclxuICAgIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcclxuICAgIHJlbmRlcjogaW5mZXJuby5yZW5kZXIsXHJcbiAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiB1bm1vdW50Q29tcG9uZW50QXROb2RlLFxyXG4gICAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLFxyXG4gICAgdmVyc2lvbjogdmVyc2lvblxyXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuRE9NID0gRE9NO1xuZXhwb3J0cy5FTVBUWV9PQkogPSBpbmZlcm5vLkVNUFRZX09CSjtcbmV4cG9ydHMuTk9fT1AgPSBOT19PUDtcbmV4cG9ydHMuUHJvcFR5cGVzID0gUHJvcFR5cGVzO1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50O1xuZXhwb3J0cy5jbG9uZVZOb2RlID0gaW5mZXJuby5jbG9uZVZOb2RlO1xuZXhwb3J0cy5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVZOb2RlID0gaW5mZXJuby5jcmVhdGVWTm9kZTtcbmV4cG9ydHMuZmluZERPTU5vZGUgPSBpbmZlcm5vLmZpbmRET01Ob2RlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5yZW5kZXIgPSBpbmZlcm5vLnJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuZXhwb3J0c1snZGVmYXVsdCddID0gaW5kZXg7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdCcpLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG4iLCIvKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBpcyBjYW1lbC1jYXNlLlxuICovXG5cbnZhciBoYXNTcGFjZSA9IC9cXHMvXG52YXIgaGFzU2VwYXJhdG9yID0gLyhffC18XFwufDopL1xudmFyIGhhc0NhbWVsID0gLyhbYS16XVtBLVpdfFtBLVpdW2Etel0pL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9TbHVnQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHRvU3BhY2VDYXNlKHN0cmluZykucmVwbGFjZSgvXFxzL2csICctJylcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW55IHN0YXJ0aW5nIGNhc2UgZnJvbSBhIGBzdHJpbmdgLCBsaWtlIGNhbWVsIG9yIHNuYWtlLCBidXQga2VlcFxuICogc3BhY2VzIGFuZCBwdW5jdHVhdGlvbiB0aGF0IG1heSBiZSBpbXBvcnRhbnQgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Ob0Nhc2Uoc3RyaW5nKSB7XG4gIGlmIChoYXNTcGFjZS50ZXN0KHN0cmluZykpIHJldHVybiBzdHJpbmcudG9Mb3dlckNhc2UoKVxuICBpZiAoaGFzU2VwYXJhdG9yLnRlc3Qoc3RyaW5nKSkgcmV0dXJuICh1bnNlcGFyYXRlKHN0cmluZykgfHwgc3RyaW5nKS50b0xvd2VyQ2FzZSgpXG4gIGlmIChoYXNDYW1lbC50ZXN0KHN0cmluZykpIHJldHVybiB1bmNhbWVsaXplKHN0cmluZykudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvU3BhY2VDYXNlKHN0cmluZykge1xuICByZXR1cm4gdG9Ob0Nhc2Uoc3RyaW5nKS5yZXBsYWNlKC9bXFxXX10rKC58JCkvZywgZnVuY3Rpb24gKG1hdGNoZXMsIG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoID8gJyAnICsgbWF0Y2ggOiAnJ1xuICB9KS50cmltKClcbn1cblxuLyoqXG4gKiBTZXBhcmF0b3Igc3BsaXR0ZXIuXG4gKi9cblxudmFyIHNlcGFyYXRvclNwbGl0dGVyID0gL1tcXFdfXSsoLnwkKS9nXG5cbi8qKlxuICogVW4tc2VwYXJhdGUgYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gdW5zZXBhcmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHNlcGFyYXRvclNwbGl0dGVyLCBmdW5jdGlvbiAobSwgbmV4dCkge1xuICAgIHJldHVybiBuZXh0ID8gJyAnICsgbmV4dCA6ICcnXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxjYXNlIHNwbGl0dGVyLlxuICovXG5cbnZhciBjYW1lbFNwbGl0dGVyID0gLyguKShbQS1aXSspL2dcblxuLyoqXG4gKiBVbi1jYW1lbGNhc2UgYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHVuY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShjYW1lbFNwbGl0dGVyLCBmdW5jdGlvbiAobSwgcHJldmlvdXMsIHVwcGVycykge1xuICAgIHJldHVybiBwcmV2aW91cyArICcgJyArIHVwcGVycy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcnKS5qb2luKCcgJylcbiAgfSlcbn1cbiIsImltcG9ydCB7IHRvU2x1Z0Nhc2UgfSBmcm9tICcuL2Nhc2UtY29udmVydCc7XG5cbmNvbnN0IHVuaXF1ZUNhbGxTeW1ib2wgPSBTeW1ib2woJ3VuaXF1ZSBjYWxsJyksXG4gICAgZVN0YXRlU3ltYm9sID0gU3ltYm9sKCdleHRlbnNpb24gc3RhdGUnKTtcblxuLyogRW5oYW5jaW5nIGEgY3VzdG9tIGVsZW1lbnQgY2xhc3MgdGhhdCBleHRlbmRzIEhUTUxFbGVtZW50ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBc0N1c3RvbUVsZW1lbnQob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdHJlZVJlbmRlcmVyID0gZGVmYXVsdFRyZWVSZW5kZXJlcixcbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2ssXG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJvcHNFeHRyYWN0b3JTZWxlY3RvcixcbiAgICAgICAgcHJvcHNFeHRyYWN0b3IsXG4gICAgICAgIGNvbXB1dGUgPSB0cnVlLFxuICAgICAgICB0YWcsXG4gICAgfSA9IG9wdHM7XG5cbiAgICBjb25zdCB7IGNvbm5lY3QsIGRlY29yYXRlQ29tcG9uZW50IH0gPSBzdGF0ZT8gc3RhdGUob3B0cykgOiB7fTtcblxuICAgIC8vVE9ETyBtYXJraW5nIG1ldGhvZHMgb24gY29tcG9uZW50IGNsYXNzIGFzIEBFeHBvc2VPbkVsZW1lbnQoKVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcihCYXNlQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcywgZGVmYXVsdHMgfSA9IGV4dGVuZGVkUHJvcGVydGllcyhCYXNlQ29tcG9uZW50LnByb3BlcnRpZXMgfHwge30pO1xuXG4gICAgICAgIGNvbnN0IG9ic2VydmVkQXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICAgICAgICAvL1RPRE8gZmlsdGVyIG91dCBub24gYXR0cmlidXRlIHByb3BlcnRpZXNcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIGZ1bmN0aW9uIHRvIHVzZSBpbiBvdXRwdXQgb2Ygb3RoZXIgY29tcG9uZW50cyBkaXJlY3RseSByYXRoZXIgdGhhbiB1c2luZyB0aGUgdGFnLlxuICAgICAgICAgKlxuXG4gICAgICAgIGZ1bmN0aW9uIEJpZ2dlcihwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIDxDdXN0b21FbGVtZW50LmFzQ29tcG9uZW50IGE9ezF9IGI9XCIyXCIvPjtcbiAgICAgICAgfVxuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhc0NvbXBvbmVudChwcm9wcykge1xuICAgICAgICAgICAgLy9UT0RPIHByb3BzIDIgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gLSBjYWxsIGNvbnRlbnQgcmVuZGVyZXJcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQob3B0cy50YWcsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzIGN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgICAgICBzdGF0aWMgYXNDb21wb25lbnQgPSBhc0NvbXBvbmVudDtcblxuICAgICAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXNbZVN0YXRlU3ltYm9sXSA9IHRyZWVSZW5kZXJlcih0aGlzLCBCYXNlQ29tcG9uZW50LCBkZWNvcmF0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSB1bmlxdWVDYWxsKHRoaXMsICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZWRQcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc0V4dHJhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHByb3BzRXh0cmFjdG9yU2VsZWN0b3IgPyB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwocHJvcHNFeHRyYWN0b3JTZWxlY3RvcikgOiB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtYWRlIHZpYSBzdWItcmVuZGVyIGl0IHdpbGwgYmUgaW4gdk5vZGUuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnNlZWRQcm9wcywgcHJvcHNFeHRyYWN0b3IoQXJyYXkuZnJvbShjaGlsZHJlbiksIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IHRoaXNbZVN0YXRlU3ltYm9sXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdldFByb3BlcnRpZXModGhpcywgcHJvcGVydGllcywgZGVmYXVsdHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIDU0IGhhcyBuYXRpdmUgY3VzdG9tIGVsZW1lbnRzIGFuZCBpc24ndCBEUkUncyBpc3N1ZS4gVGhlIHNwZWMgc2F5cyBleHBsaWNpdGx5IHRoYXQgdGhpcyBlcnJvciB3aWxsIGJlIHRocm93biBpZiB5b3UgdHJ5IGFuZCBzZXQgYXR0cmlidXRlcyBpbiB0aGUgY29uc3RydWN0b3IuIFlvdSBjYW4gc2V0IHByb3BlcnRpZXMsIGJ1dCBhdHRyaWJ1dGVzIG1pc3QgYmUgZGVmZXJyZWQgdW50aWwgY29ubmVjdGVkQ2FsbGJhY2suXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2RlZmluZWQnLCcnKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoaXMgcGF0dGVybiBvZiBtaXhpbmcgaW50byBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGludGVybmFsLCBjb25uZWN0KHRoaXMsIHByb3BzLCBpbnRlcm5hbCkpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YXRlJywgeyBnZXQ6IGludGVybmFsLmdldFN0YXRlLCBzZXQ6IChjaGFuZ2UpID0+IGludGVybmFsLmRpc3BhdGNoKGFjdGlvbkZvckNoYW5nZShjaGFuZ2UpKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFsLmV4dHJhY3RTdGF0ZSkgaW50ZXJuYWwuZXh0cmFjdFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludGVybmFsLmNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkQ2FsbGJhY2spIGNvbm5lY3RlZENhbGxiYWNrKHRoaXMsIGludGVybmFsLmNvbXBvbmVudCwgcHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJuYWwucm9vdFJlbmRlcihwcm9wcyk7XG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50LmNvbXBvbmVudFdpbGxNb3VudCBpcyBjYWxsZWQgZHVyaW5nIGNyZWF0aW9uIGluZmVybm8vdXRpbHMgY3JlYXRlQ2xhc3NDb21wb25lbnRJbnN0YW5jZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gdGhpc1tlU3RhdGVTeW1ib2xdO1xuICAgICAgICAgICAgICAgIC8vVE9ETyBjYWNoZSBwcm9wZXJ0aWVzIHRvIG1ha2UgZ2V0UHJvcGVydGllcyBmYXN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHJlbmRlclxuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZXRQcm9wZXJ0aWVzKHRoaXMsIHByb3BlcnRpZXMsIGRlZmF1bHRzKTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyB0cmlnZ2VyIHByb3BzIHVwZGF0ZSBvbiBjb21wb25lbnQgaW5zdGVhZFxuXG4gICAgICAgICAgICAgICAgaW50ZXJuYWwucm9vdFJlbmRlcihwcm9wcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hhbmdlcyBhcmUgZG9uZSBieSBkaXNwYXRjaGluZyBzdG9yZSBhY3Rpb25zLiBgYWN0aW9uRm9yQ2hhbmdlYCBjYW4gYmUgc2VlbiBhcyB0aGUgcmV2ZXJzZVxuICAgICAgICAgICAgICogb2YgdGhlIHN0YXRlU2VsZWN0b3IuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vVE9ETyBqdXN0IGdvIHdpdGggZGlzcGF0Y2hcbiAgICAgICAgICAgIHNldFN0YXRlKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsLmRpc3BhdGNoKGFjdGlvbkZvckNoYW5nZShjaGFuZ2UpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSB0aGlzW2VTdGF0ZVN5bWJvbF07XG4gICAgICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3RlZENhbGxiYWNrKSBkaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMsIGludGVybmFsLmNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAvL1RPRE8gdW5tb3VudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBpbnRlcm5hbC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWcsIGN1c3RvbUVsZW1lbnQpOyAvLyBXZWIgQ29tcG9uZW50cyBBUEksIHBlcmhhcHMgcmVnaXN0ZXIgYW5kIHF1ZXVlIGZvciBvcmRlcmVkIHJlZ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXN0b21FbGVtZW50O1xuICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJlZVJlbmRlcmVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSgpIHsgfSxcbiAgICAgICAgZGVzdHJveSgpIHsgfSxcbiAgICAgICAgc2V0U3RhdGUoKSB7IH0sXG4gICAgICAgIHJvb3RSZW5kZXIoKSB7IH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdW5pcXVlQ2FsbChpbnN0YW5jZSwgbmFtZSkge1xuICAgIGNvbnN0IGZuID0gdHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicgPyBuYW1lIDogaW5zdGFuY2VbbmFtZV07XG5cbiAgICBpbnN0YW5jZVt1bmlxdWVDYWxsU3ltYm9sXSA9IFtdO1xuXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhc3RBcmdzID0gaW5zdGFuY2VbdW5pcXVlQ2FsbFN5bWJvbF07XG4gICAgICAgIGluc3RhbmNlW3VuaXF1ZUNhbGxTeW1ib2xdID0gYXJncztcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBwYXN0QXJncy5sZW5ndGgpIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJncyk7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPGFyZ3MubGVuZ3RoOyArK2kpIGlmIChhcmdzW2ldID09PSBwYXN0QXJnc1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuICAgIH07XG59XG5cbi8qXG5JbnRlcnByZXQgUG9seW1lciBsaWtlIHByb3BlcnRpZXNcbmh0dHBzOi8vd3d3LnBvbHltZXItcHJvamVjdC5vcmcvMS4wL2RvY3MvZGV2Z3VpZGUvcHJvcGVydGllc1xuXG5jb3VudDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICBub3RpZnk6IHRydWVcbiAgICB9XG4qL1xuXG5mdW5jdGlvbiBleHRlbmRlZFByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5yZWR1Y2UoKHJlc3VsdCwgcHJvcE5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICBsZXQgc2x1Z05hbWUgPSB0b1NsdWdDYXNlKHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvcC5hdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzbHVnTmFtZSA9IHByb3AuYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHJlc3VsdC5kZWZhdWx0c1twcm9wTmFtZV0gPSByZXN1bHQuZGVmYXVsdHNbc2x1Z05hbWVdID0gcHJvcC5kZWZhdWx0O1xuICAgICAgICByZXN1bHQucHJvcGVydGllc1twcm9wTmFtZV0gPSByZXN1bHQucHJvcGVydGllc1tzbHVnTmFtZV0gPSBtYWtlUHJvcChwcm9wTmFtZSwgc2x1Z05hbWUsIHByb3ApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHsgcHJvcGVydGllczoge30sIGRlZmF1bHRzOiB7fSB9KTtcblxuICAgIGZ1bmN0aW9uIG1ha2VQcm9wKGNvZGVOYW1lLCBzbHVnTmFtZSwgcHJvcCkge1xuICAgICAgICAvL2VuaGFuY2UgZnJvbSBDbGFzcyB0byBPYmplY3RcbiAgICAgICAgLy9UT0RPIGNvZXJjZSBmdW5jdGlvblxuICAgICAgICByZXR1cm4gdHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICAgICAgICB0eXBlOiBwcm9wLFxuICAgICAgICAgICAgY29kZU5hbWUsXG4gICAgICAgICAgICBzbHVnTmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvZXJjZTogKHZhbHVlKSA9PiB2YWx1ZSxcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIC4uLnByb3AsXG4gICAgICAgICAgICBjb2RlTmFtZSxcbiAgICAgICAgICAgIHNsdWdOYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlOiBwcm9wLmF0dHJpYnV0ZSAhPT0gZmFsc2UsXG4gICAgICAgICAgICBjb2VyY2U6IHByb3AuY29lcmNlIHx8ICgodmFsdWUpID0+IHZhbHVlKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vVE9ETyBidWlsZCBvbiBhdHRyczJwcm9wc1xuLy9UT0RPIGNvZXJjZSB0eXBlcyBmcm9tIGF0dHJpYnV0ZXNcbmZ1bmN0aW9uIGdldFByb3BlcnRpZXMoZWwsIHByb3BlcnRpZXMsIGRlZmF1bHRzKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IEFycmF5LmZyb20oZWwuYXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMucmVkdWNlKChyZXN1bHQsIGF0dHIpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbYXR0ci5uYW1lXTtcbiAgICAgICAgLyogcHJvcCBBUEk6XG4gICAgICAgICAgICBjb2VyY2UoKVxuICAgICAgICAgICAgYXR0cmlidXRlOiBzdHJpbmd8Ym9vbGVhblxuICAgICAgICAgICAgY29kZU5hbWVcbiAgICAgICAgICAgIHNsdWdOYW1lXG4gICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICovXG4gICAgICAgIGlmIChwcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0W3Byb3AuY29kZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2godHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcC5jb2RlTmFtZV0gPSBwcm9wLmNvZXJjZShhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChwcm9wLmNvZXJjZShhdHRyLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcC5jb2RlTmFtZV0gPSBbdmFsdWUsIHByb3AuY29lcmNlKGF0dHIudmFsdWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3AuY29kZU5hbWVdID0gcHJvcC5jb2VyY2UoYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LHsgLi4uZGVmYXVsdHMsIC4uLmVsLnNlZWRQcm9wcyB9KVxufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKGVsLCBvYnNlcnZlZEF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gb2JzZXJ2ZWRBdHRyaWJ1dGVzLnJlZHVjZSgocmVzdWx0LCBuYW1lKSA9PiB7IHJlc3VsdFtuYW1lXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTsgcmV0dXJuIHJlc3VsdDsgfSx7fSlcbn1cblxuXG4vKlRPRE8gbGVhcm4gZnJvbSBTa2F0ZSBKU1xuXG5zdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcyAoKSB7XG4gICAgY29uc3QgYXR0cnNPbkN0b3IgPSB0aGlzLmhhc093blByb3BlcnR5KCRjdG9yT2JzZXJ2ZWRBdHRyaWJ1dGVzKSA/IHRoaXNbJGN0b3JPYnNlcnZlZEF0dHJpYnV0ZXNdIDogW107XG4gICAgY29uc3QgcHJvcERlZnMgPSBnZXRQcm9wc01hcCh0aGlzKTtcblxuICAgIC8vIFVzZSBPYmplY3Qua2V5cyB0byBza2lwcyBzeW1ib2wgcHJvcHMgc2luY2UgdGhleSBoYXZlIG5vIGxpbmtlZCBhdHRyaWJ1dGVzXG4gICAgY29uc3QgYXR0cnNGcm9tTGlua2VkUHJvcHMgPSBPYmplY3Qua2V5cyhwcm9wRGVmcykubWFwKHByb3BOYW1lID0+XG4gICAgICBwcm9wRGVmc1twcm9wTmFtZV0uYXR0clNvdXJjZSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgY29uc3QgYWxsID0gYXR0cnNGcm9tTGlua2VkUHJvcHMuY29uY2F0KGF0dHJzT25DdG9yKS5jb25jYXQoc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gYWxsLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+XG4gICAgICBhbGwuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpO1xuICB9XG5cbiAgc3RhdGljIHNldCBvYnNlcnZlZEF0dHJpYnV0ZXMgKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgc2V0Q3Rvck5hdGl2ZVByb3BlcnR5KHRoaXMsICdvYnNlcnZlZEF0dHJpYnV0ZXMnLCB2YWx1ZSk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHN1cGVyY2xhc3MgcHJvcHMgb3ZlcndyaXR0ZW4gd2l0aCB0aGlzIENvbXBvbmVudCBwcm9wc1xuICBzdGF0aWMgZ2V0IHByb3BzICgpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCBzdXBlci5wcm9wcywgdGhpc1skY3RvclByb3BzXSk7XG4gIH1cblxuICBzdGF0aWMgc2V0IHByb3BzICh2YWx1ZSkge1xuICAgIHNldEN0b3JOYXRpdmVQcm9wZXJ0eSh0aGlzLCAkY3RvclByb3BzLCB2YWx1ZSk7XG4gIH1cblxuXG5cbiAgdXBkYXRlOlxuICBjb25zdCBwcm9wTmFtZU9yU3ltYm9sID0gZGF0YSh0aGlzLCAnYXR0clNvdXJjZUxpbmtzJylbbmFtZV07XG4gIGlmIChwcm9wTmFtZU9yU3ltYm9sKSB7XG4gICAgY29uc3QgY2hhbmdlZEV4dGVybmFsbHkgPSBnZXRBdHRyTWdyKHRoaXMpLm9uQXR0cmlidXRlQ2hhbmdlZChuYW1lLCBuZXdWYWx1ZSk7XG4gICAgaWYgKGNoYW5nZWRFeHRlcm5hbGx5KSB7XG4gICAgICAvLyBTeW5jIHVwIHRoZSBwcm9wZXJ0eS5cbiAgICAgIGNvbnN0IHByb3BEZWYgPSBnZXRQcm9wc01hcCh0aGlzLmNvbnN0cnVjdG9yKVtwcm9wTmFtZU9yU3ltYm9sXTtcbiAgICAgIGNvbnN0IG5ld1Byb3BWYWwgPSBuZXdWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wRGVmLmRlc2VyaWFsaXplXG4gICAgICAgID8gcHJvcERlZi5kZXNlcmlhbGl6ZShuZXdWYWx1ZSlcbiAgICAgICAgOiBuZXdWYWx1ZTtcblxuICAgICAgY29uc3QgcHJvcERhdGEgPSBkYXRhKHRoaXMsICdwcm9wcycpW3Byb3BOYW1lT3JTeW1ib2xdO1xuICAgICAgcHJvcERhdGEuc2V0dGluZ1Byb3BGcm9tQXR0clNvdXJjZSA9IHRydWU7XG4gICAgICB0aGlzW3Byb3BOYW1lT3JTeW1ib2xdID0gbmV3UHJvcFZhbDtcbiAgICAgIHByb3BEYXRhLnNldHRpbmdQcm9wRnJvbUF0dHJTb3VyY2UgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBERVBSRUNBVEVEXG4gIC8vXG4gIC8vIHN0YXRpYyBhdHRyaWJ1dGVDaGFuZ2VkKClcbiAgY29uc3QgeyBhdHRyaWJ1dGVDaGFuZ2VkIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICBpZiAoaXNGdW5jdGlvbihhdHRyaWJ1dGVDaGFuZ2VkKSkge1xuICAgIGRlcHJlY2F0ZWQodGhpcywgJ3N0YXRpYyBhdHRyaWJ1dGVDaGFuZ2VkJywgJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycpO1xuICAgIGF0dHJpYnV0ZUNoYW5nZWQodGhpcywgeyBuYW1lLCBuZXdWYWx1ZSwgb2xkVmFsdWUgfSk7XG4gIH1cblxuXG5cbiovXG4iLCJpbXBvcnQgeyBjcmVhdGVWTm9kZSwgZ2V0RmxhZ3NGb3JFbGVtZW50Vm5vZGUgfSBmcm9tICdpbmZlcm5vJztcblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJuby1TaGFyZWRcclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZihvKSB7XHJcbiAgICByZXR1cm4gaXNVbmRlZmluZWQobykgfHwgaXNOdWxsKG8pO1xyXG59XHJcbmZ1bmN0aW9uIGlzSW52YWxpZChvKSB7XHJcbiAgICByZXR1cm4gaXNOdWxsKG8pIHx8IG8gPT09IGZhbHNlIHx8IGlzVHJ1ZShvKSB8fCBpc1VuZGVmaW5lZChvKTtcclxufVxyXG5mdW5jdGlvbiBpc1N0cmluZyhvKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XHJcbn1cclxuZnVuY3Rpb24gaXNOdWxsKG8pIHtcclxuICAgIHJldHVybiBvID09PSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGlzVHJ1ZShvKSB7XHJcbiAgICByZXR1cm4gbyA9PT0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvKSB7XHJcbiAgICByZXR1cm4gbyA9PT0gdm9pZCAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcclxuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIjtcclxufVxuXG4vKipcclxuICogQG1vZHVsZSBJbmZlcm5vLUNyZWF0ZS1FbGVtZW50XHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbnZhciBjb21wb25lbnRIb29rcyA9IG5ldyBTZXQoKTtcclxuY29tcG9uZW50SG9va3MuYWRkKFwib25Db21wb25lbnRXaWxsTW91bnRcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50RGlkTW91bnRcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50V2lsbFVubW91bnRcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50U2hvdWxkVXBkYXRlXCIpO1xyXG5jb21wb25lbnRIb29rcy5hZGQoXCJvbkNvbXBvbmVudFdpbGxVcGRhdGVcIik7XHJcbmNvbXBvbmVudEhvb2tzLmFkZChcIm9uQ29tcG9uZW50RGlkVXBkYXRlXCIpO1xyXG4vKipcclxuICogQ3JlYXRlcyB2aXJ0dWFsIG5vZGVcclxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb258Q29tcG9uZW50PGFueSwgYW55Pn0gdHlwZSBUeXBlIG9mIG5vZGVcclxuICogQHBhcmFtIHtvYmplY3Q9fSBwcm9wcyBPcHRpb25hbCBwcm9wcyBmb3IgdmlydHVhbCBub2RlXHJcbiAqIEBwYXJhbSB7Li4ue29iamVjdH09fSBfY2hpbGRyZW4gT3B0aW9uYWwgY2hpbGRyZW4gZm9yIHZpcnR1YWwgbm9kZVxyXG4gKiBAcmV0dXJucyB7Vk5vZGV9IG5ldyB2aXJ0dWFsIG5kb2VcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgX2NoaWxkcmVuID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgX2NoaWxkcmVuWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXHJcbiAgICBpZiAoaXNJbnZhbGlkKHR5cGUpIHx8IGlzT2JqZWN0KHR5cGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5mZXJubyBFcnJvcjogY3JlYXRlRWxlbWVudCgpIG5hbWUgcGFyYW1ldGVyIGNhbm5vdCBiZSB1bmRlZmluZWQsIG51bGwsIGZhbHNlIG9yIHRydWUsIEl0IG11c3QgYmUgYSBzdHJpbmcsIGNsYXNzIG9yIGZ1bmN0aW9uLlwiKTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZHJlbiA9IF9jaGlsZHJlbjtcclxuICAgIHZhciByZWYgPSBudWxsO1xyXG4gICAgdmFyIGtleSA9IG51bGw7XHJcbiAgICB2YXIgY2xhc3NOYW1lID0gbnVsbDtcclxuICAgIHZhciBmbGFncyA9IDA7XHJcbiAgICB2YXIgbmV3UHJvcHM7XHJcbiAgICBpZiAoX2NoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKF9jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBfY2hpbGRyZW5bMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF9jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RyaW5nKHR5cGUpKSB7XHJcbiAgICAgICAgZmxhZ3MgPSBnZXRGbGFnc0ZvckVsZW1lbnRWbm9kZSh0eXBlKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYocHJvcHMpKSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcImNsYXNzTmFtZVwiIHx8IHByb3AgPT09IFwiY2xhc3NcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByb3BzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gXCJrZXlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByb3BzLmtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3AgPT09IFwiY2hpbGRyZW5cIiAmJiBpc1VuZGVmaW5lZChjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuOyAvLyBhbHdheXMgZmF2b3VyIGNoaWxkcmVuIGFyZ3MsIGRlZmF1bHQgdG8gcHJvcHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3AgPT09IFwicmVmXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWYgPSBwcm9wcy5yZWY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1twcm9wXSA9IHByb3BzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmxhZ3MgPSAxNiAvKiBDb21wb25lbnRVbmtub3duICovO1xyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYocHJvcHMpKSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AkMSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEhvb2tzLmhhcyhwcm9wJDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlZltwcm9wJDFdID0gcHJvcHNbcHJvcCQxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3AkMSA9PT0gXCJrZXlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByb3BzLmtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW3Byb3AkMV0gPSBwcm9wc1twcm9wJDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGZsYWdzLCB0eXBlLCBjbGFzc05hbWUsIGNoaWxkcmVuLCBuZXdQcm9wcywga2V5LCByZWYpO1xyXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUVsZW1lbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tVm5vZGUtRmxhZ3NcclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxudmFyIFZOb2RlRmxhZ3M7XHJcbihmdW5jdGlvbiAoVk5vZGVGbGFncykge1xyXG4gICAgVk5vZGVGbGFnc1tWTm9kZUZsYWdzW1wiVGV4dFwiXSA9IDFdID0gXCJUZXh0XCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJIdG1sRWxlbWVudFwiXSA9IDJdID0gXCJIdG1sRWxlbWVudFwiO1xyXG4gICAgVk5vZGVGbGFnc1tWTm9kZUZsYWdzW1wiQ29tcG9uZW50Q2xhc3NcIl0gPSA0XSA9IFwiQ29tcG9uZW50Q2xhc3NcIjtcclxuICAgIFZOb2RlRmxhZ3NbVk5vZGVGbGFnc1tcIkNvbXBvbmVudEZ1bmN0aW9uXCJdID0gOF0gPSBcIkNvbXBvbmVudEZ1bmN0aW9uXCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJDb21wb25lbnRVbmtub3duXCJdID0gMTZdID0gXCJDb21wb25lbnRVbmtub3duXCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJIYXNLZXllZENoaWxkcmVuXCJdID0gMzJdID0gXCJIYXNLZXllZENoaWxkcmVuXCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJIYXNOb25LZXllZENoaWxkcmVuXCJdID0gNjRdID0gXCJIYXNOb25LZXllZENoaWxkcmVuXCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJTdmdFbGVtZW50XCJdID0gMTI4XSA9IFwiU3ZnRWxlbWVudFwiO1xyXG4gICAgVk5vZGVGbGFnc1tWTm9kZUZsYWdzW1wiTWVkaWFFbGVtZW50XCJdID0gMjU2XSA9IFwiTWVkaWFFbGVtZW50XCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJJbnB1dEVsZW1lbnRcIl0gPSA1MTJdID0gXCJJbnB1dEVsZW1lbnRcIjtcclxuICAgIFZOb2RlRmxhZ3NbVk5vZGVGbGFnc1tcIlRleHRhcmVhRWxlbWVudFwiXSA9IDEwMjRdID0gXCJUZXh0YXJlYUVsZW1lbnRcIjtcclxuICAgIFZOb2RlRmxhZ3NbVk5vZGVGbGFnc1tcIlNlbGVjdEVsZW1lbnRcIl0gPSAyMDQ4XSA9IFwiU2VsZWN0RWxlbWVudFwiO1xyXG4gICAgVk5vZGVGbGFnc1tWTm9kZUZsYWdzW1wiVm9pZFwiXSA9IDQwOTZdID0gXCJWb2lkXCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJGb3JtRWxlbWVudFwiXSA9IDM1ODRdID0gXCJGb3JtRWxlbWVudFwiO1xyXG4gICAgVk5vZGVGbGFnc1tWTm9kZUZsYWdzW1wiRWxlbWVudFwiXSA9IDM5NzBdID0gXCJFbGVtZW50XCI7XHJcbiAgICBWTm9kZUZsYWdzW1ZOb2RlRmxhZ3NbXCJDb21wb25lbnRcIl0gPSAyOF0gPSBcIkNvbXBvbmVudFwiO1xyXG59KShWTm9kZUZsYWdzIHx8IChWTm9kZUZsYWdzID0ge30pKTtcclxudmFyIFZOb2RlRmxhZ3MkMSA9IFZOb2RlRmxhZ3M7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZOb2RlRmxhZ3MkMTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0JykuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ2luZmVybm8nO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdpbmZlcm5vLWNvbXBvbmVudCc7XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tU2hhcmVkXHJcbiAqLyAvKiogVHlwZURvYyBDb21tZW50ICovXHJcbi8vIHRoaXMgaXMgTVVDSCBmYXN0ZXIgdGhhbiAuY29uc3RydWN0b3IgPT09IEFycmF5IGFuZCBpbnN0YW5jZW9mIEFycmF5XHJcbi8vIGluIE5vZGUgNyBhbmQgdGhlIGxhdGVyIHZlcnNpb25zIG9mIFY4LCBzbG93ZXIgaW4gb2xkZXIgdmVyc2lvbnMgdGhvdWdoXHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChvKSB7XHJcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkKG8ucHJvdG90eXBlKSAmJiAhaXNVbmRlZmluZWQoby5wcm90b3R5cGUucmVuZGVyKTtcclxufVxyXG5mdW5jdGlvbiBpc1N0cmluZ09yTnVtYmVyKG8pIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIG87XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzSW52YWxpZChvKSB7XHJcbiAgICByZXR1cm4gaXNOdWxsKG8pIHx8IG8gPT09IGZhbHNlIHx8IGlzVHJ1ZShvKSB8fCBpc1VuZGVmaW5lZChvKTtcclxufVxyXG5mdW5jdGlvbiBpc051bGwobykge1xyXG4gICAgcmV0dXJuIG8gPT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNUcnVlKG8pIHtcclxuICAgIHJldHVybiBvID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcclxuICAgIHJldHVybiBvID09PSB2b2lkIDA7XHJcbn1cclxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm9iamVjdFwiO1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tRGV2dG9vbHNcclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxuZnVuY3Rpb24gZmluZFZOb2RlRnJvbURvbSh2Tm9kZSwgZG9tKSB7XHJcbiAgICBpZiAoIXZOb2RlKSB7XHJcbiAgICAgICAgdmFyIHJvb3RzID0gb3B0aW9ucy5yb290cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHJvb3QgPSByb290c1tpXTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZpbmRWTm9kZUZyb21Eb20ocm9vdC5pbnB1dCwgZG9tKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICh2Tm9kZS5kb20gPT09IGRvbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdk5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmbGFncyA9IHZOb2RlLmZsYWdzO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGlmIChmbGFncyAmIDI4IC8qIENvbXBvbmVudCAqLykge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLl9sYXN0SW5wdXQgfHwgY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxlbiQxID0gY2hpbGRyZW4ubGVuZ3RoOyBpJDEgPCBsZW4kMTsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpJDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0JDEgPSBmaW5kVk5vZGVGcm9tRG9tKGNoaWxkLCBkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0JDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQkMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQkMiA9IGZpbmRWTm9kZUZyb21Eb20oY2hpbGRyZW4sIGRvbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0JDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0JDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxudmFyIGluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiBnZXRLZXlGb3JWTm9kZSh2Tm9kZSkge1xyXG4gICAgdmFyIGZsYWdzID0gdk5vZGUuZmxhZ3M7XHJcbiAgICBpZiAoZmxhZ3MgJiA0IC8qIENvbXBvbmVudENsYXNzICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHZOb2RlLmNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZOb2RlLmRvbTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21WTm9kZSh2Tm9kZSkge1xyXG4gICAgdmFyIGtleSA9IGdldEtleUZvclZOb2RlKHZOb2RlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZU1hcC5nZXQoa2V5KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZyb21WTm9kZSh2Tm9kZSwgaW5zdGFuY2UpIHtcclxuICAgIHZhciBrZXkgPSBnZXRLZXlGb3JWTm9kZSh2Tm9kZSk7XHJcbiAgICBpbnN0YW5jZU1hcC5zZXQoa2V5LCBpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlSW5zdGFuY2VGb3JWTm9kZSh2Tm9kZSkge1xyXG4gICAgdmFyIGtleSA9IGdldEtleUZvclZOb2RlKHZOb2RlKTtcclxuICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBicmlkZ2UgZm9yIGV4cG9zaW5nIEluZmVybm8ncyBjb21wb25lbnQgdHJlZSB0byBSZWFjdCBEZXZUb29scy5cclxuICpcclxuICogSXQgY3JlYXRlcyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGludGVyZmFjZXMgdGhhdCBSZWFjdERPTSBwYXNzZXMgdG9cclxuICogZGV2dG9vbHMgdG8gZW5hYmxlIGl0IHRvIHF1ZXJ5IHRoZSBjb21wb25lbnQgdHJlZSBhbmQgaG9vayBpbnRvIGNvbXBvbmVudFxyXG4gKiB1cGRhdGVzLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvNTlmZjc3NDllZGEwY2Q4NThkNWVlNTY4MzE1YmNiYTFiZTc1YTFjYS9zcmMvcmVuZGVyZXJzL2RvbS9SZWFjdERPTS5qc1xyXG4gKiBmb3IgaG93IFJlYWN0RE9NIGV4cG9ydHMgaXRzIGludGVybmFscyBmb3IgdXNlIGJ5IHRoZSBkZXZ0b29scyBhbmRcclxuICogdGhlIGBhdHRhY2hSZW5kZXJlcigpYCBmdW5jdGlvbiBpblxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtZGV2dG9vbHMvYmxvYi9lMzFlYzU4MjUzNDJlZGE1NzBhY2ZjOWJjYjQzYTQ0MjU4ZmNlYjI4L2JhY2tlbmQvYXR0YWNoUmVuZGVyZXIuanNcclxuICogZm9yIGhvdyB0aGUgZGV2dG9vbHMgY29uc3VtZXMgdGhlIHJlc3VsdGluZyBvYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRGV2VG9vbHNCcmlkZ2UoKSB7XHJcbiAgICB2YXIgQ29tcG9uZW50VHJlZSA9IHtcclxuICAgICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5ub2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGRvbSkge1xyXG4gICAgICAgICAgICB2YXIgdk5vZGUgPSBmaW5kVk5vZGVGcm9tRG9tKG51bGwsIGRvbSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2Tm9kZSA/IHVwZGF0ZVJlYWN0Q29tcG9uZW50KHZOb2RlLCBudWxsKSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIE1hcCBvZiByb290IElEICh0aGUgSUQgaXMgdW5pbXBvcnRhbnQpIHRvIGNvbXBvbmVudCBpbnN0YW5jZS5cclxuICAgIHZhciByb290cyA9IHt9O1xyXG4gICAgZmluZFJvb3RzKHJvb3RzKTtcclxuICAgIHZhciBNb3VudCA9IHtcclxuICAgICAgICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogcm9vdHMsXHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5XHJcbiAgICAgICAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIF9yZW5kZXJOZXdSb290Q29tcG9uZW50KGluc3RhbmNlKSB7IH1cclxuICAgIH07XHJcbiAgICB2YXIgUmVjb25jaWxlciA9IHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcclxuICAgICAgICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gbW91bnRDb21wb25lbnQoaW5zdGFuY2UpIHsgfSxcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcclxuICAgICAgICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShpbnN0YW5jZSkgeyB9LFxyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1lbXB0eVxyXG4gICAgICAgIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIHJlY2VpdmVDb21wb25lbnQoaW5zdGFuY2UpIHsgfSxcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcclxuICAgICAgICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50KGluc3RhbmNlKSB7IH1cclxuICAgIH07XHJcbiAgICB2YXIgcXVldWVkTW91bnRDb21wb25lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIHF1ZXVlZFJlY2VpdmVDb21wb25lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIHF1ZXVlZFVubW91bnRDb21wb25lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIHF1ZXVlVXBkYXRlID0gZnVuY3Rpb24gKHVwZGF0ZXIsIG1hcCwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKCFtYXAuaGFzKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgbWFwLnNldChjb21wb25lbnQsIHRydWUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlcihjb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHF1ZXVlTW91bnRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7IHJldHVybiBxdWV1ZVVwZGF0ZShSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50LCBxdWV1ZWRNb3VudENvbXBvbmVudHMsIGNvbXBvbmVudCk7IH07XHJcbiAgICB2YXIgcXVldWVSZWNlaXZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkgeyByZXR1cm4gcXVldWVVcGRhdGUoUmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50LCBxdWV1ZWRSZWNlaXZlQ29tcG9uZW50cywgY29tcG9uZW50KTsgfTtcclxuICAgIHZhciBxdWV1ZVVubW91bnRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7IHJldHVybiBxdWV1ZVVwZGF0ZShSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQsIHF1ZXVlZFVubW91bnRDb21wb25lbnRzLCBjb21wb25lbnQpOyB9O1xyXG4gICAgLyoqIE5vdGlmeSBkZXZ0b29scyB0aGF0IGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZSBoYXMgYmVlbiBtb3VudGVkIGludG8gdGhlIERPTS4gKi9cclxuICAgIHZhciBjb21wb25lbnRBZGRlZCA9IGZ1bmN0aW9uICh2Tm9kZSkge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHVwZGF0ZVJlYWN0Q29tcG9uZW50KHZOb2RlLCBudWxsKTtcclxuICAgICAgICBpZiAoaXNSb290Vk5vZGUodk5vZGUpKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9yb290SUQgPSBuZXh0Um9vdEtleShyb290cyk7XHJcbiAgICAgICAgICAgIHJvb3RzW2luc3RhbmNlLl9yb290SURdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmlzaXROb25Db21wb3NpdGVDaGlsZHJlbihpbnN0YW5jZSwgZnVuY3Rpb24gKGNoaWxkSW5zdCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRJbnN0KSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZEluc3QuX2luRGV2VG9vbHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcXVldWVNb3VudENvbXBvbmVudChjaGlsZEluc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcXVldWVNb3VudENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIE5vdGlmeSBkZXZ0b29scyB0aGF0IGEgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWQgd2l0aCBuZXcgcHJvcHMvc3RhdGUuICovXHJcbiAgICB2YXIgY29tcG9uZW50VXBkYXRlZCA9IGZ1bmN0aW9uICh2Tm9kZSkge1xyXG4gICAgICAgIHZhciBwcmV2UmVuZGVyZWRDaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHZpc2l0Tm9uQ29tcG9zaXRlQ2hpbGRyZW4oZ2V0SW5zdGFuY2VGcm9tVk5vZGUodk5vZGUpLCBmdW5jdGlvbiAoY2hpbGRJbnN0KSB7XHJcbiAgICAgICAgICAgIHByZXZSZW5kZXJlZENoaWxkcmVuLnB1c2goY2hpbGRJbnN0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBOb3RpZnkgZGV2dG9vbHMgYWJvdXQgdXBkYXRlcyB0byB0aGlzIGNvbXBvbmVudCBhbmQgYW55IG5vbi1jb21wb3NpdGVcclxuICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHVwZGF0ZVJlYWN0Q29tcG9uZW50KHZOb2RlLCBudWxsKTtcclxuICAgICAgICBxdWV1ZVJlY2VpdmVDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgICAgIHZpc2l0Tm9uQ29tcG9zaXRlQ2hpbGRyZW4oaW5zdGFuY2UsIGZ1bmN0aW9uIChjaGlsZEluc3QpIHtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZEluc3QuX2luRGV2VG9vbHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5ldyBET00gY2hpbGQgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBjaGlsZEluc3QuX2luRGV2VG9vbHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcXVldWVNb3VudENvbXBvbmVudChjaGlsZEluc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlZCBET00gY2hpbGQgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVJlY2VpdmVDb21wb25lbnQoY2hpbGRJbnN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEZvciBhbnkgbm9uLWNvbXBvc2l0ZSBjaGlsZHJlbiB0aGF0IHdlcmUgcmVtb3ZlZCBieSB0aGUgbGF0ZXN0IHJlbmRlcixcclxuICAgICAgICAvLyByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgUmVhY3RET01Db21wb25lbnQtbGlrZSBpbnN0YW5jZXMgYW5kIG5vdGlmeVxyXG4gICAgICAgIC8vIHRoZSBkZXZ0b29sc1xyXG4gICAgICAgIHByZXZSZW5kZXJlZENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkSW5zdCkge1xyXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoY2hpbGRJbnN0Lm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVJbnN0YW5jZUZvclZOb2RlKGNoaWxkSW5zdC52Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVVubW91bnRDb21wb25lbnQoY2hpbGRJbnN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBOb3RpZnkgZGV2dG9vbHMgdGhhdCBhIGNvbXBvbmVudCBoYXMgYmVlbiB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLiAqL1xyXG4gICAgdmFyIGNvbXBvbmVudFJlbW92ZWQgPSBmdW5jdGlvbiAodk5vZGUpIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSB1cGRhdGVSZWFjdENvbXBvbmVudCh2Tm9kZSwgbnVsbCk7XHJcbiAgICAgICAgdmlzaXROb25Db21wb3NpdGVDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGRJbnN0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZUluc3RhbmNlRm9yVk5vZGUoY2hpbGRJbnN0LnZOb2RlKTtcclxuICAgICAgICAgICAgcXVldWVVbm1vdW50Q29tcG9uZW50KGNoaWxkSW5zdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcXVldWVVbm1vdW50Q29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgICAgICBkZWxldGVJbnN0YW5jZUZvclZOb2RlKHZOb2RlKTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UuX3Jvb3RJRCkge1xyXG4gICAgICAgICAgICBkZWxldGUgcm9vdHNbaW5zdGFuY2UuX3Jvb3RJRF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgQ29tcG9uZW50VHJlZTogQ29tcG9uZW50VHJlZSxcclxuICAgICAgICBNb3VudDogTW91bnQsXHJcbiAgICAgICAgUmVjb25jaWxlcjogUmVjb25jaWxlcixcclxuICAgICAgICBjb21wb25lbnRBZGRlZDogY29tcG9uZW50QWRkZWQsXHJcbiAgICAgICAgY29tcG9uZW50UmVtb3ZlZDogY29tcG9uZW50UmVtb3ZlZCxcclxuICAgICAgICBjb21wb25lbnRVcGRhdGVkOiBjb21wb25lbnRVcGRhdGVkXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUm9vdFZOb2RlKHZOb2RlKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb3B0aW9ucy5yb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHZhciByb290ID0gb3B0aW9ucy5yb290c1tpXTtcclxuICAgICAgICBpZiAocm9vdC5pbnB1dCA9PT0gdk5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVcGRhdGUgKGFuZCBjcmVhdGUgaWYgbmVjZXNzYXJ5KSB0aGUgUmVhY3RET01Db21wb25lbnR8UmVhY3RDb21wb3NpdGVDb21wb25lbnQtbGlrZVxyXG4gKiBpbnN0YW5jZSBmb3IgYSBnaXZlbiBJbmZlcm5vIGNvbXBvbmVudCBpbnN0YW5jZSBvciBET00gTm9kZS5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZVJlYWN0Q29tcG9uZW50KHZOb2RlLCBwYXJlbnREb20pIHtcclxuICAgIGlmICghdk5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBmbGFncyA9IHZOb2RlLmZsYWdzO1xyXG4gICAgdmFyIG9sZEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tVk5vZGUodk5vZGUpO1xyXG4gICAgdmFyIG5ld0luc3RhbmNlO1xyXG4gICAgaWYgKGZsYWdzICYgMjggLyogQ29tcG9uZW50ICovKSB7XHJcbiAgICAgICAgbmV3SW5zdGFuY2UgPSBjcmVhdGVSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCh2Tm9kZSwgaXNVbmRlZmluZWQob2xkSW5zdGFuY2UpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld0luc3RhbmNlID0gY3JlYXRlUmVhY3RET01Db21wb25lbnQodk5vZGUsIHBhcmVudERvbSk7XHJcbiAgICB9XHJcbiAgICBpZiAob2xkSW5zdGFuY2UpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgb2xkSW5zdGFuY2Vba2V5XSA9IG5ld0luc3RhbmNlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvbGRJbnN0YW5jZTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUluc3RhbmNlRnJvbVZOb2RlKHZOb2RlLCBuZXdJbnN0YW5jZSk7XHJcbiAgICByZXR1cm4gbmV3SW5zdGFuY2U7XHJcbn1cclxuZnVuY3Rpb24gaXNJbnZhbGlkQ2hpbGQoY2hpbGQpIHtcclxuICAgIHJldHVybiBpc0ludmFsaWQoY2hpbGQpIHx8IGNoaWxkID09PSBcIlwiO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuLCBkb20pIHtcclxuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgIHJldHVybiBjaGlsZHJlblxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gIWlzSW52YWxpZENoaWxkKGNoaWxkKTsgfSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIHVwZGF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCBkb20pOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhKGlzSW52YWxpZENoaWxkKGNoaWxkcmVuKSB8fCBjaGlsZHJlbiA9PT0gXCJcIilcclxuICAgICAgICAgICAgPyBbdXBkYXRlUmVhY3RDb21wb25lbnQoY2hpbGRyZW4sIGRvbSldXHJcbiAgICAgICAgICAgIDogW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIFJlYWN0RE9NQ29tcG9uZW50LWNvbXBhdGlibGUgb2JqZWN0IGZvciBhIGdpdmVuIERPTSBub2RlIHJlbmRlcmVkXHJcbiAqIGJ5IEluZmVybm8uXHJcbiAqXHJcbiAqIFRoaXMgaW1wbGVtZW50cyB0aGUgc3Vic2V0IG9mIHRoZSBSZWFjdERPTUNvbXBvbmVudCBpbnRlcmZhY2UgdGhhdFxyXG4gKiBSZWFjdCBEZXZUb29scyByZXF1aXJlcyBpbiBvcmRlciB0byBkaXNwbGF5IERPTSBub2RlcyBpbiB0aGUgaW5zcGVjdG9yIHdpdGhcclxuICogdGhlIGNvcnJlY3QgdHlwZSBhbmQgcHJvcGVydGllcy5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0RE9NQ29tcG9uZW50KHZOb2RlLCBwYXJlbnREb20pIHtcclxuICAgIHZhciBmbGFncyA9IHZOb2RlLmZsYWdzO1xyXG4gICAgaWYgKGZsYWdzICYgNDA5NiAvKiBWb2lkICovKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgdHlwZSA9IHZOb2RlLnR5cGU7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbiA9PT0gMCA/IHZOb2RlLmNoaWxkcmVuLnRvU3RyaW5nKCkgOiB2Tm9kZS5jaGlsZHJlbjtcclxuICAgIHZhciBwcm9wcyA9IHZOb2RlLnByb3BzO1xyXG4gICAgdmFyIGRvbSA9IHZOb2RlLmRvbTtcclxuICAgIHZhciBpc1RleHQgPSBmbGFncyAmIDEgLyogVGV4dCAqLyB8fCBpc1N0cmluZ09yTnVtYmVyKHZOb2RlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX2N1cnJlbnRFbGVtZW50OiBpc1RleHRcclxuICAgICAgICAgICAgPyBjaGlsZHJlbiB8fCB2Tm9kZVxyXG4gICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBfaW5EZXZUb29sczogZmFsc2UsXHJcbiAgICAgICAgX3JlbmRlcmVkQ2hpbGRyZW46ICFpc1RleHQgJiYgbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4sIGRvbSksXHJcbiAgICAgICAgX3N0cmluZ1RleHQ6IGlzVGV4dCA/IChjaGlsZHJlbiB8fCB2Tm9kZSkudG9TdHJpbmcoKSA6IG51bGwsXHJcbiAgICAgICAgbm9kZTogZG9tIHx8IHBhcmVudERvbSxcclxuICAgICAgICB2Tm9kZTogdk5vZGVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xyXG4gICAgaWYgKGtleSAmJiBrZXlbMF0gPT09IFwiLlwiKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LWNvbXBhdGlibGUgb2JqZWN0IGZvciBhIGdpdmVuIEluZmVybm9cclxuICogY29tcG9uZW50IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBUaGlzIGltcGxlbWVudHMgdGhlIHN1YnNldCBvZiB0aGUgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW50ZXJmYWNlIHRoYXRcclxuICogdGhlIERldlRvb2xzIHJlcXVpcmVzIGluIG9yZGVyIHRvIHdhbGsgdGhlIGNvbXBvbmVudCB0cmVlIGFuZCBpbnNwZWN0IHRoZVxyXG4gKiBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LWRldnRvb2xzL2Jsb2IvZTMxZWM1ODI1MzQyZWRhNTcwYWNmYzliY2I0M2E0NDI1OGZjZWIyOC9iYWNrZW5kL2dldERhdGEuanNcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0Q29tcG9zaXRlQ29tcG9uZW50KHZOb2RlLCBpc0ZpcnN0Q3JlYXRpb24pIHtcclxuICAgIHZhciB0eXBlID0gdk5vZGUudHlwZTtcclxuICAgIHZhciBpbnN0YW5jZSA9IHZOb2RlLmNoaWxkcmVuO1xyXG4gICAgdmFyIGxhc3RJbnB1dCA9IGluc3RhbmNlLl9sYXN0SW5wdXQgfHwgaW5zdGFuY2U7XHJcbiAgICB2YXIgZG9tID0gdk5vZGUuZG9tO1xyXG4gICAgdmFyIGNvbXBvc2l0ZUNvbXBvbmVudCA9IHtcclxuICAgICAgICBfY3VycmVudEVsZW1lbnQ6IHtcclxuICAgICAgICAgICAga2V5OiBub3JtYWxpemVLZXkodk5vZGUua2V5KSxcclxuICAgICAgICAgICAgcHJvcHM6IHZOb2RlLnByb3BzLFxyXG4gICAgICAgICAgICByZWY6IG51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pbnN0YW5jZTogaW5zdGFuY2UsXHJcbiAgICAgICAgX3JlbmRlcmVkQ29tcG9uZW50OiB1cGRhdGVSZWFjdENvbXBvbmVudChsYXN0SW5wdXQsIGRvbSksXHJcbiAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24gZ2V0TmFtZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVOYW1lKHR5cGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9kZTogZG9tLFxyXG4gICAgICAgIHByb3BzOiBpbnN0YW5jZS5wcm9wcyxcclxuICAgICAgICBzZXRTdGF0ZTogaW5zdGFuY2Uuc2V0U3RhdGUuYmluZChpbnN0YW5jZSksXHJcbiAgICAgICAgc3RhdGU6IGluc3RhbmNlLnN0YXRlLFxyXG4gICAgICAgIHZOb2RlOiB2Tm9kZVxyXG4gICAgfTtcclxuICAgIGlmIChpc0ZpcnN0Q3JlYXRpb24pIHtcclxuICAgICAgICB2YXIgZm9yY2VJbnN0YW5jZVVwZGF0ZSA9IGluc3RhbmNlLmZvcmNlVXBkYXRlLmJpbmQoaW5zdGFuY2UpOyAvLyBTYXZlIG9mZiBmb3IgdXNlIGJlbG93LlxyXG4gICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHZOb2RlLnByb3BzID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSByZWd1bGFyIEluZmVybm8gcHJvcHMuXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzLCBcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGF0IGdldHMgdXBkYXRlZCBieSB0aGUgUmVhY3QgZGV2dG9vbHMgd2hlbiBwcm9wcyBhcmUgZWRpdGVkLlxyXG4gICAgICAgICAgICBjb21wb3NpdGVDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnByb3BzKTtcclxuICAgICAgICAgICAgZm9yY2VJbnN0YW5jZVVwZGF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcG9zaXRlQ29tcG9uZW50O1xyXG59XHJcbmZ1bmN0aW9uIG5leHRSb290S2V5KHJvb3RzKSB7XHJcbiAgICByZXR1cm4gXCIuXCIgKyBPYmplY3Qua2V5cyhyb290cykubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBWaXNpdCBhbGwgY2hpbGQgaW5zdGFuY2VzIG9mIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQtbGlrZSBvYmplY3QgdGhhdCBhcmVcclxuICogbm90IGNvbXBvc2l0ZSBjb21wb25lbnRzIChpZS4gdGhleSByZXByZXNlbnQgRE9NIGVsZW1lbnRzIG9yIHRleHQpXHJcbiAqL1xyXG5mdW5jdGlvbiB2aXNpdE5vbkNvbXBvc2l0ZUNoaWxkcmVuKGNvbXBvbmVudCwgdmlzaXRvcikge1xyXG4gICAgaWYgKGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQpIHtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuX2NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB2aXNpdG9yKGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQpO1xyXG4gICAgICAgICAgICB2aXNpdE5vbkNvbXBvc2l0ZUNoaWxkcmVuKGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQsIHZpc2l0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbXBvbmVudC5fcmVuZGVyZWRDaGlsZHJlbikge1xyXG4gICAgICAgIGNvbXBvbmVudC5fcmVuZGVyZWRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0b3IoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5fY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXROb25Db21wb3NpdGVDaGlsZHJlbihjaGlsZCwgdmlzaXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJuIHRoZSBuYW1lIG9mIGEgY29tcG9uZW50IGNyZWF0ZWQgYnkgYSBgUmVhY3RFbGVtZW50YC1saWtlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHR5cGVOYW1lKHR5cGUpIHtcclxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHR5cGU7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmQgYWxsIHJvb3QgY29tcG9uZW50IGluc3RhbmNlcyByZW5kZXJlZCBieSBJbmZlcm5vIGluIGBub2RlYCdzIGNoaWxkcmVuXHJcbiAqIGFuZCBhZGQgdGhlbSB0byB0aGUgYHJvb3RzYCBtYXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kUm9vdHMocm9vdHMpIHtcclxuICAgIG9wdGlvbnMucm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xyXG4gICAgICAgIHJvb3RzW25leHRSb290S2V5KHJvb3RzKV0gPSB1cGRhdGVSZWFjdENvbXBvbmVudChyb290LmlucHV0LCBudWxsKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbW9kdWxlIEluZmVybm8tRGV2dG9vbHNcclxuICovIC8qKiBUeXBlRG9jIENvbW1lbnQgKi9cclxudmFyIGZ1bmN0aW9uYWxDb21wb25lbnRXcmFwcGVycyA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uYWxDb21wb25lbnQodk5vZGUpIHtcclxuICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IHZOb2RlLnR5cGU7XHJcbiAgICB2YXIgbmFtZSA9IHZOb2RlLnR5cGUubmFtZSB8fCBcIkZ1bmN0aW9uIChhbm9ueW1vdXMpXCI7XHJcbiAgICB2YXIgd3JhcHBlcnMgPSBmdW5jdGlvbmFsQ29tcG9uZW50V3JhcHBlcnM7XHJcbiAgICBpZiAoIXdyYXBwZXJzLmhhcyhvcmlnaW5hbFJlbmRlcikpIHtcclxuICAgICAgICB2YXIgd3JhcHBlciA9IChmdW5jdGlvbiAoQ29tcG9uZW50JCQxKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB3cmFwcGVyICgpIHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQkJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBDb21wb25lbnQkJDEgKSB3cmFwcGVyLl9fcHJvdG9fXyA9IENvbXBvbmVudCQkMTtcbiAgICAgICAgICAgIHdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29tcG9uZW50JCQxICYmIENvbXBvbmVudCQkMS5wcm90b3R5cGUgKTtcbiAgICAgICAgICAgIHdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gd3JhcHBlcjtcblxuICAgICAgICAgICAgd3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyIChwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihwcm9wcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICB9KENvbXBvbmVudCkpO1xyXG4gICAgICAgIC8vIEV4cG9zZSB0aGUgb3JpZ2luYWwgY29tcG9uZW50IG5hbWUuIFJlYWN0IERldiBUb29scyB3aWxsIHVzZVxyXG4gICAgICAgIC8vIHRoaXMgcHJvcGVydHkgaWYgaXQgZXhpc3RzIG9yIGZhbGwgYmFjayB0byBGdW5jdGlvbi5uYW1lXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlLlxyXG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlICovXHJcbiAgICAgICAgd3JhcHBlcltcImRpc3BsYXlOYW1lXCJdID0gbmFtZTtcclxuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXHJcbiAgICAgICAgd3JhcHBlcnMuc2V0KG9yaWdpbmFsUmVuZGVyLCB3cmFwcGVyKTtcclxuICAgIH1cclxuICAgIHZOb2RlLnR5cGUgPSB3cmFwcGVycy5nZXQob3JpZ2luYWxSZW5kZXIpO1xyXG4gICAgdk5vZGUudHlwZS5kZWZhdWx0UHJvcHMgPSBvcmlnaW5hbFJlbmRlci5kZWZhdWx0UHJvcHM7XHJcbiAgICB2Tm9kZS5yZWYgPSBudWxsO1xyXG4gICAgdk5vZGUuZmxhZ3MgPSA0IC8qIENvbXBvbmVudENsYXNzICovO1xyXG59XHJcbi8vIENyZWRpdDogdGhpcyBiYXNlZCBvbiBvbiB0aGUgZ3JlYXQgd29yayBkb25lIHdpdGggUHJlYWN0IGFuZCBpdHMgZGV2dG9vbHNcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvYmxvYi9tYXN0ZXIvZGV2dG9vbHMvZGV2dG9vbHMuanNcclxuZnVuY3Rpb24gaW5pdERldlRvb2xzKCkge1xyXG4gICAgLyogdHNsaW50OmRpc2FibGUgKi9cclxuICAgIGlmICh0eXBlb2Ygd2luZG93W1wiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fXCJdID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xyXG4gICAgICAgIC8vIFJlYWN0IERldlRvb2xzIGFyZSBub3QgaW5zdGFsbGVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIG5leHRWTm9kZSA9IG9wdGlvbnMuY3JlYXRlVk5vZGU7XHJcbiAgICBvcHRpb25zLmNyZWF0ZVZOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XHJcbiAgICAgICAgdmFyIGZsYWdzID0gdk5vZGUuZmxhZ3M7XHJcbiAgICAgICAgaWYgKGZsYWdzICYgMjggLyogQ29tcG9uZW50ICovICYmICFpc1N0YXRlZnVsQ29tcG9uZW50KHZOb2RlLnR5cGUpKSB7XHJcbiAgICAgICAgICAgIHdyYXBGdW5jdGlvbmFsQ29tcG9uZW50KHZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5leHRWTm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dFZOb2RlKHZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTm90aWZ5IGRldnRvb2xzIHdoZW4gcHJlYWN0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWQsIHVwZGF0ZWQgb3IgdW5tb3VudGVkXHJcbiAgICB2YXIgYnJpZGdlID0gY3JlYXRlRGV2VG9vbHNCcmlkZ2UoKTtcclxuICAgIHZhciBuZXh0QWZ0ZXJNb3VudCA9IG9wdGlvbnMuYWZ0ZXJNb3VudDtcclxuICAgIG9wdGlvbnMuYWZ0ZXJNb3VudCA9IGZ1bmN0aW9uICh2Tm9kZSkge1xyXG4gICAgICAgIGJyaWRnZS5jb21wb25lbnRBZGRlZCh2Tm9kZSk7XHJcbiAgICAgICAgaWYgKG5leHRBZnRlck1vdW50KSB7XHJcbiAgICAgICAgICAgIG5leHRBZnRlck1vdW50KHZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIG5leHRBZnRlclVwZGF0ZSA9IG9wdGlvbnMuYWZ0ZXJVcGRhdGU7XHJcbiAgICBvcHRpb25zLmFmdGVyVXBkYXRlID0gZnVuY3Rpb24gKHZOb2RlKSB7XHJcbiAgICAgICAgYnJpZGdlLmNvbXBvbmVudFVwZGF0ZWQodk5vZGUpO1xyXG4gICAgICAgIGlmIChuZXh0QWZ0ZXJVcGRhdGUpIHtcclxuICAgICAgICAgICAgbmV4dEFmdGVyVXBkYXRlKHZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIG5leHRCZWZvcmVVbm1vdW50ID0gb3B0aW9ucy5iZWZvcmVVbm1vdW50O1xyXG4gICAgb3B0aW9ucy5iZWZvcmVVbm1vdW50ID0gZnVuY3Rpb24gKHZOb2RlKSB7XHJcbiAgICAgICAgYnJpZGdlLmNvbXBvbmVudFJlbW92ZWQodk5vZGUpO1xyXG4gICAgICAgIGlmIChuZXh0QmVmb3JlVW5tb3VudCkge1xyXG4gICAgICAgICAgICBuZXh0QmVmb3JlVW5tb3VudCh2Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIE5vdGlmeSBkZXZ0b29scyBhYm91dCB0aGlzIGluc3RhbmNlIG9mIFwiUmVhY3RcIlxyXG4gICAgLyogdHNsaW50OmRpc2FibGUgKi9cclxuICAgIHdpbmRvd1tcIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfX1wiXS5pbmplY3QoYnJpZGdlKTtcclxuICAgIC8qIHRzbGludDplbmFibGUgKi9cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3B0aW9ucy5hZnRlck1vdW50ID0gbmV4dEFmdGVyTW91bnQ7XHJcbiAgICAgICAgb3B0aW9ucy5hZnRlclVwZGF0ZSA9IG5leHRBZnRlclVwZGF0ZTtcclxuICAgICAgICBvcHRpb25zLmJlZm9yZVVubW91bnQgPSBuZXh0QmVmb3JlVW5tb3VudDtcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBtb2R1bGUgSW5mZXJuby1EZXZ0b29sc1xyXG4gKi8gLyoqIFR5cGVEb2MgQ29tbWVudCAqL1xyXG5pbml0RGV2VG9vbHMoKTtcbiIsIi8qKiBAanN4IGNyZWF0ZUVsZW1lbnQgKi9cbmltcG9ydCBjcmVhdGVFbGVtZW50IGZyb20gJ2luZmVybm8tY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdpbmZlcm5vLWNvbXBvbmVudCc7XG5pbXBvcnQgSW5mZXJubyBmcm9tICdpbmZlcm5vJztcbmltcG9ydCBWTm9kZUZsYWdzIGZyb20gJ2luZmVybm8tdm5vZGUtZmxhZ3MnO1xuaW1wb3J0ICdpbmZlcm5vLWRldnRvb2xzJztcbi8vIHRyeSBodHRwczovL2N5Y2xlLmpzLm9yZy9tb2RlbC12aWV3LWludGVudC5odG1sXG5cbi8vIHNob3J0Y3V0IGZvciBjb21wb25lbnQgaW1wbGVtZW50YXRpb25zXG5leHBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfTtcblxuLypcbiBFdmVyeXRoaW5nIHVuZGVyIGVsZW1lbnQgbXVzdCBiZSBpbXBsZW1lbnRlZCB3aXRoIGNvbXBhdGlibGUgY29tcG9uZW50c1xuIHRoYXQgd29yayBpbiBjb2hlcmVudCByZW5kZXJpbmcgc3R5bGVcbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmZlcm5vVHJlZVJlbmRlcmVyKGVsLCBCYXNlQ29tcG9uZW50LCBkZWNvcmF0ZUNvbXBvbmVudCkge1xuICAgIC8vVE9ETyBkb24ndCBuZWVkIGEgY2xhc3MgcGVyIGVsZW1lbnQsIGFzc29jaWF0ZSBtYWluIGVsZW1lbnQgd2l0aCBNYXN0ZXJcbiAgICBjbGFzcyBNYXN0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgICAgICBzdGF0aWMgZ2V0IG5hbWUoKSB7IHJldHVybiBlbC5sb2NhbE5hbWU7IH0gLy8gZGVidWdnaW5nIHRoZSByZW5kZXIgZnVuY3Rpb24vY2xhc3NcbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuID09IG51bGwgfHxcbiAgICAgICAgICAgICAgKHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgdHlwZW9mIHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB0aGlzLnByb3BzLmNoaWxkcmVuLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW5mZXJubyBFcnJvcjogT25seSBvbmUgY2hpbGQgaXMgYWxsb3dlZCB3aXRoaW4gdGhlIGBQcm92aWRlcmAgY29tcG9uZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7IC8vIHsgc3RvcmU6IHRoaXMuc3RvcmUsIHN0b3JlU3Vic2NyaXB0aW9uOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBFeHRlbmRlZCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgICAgICBzdGF0aWMgZ2V0IG5hbWUoKSB7IHJldHVybiBCYXNlQ29tcG9uZW50Lm5hbWU7IH0gLy8gZGVidWdnaW5nIHRoZSByZW5kZXIgZnVuY3Rpb24vY2xhc3NcblxuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWNvcmF0ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykgZGVjb3JhdGVDb21wb25lbnQodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAvLyByZW1lbWJlciBjb21wb25lbnQgZm9yIG5vd1xuICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnQgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuICAgICAgICAvLyAgICAgY29uc3QgdXNlUHJvcHMgPSBwcm9wcyB8fCB0aGlzLnJlbmRlclByb3BzKCk7XG4gICAgICAgIC8vICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMucmVuZGVyQ29udGVudChwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIEluZmVybm8uY3JlYXRlVk5vZGUoVk5vZGVGbGFncy5IdG1sRWxlbWVudCwgZWxOYW1lLCB1c2VQcm9wcy5jbGFzc05hbWUsIGNoaWxkcmVuLCB1c2VQcm9wcyk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgd3JhcHBlZCBjb21wb25lbnQgdGhhdCBzdXBwb3J0cyB1cGRhdGUgZmliZXJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjb21wb25lbnQ6IG51bGwsIC8vIGlzIHRoaXMgZXZlbiByZWxldmFudD9cbiAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgIGFzQ29tcG9uZW50OiBFeHRlbmRlZCxcblxuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jb21wb25lbnQpID8gdGhpcy5jb21wb25lbnQuc3RhdGUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICAgICAgLy9UT0RPIGhvdyB0byBkbyB0aGlzP1xuICAgICAgICB9LFxuICAgICAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgLy9UT0RPIGhvdyB0byBkbyB0aGlzP1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB0aGlzLmNvbXBvbmVudC5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJvb3RSZW5kZXIocHJvcHMpIHtcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmNvbXBvbmVudC5yZW5kZXJBc3luYykge1xuICAgICAgICAgICAgaWYgKEJhc2VDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckFzeW5jKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5taXhpblByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuY29tcG9uZW50LnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gQmFzZUNvbXBvbmVudC5wcm90b3R5cGUubWl4aW5Qcm9wcy5jYWxsKHRoaXMuY29tcG9uZW50LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBhcHBseSB0byBlbGVtZW50LCBub3QgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgd2hlbiBwcm9wcywgYXR0cnMsIHN0YXRlIGNoYW5nZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWwuc3R5bGUsIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yKGNvbnN0IG4gaW4gcHJvcHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGVsLnN0eWxlW25dID0gcHJvcHMuc3R5bGVbbl07XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLm9uQ2xpY2spIGVsLm9uY2xpY2sgPSBwcm9wcy5vbmNsaWNrOyAvLz8/XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zdCB2Tm9kZSA9IEluZmVybm8uY3JlYXRlVk5vZGUoVk5vZGVGbGFncy5Db21wb25lbnRDbGFzcywgTWFzdGVyLCAnJyxcbiAgICAgICAgICAgICAgICAvLyAgICAgSW5mZXJuby5jcmVhdGVWTm9kZShWTm9kZUZsYWdzLkNvbXBvbmVudENsYXNzLCBXcmFwcGVkLCAnJywgW10sIHByb3BzKVxuICAgICAgICAgICAgICAgIC8vICk7XG4gICAgICAgICAgICAgICAgLy8gZG9lc24ndCBzZWVtIHRvIHdvcmsgc2luY2UgaW5zdGFuY2UgaXMgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgLy8gaWYgKCF0aGlzLmNvbXBvbmVudCkgdGhpcy5jb21wb25lbnQgPSB2Tm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBJbmZlcm5vLnJlbmRlcig8TWFzdGVyPjxFeHRlbmRlZCB7Li4ucHJvcHN9IC8+PC9NYXN0ZXI+LGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gY29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFZOb2RlRnJvbUpTT05NTChqc29ubWwsIG1ldGEpIHtcbiAgICAvLyBjb25zb2xlLndhcm4oJ0pTT04nLCBqc29ubWwpO1xuICAgIHJldHVybiBCWV9UWVBFLm9iamVjdChqc29ubWwsIG1ldGEpO1xufVxuXG5mdW5jdGlvbiB0YWcyZmxhZ3ModGFnKSB7XG4gICAgc3dpdGNoKHRhZykge1xuICAgICAgICAvL1RPRE8gc3ZnIG1lZGlhIGtleWVkIGNoaWxkcmVuXG4gICAgICAgIGNhc2UgJ3N2Zyc6IHJldHVybiBWTm9kZUZsYWdzLlN2Z0VsZW1lbnQ7XG4gICAgICAgIGNhc2UgJ2lucHV0JzogcmV0dXJuIFZOb2RlRmxhZ3MuSW5wdXRFbGVtZW50O1xuICAgICAgICBjYXNlICd0ZXh0YXJlYSc6IHJldHVybiBWTm9kZUZsYWdzLlRleHRhcmVhRWxlbWVudDtcbiAgICAgICAgY2FzZSAnc2VsZWN0JzogcmV0dXJuIFZOb2RlRmxhZ3MuU2VsZWN0RWxlbWVudDtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIFZOb2RlRmxhZ3MuSHRtbEVsZW1lbnQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb2VyY2VQcm9wcyhwcm9wcykge1xuICAgIC8vIHBzZXVkbyBwcm9wcyBmcm9tIHRlbXBsYXRlZC5qc1xuICAgIGlmIChwcm9wcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShwcm9wcykucmVkdWNlKChyZXN1bHQsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAyICYmIG5vZGUubm9kZU5hbWUgIT09ICdjaGlsZHJlbicpIHJlc3VsdFtub2RlLm5vZGVOYW1lXSA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbmxldCBCWV9UWVBFID0ge1xuICAgICd1bmRlZmluZWQnKCkge1xuICAgICAgICByZXR1cm4gSW5mZXJuby5jcmVhdGVWTm9kZShWTm9kZUZsYWdzLlZvaWQpO1xuICAgIH0sXG4gICAgJ3N0cmluZycodGV4dCkge1xuICAgICAgICAvLyByZXR1cm4gSW5mZXJuby5jcmVhdGVWTm9kZShWTm9kZUZsYWdzLlRleHQsIHRleHQpOyAvLyB0cmFuc2Zvcm0gZnVuY3Rpb24/XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG4gICAgJ2Z1bmN0aW9uJyhmbiwgbWV0YSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZuKCk7XG4gICAgICAgIEJZX1RZUEVbdHlwZW9mIHZhbHVlXSh2YWx1ZSwgbWV0YSk7XG4gICAgfSxcbiAgICAnb2JqZWN0Jyhqc29ubWwsIG1ldGEpIHtcbiAgICAgICAgaWYgKGpzb25tbCA9PT0gbnVsbCkgcmV0dXJuIEluZmVybm8uY3JlYXRlVk5vZGUoVk5vZGVGbGFncy5Wb2lkKTtcbiAgICAgICAgLy8gVE9ETyBoYW5kbGUga2V5LCB0aW1pbmcsIGRhdGEgZGVwcywgdGltaW5nIGNhbGxiYWNrc1xuICAgICAgICAvL1doYXQgYWJvdXQgVk5vZGVGbGFncy5IYXNLZXllZENoaWxkcmVuXG4gICAgICAgIGNvbnN0IHByb3BzID0gY29lcmNlUHJvcHMoanNvbm1sWzFdIHx8IHt9KTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvcHMua2V5OyAvL1RPRE8gdHJ1ZT9cbiAgICAgICAgLy9UT0RPIGlkZW50aWZ5aW5nIGN1c3RvbSBlbGVtZW50cyB0byBjb252ZXJ0IHRvIGNvbXBvbmVudCByZW5kZXJpbmdcbiAgICAgICAgcmV0dXJuIEluZmVybm8uY3JlYXRlVk5vZGUoXG4gICAgICAgICAgICB0YWcyZmxhZ3MoanNvbm1sWzBdKSwganNvbm1sWzBdLFxuICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgICAganNvbm1sLnNsaWNlKDIsIGpzb25tbC5sZW5ndGgpLm1hcChlbCA9PiBCWV9UWVBFW3R5cGVvZiBlbF0oZWwsIG1ldGEpKSxcbiAgICAgICAgICAgIHByb3BzLCBrZXksIC8qIHJlZiAqL1xuICAgICAgICApO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7IChmdW5jdGlvbihmbiwgbmFtZSkgeyBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSBmbihleHBvcnRzLCBtb2R1bGUpOyBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGZuKG5hbWUgPT09ICcqJyA/IHNlbGYgOiAobmFtZSA/IHNlbGZbbmFtZV0gPSB7fSA6IHt9KSk7IH0pKGZ1bmN0aW9uKGV4cG9ydHMsIG1vZHVsZSkgeyAvLyA9PT0gU3ltYm9sIFN1cHBvcnQgPT09XG5cbmZ1bmN0aW9uIGhhc1N5bWJvbChuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgQm9vbGVhbihTeW1ib2xbbmFtZV0pO1xufVxuXG5mdW5jdGlvbiBnZXRTeW1ib2wobmFtZSkge1xuICByZXR1cm4gaGFzU3ltYm9sKG5hbWUpID8gU3ltYm9sW25hbWVdIDogXCJAQFwiICsgbmFtZTtcbn1cblxuLy8gUG9ueWZpbGwgU3ltYm9sLm9ic2VydmFibGUgZm9yIGludGVyb3BlcmFiaWxpdHkgd2l0aCBvdGhlciBsaWJyYXJpZXNcbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgIVN5bWJvbC5vYnNlcnZhYmxlKSB7XG4gIFN5bWJvbC5vYnNlcnZhYmxlID0gU3ltYm9sKFwib2JzZXJ2YWJsZVwiKTtcbn1cblxuLy8gPT09IEFic3RyYWN0IE9wZXJhdGlvbnMgPT09XG5cbmZ1bmN0aW9uIGdldE1ldGhvZChvYmosIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcblxuICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWVzKG9iaikge1xuICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgaWYgKGN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGN0b3IgPSBjdG9yW2dldFN5bWJvbChcInNwZWNpZXNcIildO1xuICAgIGlmIChjdG9yID09PSBudWxsKSB7XG4gICAgICBjdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3RvciAhPT0gdW5kZWZpbmVkID8gY3RvciA6IE9ic2VydmFibGU7XG59XG5cbmZ1bmN0aW9uIGFkZE1ldGhvZHModGFyZ2V0LCBtZXRob2RzKSB7XG4gIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtZXRob2RzLCBrKTtcbiAgICBkZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrLCBkZXNjKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIC8vIEFzc2VydDogIG9ic2VydmVyLl9vYnNlcnZlciBpcyB1bmRlZmluZWRcblxuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fY2xlYW51cDtcblxuICBpZiAoIWNsZWFudXApXG4gICAgcmV0dXJuO1xuXG4gIC8vIERyb3AgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2xlYW51cCBmdW5jdGlvbiBzbyB0aGF0IHdlIHdvbid0IGNhbGwgaXRcbiAgLy8gbW9yZSB0aGFuIG9uY2VcbiAgc3Vic2NyaXB0aW9uLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuXG4gIC8vIENhbGwgdGhlIGNsZWFudXAgZnVuY3Rpb25cbiAgY2xlYW51cCgpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSB7XG4gIHJldHVybiBzdWJzY3JpcHRpb24uX29ic2VydmVyID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpXG4gICAgcmV0dXJuO1xuXG4gIHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbn1cblxuZnVuY3Rpb24gY2xlYW51cEZyb21TdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkgfTtcbn1cblxuZnVuY3Rpb24gU3Vic2NyaXB0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIC8vIEFzc2VydDogc3Vic2NyaWJlciBpcyBjYWxsYWJsZVxuXG4gIC8vIFRoZSBvYnNlcnZlciBtdXN0IGJlIGFuIG9iamVjdFxuICBpZiAoT2JqZWN0KG9ic2VydmVyKSAhPT0gb2JzZXJ2ZXIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ic2VydmVyIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuXG4gIHRoaXMuX2NsZWFudXAgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG5cbiAgdmFyIHN0YXJ0ID0gZ2V0TWV0aG9kKG9ic2VydmVyLCBcInN0YXJ0XCIpO1xuXG4gIGlmIChzdGFydClcbiAgICBzdGFydC5jYWxsKG9ic2VydmVyLCB0aGlzKTtcblxuICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKVxuICAgIHJldHVybjtcblxuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcblxuICB0cnkge1xuICAgIC8vIENhbGwgdGhlIHN1YnNjcmliZXIgZnVuY3Rpb25cbiAgICB2YXIgY2xlYW51cCQwID0gc3Vic2NyaWJlci5jYWxsKHVuZGVmaW5lZCwgb2JzZXJ2ZXIpO1xuXG4gICAgLy8gVGhlIHJldHVybiB2YWx1ZSBtdXN0IGJlIHVuZGVmaW5lZCwgbnVsbCwgYSBzdWJzY3JpcHRpb24gb2JqZWN0LCBvciBhIGZ1bmN0aW9uXG4gICAgaWYgKGNsZWFudXAkMCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGNsZWFudXAkMC51bnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBjbGVhbnVwJDAgPSBjbGVhbnVwRnJvbVN1YnNjcmlwdGlvbihjbGVhbnVwJDApO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGNsZWFudXAkMCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNsZWFudXAkMCArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgICB0aGlzLl9jbGVhbnVwID0gY2xlYW51cCQwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgc3RhcnR1cCwgdGhlbiBhdHRlbXB0IHRvIHNlbmQgdGhlIGVycm9yXG4gICAgLy8gdG8gdGhlIG9ic2VydmVyXG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgdGhlIHN0cmVhbSBpcyBhbHJlYWR5IGZpbmlzaGVkLCB0aGVuIHBlcmZvcm0gY2xlYW51cFxuICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKVxuICAgIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG59XG5cbmFkZE1ldGhvZHMoU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHt9LCB7XG4gIGdldCBjbG9zZWQoKSB7IHJldHVybiBzdWJzY3JpcHRpb25DbG9zZWQodGhpcykgfSxcbiAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uKCkgeyBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKSB9LFxufSk7XG5cbmZ1bmN0aW9uIFN1YnNjcmlwdGlvbk9ic2VydmVyKHN1YnNjcmlwdGlvbikge1xuICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG59XG5cbmFkZE1ldGhvZHMoU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge30sIHtcblxuICBnZXQgY2xvc2VkKCkgeyByZXR1cm4gc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMuX3N1YnNjcmlwdGlvbikgfSxcblxuICBuZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb247XG5cbiAgICAvLyBJZiB0aGUgc3RyZWFtIGlzIGNsb3NlZCwgdGhlbiByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXI7XG4gICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIsIFwibmV4dFwiKTtcblxuICAgIC8vIElmIHRoZSBvYnNlcnZlciBkb2Vzbid0IHN1cHBvcnQgXCJuZXh0XCIsIHRoZW4gcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghbSlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAvLyBTZW5kIHRoZSBuZXh0IHZhbHVlIHRvIHRoZSBzaW5rXG4gICAgcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICB9LFxuXG4gIGVycm9yOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb247XG5cbiAgICAvLyBJZiB0aGUgc3RyZWFtIGlzIGNsb3NlZCwgdGhyb3cgdGhlIGVycm9yIHRvIHRoZSBjYWxsZXJcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpXG4gICAgICB0aHJvdyB2YWx1ZTtcblxuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXI7XG4gICAgc3Vic2NyaXB0aW9uLl9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgbSQwID0gZ2V0TWV0aG9kKG9ic2VydmVyLCBcImVycm9yXCIpO1xuXG4gICAgICAvLyBJZiB0aGUgc2luayBkb2VzIG5vdCBzdXBwb3J0IFwiZXJyb3JcIiwgdGhlbiB0aHJvdyB0aGUgZXJyb3IgdG8gdGhlIGNhbGxlclxuICAgICAgaWYgKCFtJDApXG4gICAgICAgIHRocm93IHZhbHVlO1xuXG4gICAgICB2YWx1ZSA9IG0kMC5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHsgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIH1cbiAgICAgIGZpbmFsbHkgeyB0aHJvdyBlIH1cbiAgICB9XG5cbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIGNvbXBsZXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb247XG5cbiAgICAvLyBJZiB0aGUgc3RyZWFtIGlzIGNsb3NlZCwgdGhlbiByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXI7XG4gICAgc3Vic2NyaXB0aW9uLl9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgbSQxID0gZ2V0TWV0aG9kKG9ic2VydmVyLCBcImNvbXBsZXRlXCIpO1xuXG4gICAgICAvLyBJZiB0aGUgc2luayBkb2VzIG5vdCBzdXBwb3J0IFwiY29tcGxldGVcIiwgdGhlbiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB2YWx1ZSA9IG0kMSA/IG0kMS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHsgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIH1cbiAgICAgIGZpbmFsbHkgeyB0aHJvdyBlIH1cbiAgICB9XG5cbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG59KTtcblxuZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKSB7XG4gIC8vIFRoZSBzdHJlYW0gc3Vic2NyaWJlciBtdXN0IGJlIGEgZnVuY3Rpb25cbiAgaWYgKHR5cGVvZiBzdWJzY3JpYmVyICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ic2VydmFibGUgaW5pdGlhbGl6ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gIHRoaXMuX3N1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xufVxuXG5hZGRNZXRob2RzKE9ic2VydmFibGUucHJvdG90eXBlLCB7XG5cbiAgc3Vic2NyaWJlOiBmdW5jdGlvbihvYnNlcnZlcikgeyBmb3IgKHZhciBhcmdzID0gW10sIF9fJDAgPSAxOyBfXyQwIDwgYXJndW1lbnRzLmxlbmd0aDsgKytfXyQwKSBhcmdzLnB1c2goYXJndW1lbnRzW19fJDBdKTsgXG4gICAgaWYgKHR5cGVvZiBvYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgIG5leHQ6IG9ic2VydmVyLFxuICAgICAgICBlcnJvcjogYXJnc1swXSxcbiAgICAgICAgY29tcGxldGU6IGFyZ3NbMV0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9zdWJzY3JpYmVyKTtcbiAgfSxcblxuICBmb3JFYWNoOiBmdW5jdGlvbihmbikgeyB2YXIgX190aGlzID0gdGhpczsgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpKTtcblxuICAgICAgX190aGlzLnN1YnNjcmliZSh7XG4gICAgICAgIF9zdWJzY3JpcHRpb246IG51bGwsXG5cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgIGlmIChPYmplY3Qoc3Vic2NyaXB0aW9uKSAhPT0gc3Vic2NyaXB0aW9uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzdWJzY3JpcHRpb24gKyBcIiBpcyBub3QgYW4gb2JqZWN0XCIpO1xuXG4gICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbjtcblxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24oZm4pIHsgdmFyIF9fdGhpcyA9IHRoaXM7IFxuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblxuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcblxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcikgeyByZXR1cm4gX190aGlzLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0cnkgeyB2YWx1ZSA9IGZuKHZhbHVlKSB9XG4gICAgICAgIGNhdGNoIChlKSB7IHJldHVybiBvYnNlcnZlci5lcnJvcihlKSB9XG5cbiAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpIH0sXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gb2JzZXJ2ZXIuY29tcGxldGUoeCkgfSxcbiAgICB9KTsgfSk7XG4gIH0sXG5cbiAgZmlsdGVyOiBmdW5jdGlvbihmbikgeyB2YXIgX190aGlzID0gdGhpczsgXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuXG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKSB7IHJldHVybiBfX3RoaXMuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRyeSB7IGlmICghZm4odmFsdWUpKSByZXR1cm4gdW5kZWZpbmVkIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpIH1cblxuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICBlcnJvcjogZnVuY3Rpb24oZSkgeyByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSkgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlKCkgfSxcbiAgICB9KTsgfSk7XG4gIH0sXG5cbiAgcmVkdWNlOiBmdW5jdGlvbihmbikgeyB2YXIgX190aGlzID0gdGhpczsgXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgIHZhciBoYXNTZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGFjYyA9IHNlZWQ7XG5cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpIHsgcmV0dXJuIF9fdGhpcy5zdWJzY3JpYmUoe1xuXG4gICAgICBuZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgZmlyc3QgPSAhaGFzVmFsdWU7XG4gICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWZpcnN0IHx8IGhhc1NlZWQpIHtcbiAgICAgICAgICB0cnkgeyBhY2MgPSBmbihhY2MsIHZhbHVlKSB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHsgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKGUpIHsgb2JzZXJ2ZXIuZXJyb3IoZSkgfSxcblxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWhhc1ZhbHVlICYmICFoYXNTZWVkKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWR1Y2UgYW4gZW1wdHkgc2VxdWVuY2VcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVyLm5leHQoYWNjKTtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH0sXG5cbiAgICB9KTsgfSk7XG4gIH0sXG5cbiAgZmxhdE1hcDogZnVuY3Rpb24oZm4pIHsgdmFyIF9fdGhpcyA9IHRoaXM7IFxuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblxuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcblxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBvdXRlciBPYnNlcnZhYmxlXG4gICAgICB2YXIgb3V0ZXIgPSBfX3RoaXMuc3Vic2NyaWJlKHtcblxuICAgICAgICBuZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gICAgICAgICAgT2JzZXJ2YWJsZS5mcm9tKHZhbHVlKS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogbnVsbCxcblxuICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKHMpIHsgc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuX3N1YnNjcmlwdGlvbiA9IHMpIH0sXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbih2YWx1ZSkgeyBvYnNlcnZlci5uZXh0KHZhbHVlKSB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGUpIHsgb2JzZXJ2ZXIuZXJyb3IoZSkgfSxcblxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZih0aGlzLl9zdWJzY3JpcHRpb24pO1xuXG4gICAgICAgICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICAgICAgY2xvc2VJZkRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICBjbG9zZUlmRG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2VJZkRvbmUoKSB7XG4gICAgICAgIGlmIChjb21wbGV0ZWQgJiYgc3Vic2NyaXB0aW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24ocykgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgb3V0ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG5cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZS5wcm90b3R5cGUsIGdldFN5bWJvbChcIm9ic2VydmFibGVcIiksIHtcbiAgdmFsdWU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9LFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxufSk7XG5cbmFkZE1ldGhvZHMoT2JzZXJ2YWJsZSwge1xuXG4gIGZyb206IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzIDogT2JzZXJ2YWJsZTtcblxuICAgIGlmICh4ID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyBcIiBpcyBub3QgYW4gb2JqZWN0XCIpO1xuXG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZCh4LCBnZXRTeW1ib2woXCJvYnNlcnZhYmxlXCIpKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlJDAgPSBtZXRob2QuY2FsbCh4KTtcblxuICAgICAgaWYgKE9iamVjdChvYnNlcnZhYmxlJDApICE9PSBvYnNlcnZhYmxlJDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Iob2JzZXJ2YWJsZSQwICsgXCIgaXMgbm90IGFuIG9iamVjdFwiKTtcblxuICAgICAgaWYgKG9ic2VydmFibGUkMC5jb25zdHJ1Y3RvciA9PT0gQylcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUkMDtcblxuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZhYmxlJDAuc3Vic2NyaWJlKG9ic2VydmVyKTsgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1N5bWJvbChcIml0ZXJhdG9yXCIpICYmIChtZXRob2QgPSBnZXRNZXRob2QoeCwgZ2V0U3ltYm9sKFwiaXRlcmF0b3JcIikpKSkge1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICAgIGZvciAodmFyIF9fJDAgPSAobWV0aG9kLmNhbGwoeCkpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX18kMTsgX18kMSA9IF9fJDAubmV4dCgpLCAhX18kMS5kb25lOykgeyB2YXIgaXRlbSQwID0gX18kMS52YWx1ZTsgXG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtJDApO1xuICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgICBmb3IgKHZhciBpJDAgPSAwOyBpJDAgPCB4Lmxlbmd0aDsgKytpJDApIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHhbaSQwXSk7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyBcIiBpcyBub3Qgb2JzZXJ2YWJsZVwiKTtcbiAgfSxcblxuICBvZjogZnVuY3Rpb24oKSB7IGZvciAodmFyIGl0ZW1zID0gW10sIF9fJDAgPSAwOyBfXyQwIDwgYXJndW1lbnRzLmxlbmd0aDsgKytfXyQwKSBpdGVtcy5wdXNoKGFyZ3VtZW50c1tfXyQwXSk7IFxuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMgOiBPYnNlcnZhYmxlO1xuXG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBpdGVtcy5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbaSQxXSk7XG4gICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9LFxuXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGUsIGdldFN5bWJvbChcInNwZWNpZXNcIiksIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxufSk7XG5cbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG5cblxufSwgXCIqXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vemVuLW9ic2VydmFibGUuanNcIikuT2JzZXJ2YWJsZTtcbiIsImltcG9ydCBpbmNyZW1lbnRhbFRlbXBsYXRlcyBmcm9tICcuLi8uLi9kb20vaW5jcmVtZW50YWxUZW1wbGF0ZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2VFbnRyeShibG9ja0lkLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGluY3JlbWVudGFsVGVtcGxhdGVzLmdldChibG9ja0lkKTtcbiAgICBjb25zdCBhY3Rpb25JZCA9IHRlbXBsYXRlICYmIHRlbXBsYXRlLmFjdGlvbnMgJiYgdGVtcGxhdGUuYWN0aW9ucy5sZW5ndGggPT09IDEgPyB0ZW1wbGF0ZS5hY3Rpb25zWzBdLnRlbXBsYXRlSWQgOiBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJywgdGVtcGxhdGVJZDogYmxvY2tJZCxcbiAgICAgICAgYWN0aW9uSWQsIGhpZGRlblJlc3BvbnNlOmZhbHNlLCByZXNwb25zZTogbnVsbCxcbiAgICAgICAgLi4ub3B0cyxcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2hhbGxlbmdlRW50cnkoYmxvY2tJZCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NoYWxsZW5nZScsIHRlbXBsYXRlSWQ6IGJsb2NrSWQsIC4uLm9wdHMsXG4gICAgfTtcbn1cbi8qKlxuICogQnkgZGVmYXVsdCB0aGUgc3RhdGUgaXMgYSBsaXN0IG9mIGJsb2NrcyB3aXRoIGFzc29jaWF0ZWQgdGVtcGxhdGVzIGFuZCByZXNwb25zZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnNhdGlvblJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgY29udGV4dCkge1xuICAgIC8vIGNvbnRleHQudG9waWMgY29udGV4dC5zdGFydEJsb2NrXG5cbiAgICBpZiAoIXN0YXRlKSByZXR1cm4gKHN0YXRlID0gc2VlZENvbnZlcnNhdGlvbihjb250ZXh0KSk7XG5cbiAgICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RhcnQgcmVzcG9uc2UnOlxuICAgICAgICAgICAgLy8ge3R5cGUsdGVtcGxhdGVJZCxhY3Rpb25JZCxoaWRkZW5SZXNwb25zZX1cbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCB0aHJlYWQ6IHN0YXRlLnRocmVhZC5tYXAoKGJsb2NrLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPT09IGFjdGlvbi5ibG9ja0luZGV4KSA/IG1peEJsb2NrV2l0aFBheWxvYWQoYmxvY2spIDogYmxvY2s7XG4gICAgICAgICAgICB9KX07XG4gICAgICAgIGNhc2UgJ3NldCByZXNwb25zZSc6XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgdGhyZWFkOiBzdGF0ZS50aHJlYWQubWFwKChibG9jaywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4ID09PSBhY3Rpb24uYmxvY2tJbmRleCkgPyBtaXhCbG9ja1dpdGhQYXlsb2FkKGJsb2NrKSA6IGJsb2NrO1xuICAgICAgICAgICAgfSl9O1xuICAgICAgICBjYXNlICdzdGFydCB0b3BpYyc6IHtcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgYW4gb2JzZXJ2YWJsZSByZXR1cm5lZCB3aXRoIHRpbWUgc2VxdWVuY2UgdGhyZWFkIGFkZGl0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0b3BpYzogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgdGhyZWFkOiBzdGF0ZS50aHJlYWRcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICAgIENoYWxsZW5nZUVudHJ5KGFjdGlvbi5wYXlsb2FkLnN0YXJ0QmxvY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVzcG9uc2VFbnRyeShhY3Rpb24ucGF5bG9hZC5zdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaXhCbG9ja1dpdGhQYXlsb2FkKGJsb2NrKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZCB8fCB7fTtcbiAgICAgICAgaWYgKHBheWxvYWQuaGlkZGVuUmVzcG9uc2UgIT09IHVuZGVmaW5lZCkgcGF5bG9hZC5oaWRkZW5SZXNwb25zZSA9IEJvb2xlYW4ocGF5bG9hZC5oaWRkZW5SZXNwb25zZSlcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHsgfSwgYmxvY2ssIHBheWxvYWQpO1xuICAgICAgICBpZiAoIHJlc3VsdC5yZXF1aXJlZEZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gcmVzdWx0LnJlcXVpcmVkRmllbGRzLmZpbHRlcihuYW1lID0+IHJlc3VsdFtuYW1lXSA9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmVzdWx0LnJlc3BvbnNlID0gKG1pc3NpbmdSZXF1aXJlZC5sZW5ndGggPT09IDApID8gcmVzdWx0LnJlc3BvbnNlVGVtcGxhdGUucmVuZGVyKHJlc3VsdCkgOiBudWxsO1xuICAgICAgICAgICAgLy8gVE9ETyB3aXRoIGEgcmVzcG9uc2UgdGhlIG5leHQgYmxvY2sgbXVzdCBiZSBkZXRlcm1pbmVkXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLy8gZnVuY3Rpb24gMFxuXG5mdW5jdGlvbiBzZWVkQ29udmVyc2F0aW9uKGNvbnRleHQpIHtcbiAgICBsZXQgdGhyZWFkID0gW107XG5cbiAgICBpZiAodGhyZWFkLmxlbmd0aCA9PT0gMCkge1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vVE9ETyBjb252ZXJ0IHRoZSB0aHJlYWQgdG8gaW5jcmVtZW50YWwtZG9tIGVsLmlkb21DaGlsZHJlblxuICAgIH1cblxuICAgIHJldHVybiB7IHRocmVhZCB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNvbnRlbnRSZWR1Y2VyKHN0YXRlLCB7IHR5cGUsIHBheWxvYWQgfSwgY29udGV4dCkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHNob3djYXNlUmVkdWNlcihzdGF0ZSwgeyB0eXBlLCBwYXlsb2FkIH0sIGNvbnRleHQpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlICdzZXQgc2hvd2Nhc2UgbGlzdCc6XG4gICAgICAgICAgICBjb25zdCBzaG93Y2FzZVN0YXRlID0gcGF5bG9hZC5yZWR1Y2UoKGNvbWJpbmVkLCBlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkW2VudHJ5LmhyZWZdID0gZW50cnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIHNob3djYXNlOiBwYXlsb2FkLCBzaG93Y2FzZVN0YXRlIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuIiwiLypcbiAgICBCYXNlZCBvbiByZXNlbGVjdFxuKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKGRlZmF1bHRNZW1vaXplKVxuXG5mdW5jdGlvbiBkZWZhdWx0RXF1YWxpdHlDaGVjayhhLCBiKSB7XG4gIHJldHVybiBhID09PSBiXG59XG5cbi8qIFNpbWlsYXIgdG8gaW5mZXJuby1yZWR1eCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlZnVsU2VsZWN0b3Ioc291cmNlU2VsZWN0b3IsIHN0YXRlUmVmaW5lciA9IChzdGF0ZSkgPT4gc3RhdGUsIHN0b3JlLCBzZXRDb21wb25lbnRTdGF0ZSkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gdHlwZW9mIHNvdXJjZVNlbGVjdG9yID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY3JlYXRlU2VsZWN0b3Ioc291cmNlU2VsZWN0b3IsIHN0YXRlUmVmaW5lcilcbiAgICAgICAgOiBjcmVhdGVTZWxlY3Rvci5hcHBseShudWxsLCBzb3VyY2VTZWxlY3Rvcik7XG5cbiAgICBzZWxlY3Rvci5lcnJvciA9IG51bGw7XG4gICAgc2VsZWN0b3Iuc3RhdGUgPSB7fTtcbiAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICBzZWxlY3Rvci5ydW4gPSAocHJvcHMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHNlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHByb3BzKTtcbiAgICAgICAgICAgIGlmIChuZXh0U3RhdGUgIT09IHNlbGVjdG9yLnN0YXRlIHx8IHNlbGVjdG9yLmVycm9yKSB7XG4gICAgICAgICAgICAgIHNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIHNlbGVjdG9yLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICBzZWxlY3Rvci5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZWxlY3RvciBmYWlsZWQnLCBlKTtcbiAgICAgICAgICAgIHNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBzZWxlY3Rvci5lcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNlbGVjdG9yLnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgc2VsZWN0b3Iuc3Vic2NyaXB0aW9uID0gc3RvcmUuc3Vic2NyaWJlKHNldENvbXBvbmVudFN0YXRlKTtcbiAgICB9O1xuICAgIHNlbGVjdG9yLnVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0b3Iuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBzZWxlY3Rvci5zdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXNlIGFyZSBqdXN0IHRvIGd1YXJkIGFnYWluc3QgZXh0cmEgbWVtb3J5IGxlYWthZ2UgaWYgYSBwYXJlbnQgZWxlbWVudCBkb2Vzbid0XG4gICAgICAgIC8vIGRlcmVmZXJlbmNlIHRoaXMgaW5zdGFuY2UgcHJvcGVybHksIHN1Y2ggYXMgYW4gYXN5bmMgY2FsbGJhY2sgdGhhdCBuZXZlciBmaW5pc2hlc1xuICAgICAgICBzZWxlY3Rvci5zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1lbW9pemUoZnVuYywgZXF1YWxpdHlDaGVjayA9IGRlZmF1bHRFcXVhbGl0eUNoZWNrKSB7XG4gIGxldCBsYXN0QXJncyA9IG51bGxcbiAgbGV0IGxhc3RSZXN1bHQgPSBudWxsXG4gIGNvbnN0IGlzRXF1YWxUb0xhc3RBcmcgPSAodmFsdWUsIGluZGV4KSA9PiBlcXVhbGl0eUNoZWNrKHZhbHVlLCBsYXN0QXJnc1tpbmRleF0pXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGlmIChcbiAgICAgIGxhc3RBcmdzID09PSBudWxsIHx8XG4gICAgICBsYXN0QXJncy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoIHx8XG4gICAgICAhYXJncy5ldmVyeShpc0VxdWFsVG9MYXN0QXJnKVxuICAgICkge1xuICAgICAgbGFzdFJlc3VsdCA9IGZ1bmMoLi4uYXJncylcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBhcmdzXG4gICAgcmV0dXJuIGxhc3RSZXN1bHRcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoZnVuY3MpIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShmdW5jc1swXSkgPyBmdW5jc1swXSA6IGZ1bmNzXG5cbiAgaWYgKCFkZXBlbmRlbmNpZXMuZXZlcnkoZGVwID0+IHR5cGVvZiBkZXAgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jeVR5cGVzID0gZGVwZW5kZW5jaWVzLm1hcChcbiAgICAgIGRlcCA9PiB0eXBlb2YgZGVwXG4gICAgKS5qb2luKCcsICcpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFNlbGVjdG9yIGNyZWF0b3JzIGV4cGVjdCBhbGwgaW5wdXQtc2VsZWN0b3JzIHRvIGJlIGZ1bmN0aW9ucywgYCArXG4gICAgICBgaW5zdGVhZCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBbJHtkZXBlbmRlbmN5VHlwZXN9XWBcbiAgICApXG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3IobWVtb2l6ZSwgLi4ubWVtb2l6ZU9wdGlvbnMpIHtcbiAgcmV0dXJuICguLi5mdW5jcykgPT4ge1xuICAgIGxldCByZWNvbXB1dGF0aW9ucyA9IDBcbiAgICBjb25zdCByZXN1bHRGdW5jID0gZnVuY3MucG9wKClcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoZnVuY3MpXG5cbiAgICBjb25zdCBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplKFxuICAgICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmVjb21wdXRhdGlvbnMrK1xuICAgICAgICByZXR1cm4gcmVzdWx0RnVuYyguLi5hcmdzKVxuICAgICAgfSxcbiAgICAgIC4uLm1lbW9pemVPcHRpb25zXG4gICAgKVxuXG4gICAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIHByb3BzLCAuLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBkZXBlbmRlbmNpZXMubWFwKFxuICAgICAgICBkZXBlbmRlbmN5ID0+IGRlcGVuZGVuY3koc3RhdGUsIHByb3BzLCAuLi5hcmdzKVxuICAgICAgKVxuICAgICAgcGFyYW1zLnB1c2gocHJvcHMpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkUmVzdWx0RnVuYyguLi5wYXJhbXMuY29uY2F0KGFyZ3MpKVxuICAgIH1cblxuICAgIHNlbGVjdG9yLnJlc3VsdEZ1bmMgPSByZXN1bHRGdW5jXG4gICAgc2VsZWN0b3IucmVjb21wdXRhdGlvbnMgPSAoKSA9PiByZWNvbXB1dGF0aW9uc1xuICAgIHNlbGVjdG9yLnJlc2V0UmVjb21wdXRhdGlvbnMgPSAoKSA9PiByZWNvbXB1dGF0aW9ucyA9IDBcbiAgICByZXR1cm4gc2VsZWN0b3JcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yKHNlbGVjdG9ycywgc2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3IpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCBgICtcbiAgICAgIGB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSAke3R5cGVvZiBzZWxlY3RvcnN9YFxuICAgIClcbiAgfVxuICBjb25zdCBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMoc2VsZWN0b3JzKVxuICByZXR1cm4gc2VsZWN0b3JDcmVhdG9yKFxuICAgIG9iamVjdEtleXMubWFwKGtleSA9PiBzZWxlY3RvcnNba2V5XSksXG4gICAgKC4uLnZhbHVlcykgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKGNvbXBvc2l0aW9uLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29tcG9zaXRpb25bb2JqZWN0S2V5c1tpbmRleF1dID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9uXG4gICAgICB9LCB7fSlcbiAgICB9XG4gIClcbn1cbiIsImltcG9ydCB7IHN0YXRlZnVsU2VsZWN0b3IgfSBmcm9tICcuL2NyZWF0ZVNlbGVjdG9yJztcblxuY29uc3QgTElGRV9IT09LUyA9IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGZpcmVzIGR1cmluZyBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcsIGJ1dCBjb21wb25lbnREaWRNb3VudCBhbmRcbiAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgZG8gbm90LiBCZWNhdXNlIG9mIHRoaXMsIHRyeVN1YnNjcmliZSBoYXBwZW5zIGR1cmluZyAuLi5kaWRNb3VudC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bnN1YnNjcmlwdGlvbiB3b3VsZCBuZXZlciB0YWtlIHBsYWNlIGR1cmluZyBTU1IsIGNhdXNpbmcgYSBtZW1vcnkgbGVhay5cbiAgICAgICAgLy8gVG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGEgY2hpbGQgY29tcG9uZW50IG1heSBoYXZlIHRyaWdnZXJlZCBhIHN0YXRlIGNoYW5nZSBieVxuICAgICAgICAvLyBkaXNwYXRjaGluZyBhbiBhY3Rpb24gaW4gaXRzIGNvbXBvbmVudFdpbGxNb3VudCwgd2UgaGF2ZSB0byByZS1ydW4gdGhlIHNlbGVjdCBhbmQgbWF5YmVcbiAgICAgICAgLy8gcmUtcmVuZGVyLlxuICAgICAgICB0aGlzLnNlbGVjdG9yLnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc2VsZWN0b3Iuc3RhdGU7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBudWxsO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bihuZXh0UHJvcHMpO1xuICAgIH0sXG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZTtcbiAgICB9LFxufTtcblxuZnVuY3Rpb24gbWl4aW5TdGF0ZUxpZmVjeWNsZShpbnN0YW5jZSwgSE9PS1MpIHtcbiAgICBPYmplY3Qua2V5cyhIT09LUykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlRm4gPSBpbnN0YW5jZVtrZXldO1xuICAgICAgICBpbnN0YW5jZVtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYmFzZUZuKSBiYXNlRm4uYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gSE9PS1Nba2V5XS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBVc2VkIGFzIGB7c3RhdGU6IC4ufWAgZXh0ZW5zaW9uIGZvciBlbGVtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXRlRnJvbVN0b3JlKHtcbiAgICBzdG9yZUZvciA9IHN0b3JlRm9yQnlQcm9wLFxuICAgIHN0YXRlU2VsZWN0b3IgPSByZXR1cm5QYXJhbSxcbiAgICBhY3Rpb25Gb3JDaGFuZ2UgPSByZXR1cm5QYXJhbSxcbiAgICBzdGF0ZUV4dHJhY3RvcixcbiAgICBzdGF0ZUV4dHJhY3RvclNlbGVjdG9yLFxuICAgIHN0YXRlUmVmaW5lcixcbiAgICBwYXJlbnRTdGF0ZSA9IGRlZmF1bHRQYXJlbnRTdGF0ZSxcbiAgICBkaXNwYXRjaE1ldGhvZHMsXG4gICAgY29tcG9uZW50TWV0aG9kTmFtZXMgPSB7fSxcbn0pIHtcbiAgICBjb25zdCBzdG9yZUZvckNvbnRleHQgPSBzdG9yZUZvckNvbnRleHRDdXJyeShzdG9yZUZvcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNvcmF0ZUNvbXBvbmVudChpbnN0YW5jZSwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IGNvbnRleHQuc3RvcmUgPyBjb250ZXh0LnN0b3JlIDogY29udGV4dDtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaE1ldGhvZHMgJiYgYXBpLmRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kcyA9IGRpc3BhdGNoTWV0aG9kcygoYWN0aW9uKSA9PiBhcGkuZGlzcGF0Y2goYWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwgbWV0aG9kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3RvciA9IHN0YXRlZnVsU2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgc3RhdGVTZWxlY3Rvciwgc3RhdGVSZWZpbmVyLCBjb250ZXh0LnN0b3JlLFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0b3IucnVuKGluc3RhbmNlLnByb3BzKTsgLy9UT0RPIHBsYWNlIHJpZ2h0IGxvY2F0aW9uP1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRTdGF0ZShpbnN0YW5jZS5zZWxlY3Rvci5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1peGluU3RhdGVMaWZlY3ljbGUoaW5zdGFuY2UsIExJRkVfSE9PS1MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3QoZWwsIHByb3BzLCBpbnRlcm5hbCkge1xuICAgICAgICAgICAgbGV0IHN0b3JlID0gc3RvcmVGb3JDb250ZXh0KGVsKTsgLy8gY291bGQgYWxzbyB1c2UgZW5zdXJlU3RvcmVGb3IgaWYgY3JlYXRlU3RvcmUgaXMgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFzdG9yZSAmJiBlbC5jcmVhdGVTdG9yZSkge1xuICAgICAgICAgICAgICAgIGVsLmNyZWF0ZVN0b3JlKCk7XG4gICAgICAgICAgICAgICAgc3RvcmUgPSBzdG9yZUZvckNvbnRleHQoZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBleHRyYWN0U3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzdGF0ZUV4dHJhY3RvclNlbGVjdG9yID8gZWwucXVlcnlTZWxlY3RvckFsbChzdGF0ZUV4dHJhY3RvclNlbGVjdG9yKSA6IGVsLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZWRBY3Rpb24gPSBzdGF0ZUV4dHJhY3Rvcihwcm9wcywgQXJyYXkuZnJvbShjaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVkQWN0aW9uKSBzdG9yZS5kaXNwYXRjaChzZWVkQWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0U3RhdGU6IHN0YXRlRXh0cmFjdG9yID8gZXh0cmFjdFN0YXRlIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJldHVyblBhcmFtKHBhcmFtKSB7IHJldHVybiBwYXJhbTsgfVxuZnVuY3Rpb24gcmV0dXJuU2Vjb25kUGFyYW0oXywgcGFyYW0pIHsgcmV0dXJuIHBhcmFtOyB9XG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJlbnRTdGF0ZShlbCwgc3RvcmUpIHtcbiAgICBmb3IobGV0IHAgPSBlbC5wYXJlbnROb2RlOyBwOyBwID0gcC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICgnc3RhdGUnIGluIHApIHJldHVybiBwLnN0YXRlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVGb3JCeVByb3AoZWwsbmV3U3RvcmUpIHtcbiAgICBpZiAobmV3U3RvcmUpIGVsLnN0b3JlID0gbmV3U3RvcmU7XG4gICAgcmV0dXJuIGVsLnN0b3JlIHx8IGVsLmNvbmZsdXhDb250ZXh0LnN0b3JlO1xufVxuXG5mdW5jdGlvbiBzdG9yZUZvckNvbnRleHRDdXJyeShzdG9yZUZvcikge1xuICAgIHJldHVybiBlbCA9PiB7XG4gICAgICAgIHdoaWxlKGVsKSB7XG4gICAgICAgICAgICBsZXQgc3RvcmUgPSBzdG9yZUZvcihlbCk7XG4gICAgICAgICAgICBpZiAoc3RvcmUpIHJldHVybiBzdG9yZTtcbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuIiwiLy8gY29uZmx1eCAtIGNvbnRleHR1YWwgZmx1eFxuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnemVuLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgY29udmVyc2F0aW9uUmVkdWNlciB9IGZyb20gJy4uL2NvbnZlcnNhdGlvbi9hY3Rpb25zJztcbmltcG9ydCB7IGNvbnRlbnRSZWR1Y2VyIH0gZnJvbSAnLi4vY29udGVudC9hY3Rpb25zJztcbmltcG9ydCB7IHNob3djYXNlUmVkdWNlciB9IGZyb20gJy4uL3Nob3djYXNlL2FjdGlvbnMnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IEFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xufTtcblxuXG5jb25zdCBkZWZhdWx0Q29udGV4dCA9IHtcbiAgICAvLyBzdG9yZTogZGVmYXVsdFN0b3JlXG4gICAgcHJlbG9hZGVkU3RhdGU6IHtcbiAgICAgICAgdGhyZWFkOiBbXSxcbiAgICAgICAgc2hvd2Nhc2U6IFtdLFxuICAgICAgICBzaG93Y2FzZVN0YXRlOiB7fSxcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgY2hhaW5lZCA9IGNoYWluUmVkdWNlcnMoY29udmVyc2F0aW9uUmVkdWNlciwgY29udGVudFJlZHVjZXIsIHNob3djYXNlUmVkdWNlcik7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0U3RvcmUgPSBkZWZhdWx0Q29udGV4dC5zdG9yZSA9IGNyZWF0ZVN0b3JlKGNoYWluZWQsIGRlZmF1bHRDb250ZXh0LCB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXygpKTtcblxuLy8gdGhpcyBtYXkgZ28gYXdheSBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGF0cy13cm9uZy13aXRoLWV4dGVuZGluZy10aGUtZG9tL1xuSFRNTEVsZW1lbnQucHJvdG90eXBlLmNvbmZsdXhDb250ZXh0ID0gZGVmYXVsdENvbnRleHQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGVsLCBjb250ZXh0KSB7XG4gICAgY29uc3QgY3R4ID0gT2JqZWN0LmNyZWF0ZShkZWZhdWx0Q29udGV4dCk7XG4gICAgZWwuY29uZmx1eENvbnRleHQgPSBPYmplY3QuYXNzaWduKGN0eCwgY29udGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBjb250ZXh0LCBlbmhhbmNlcikge1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuICAgIHJlZHVjZXIgPSBtaXhpbkNvbnRleHQocmVkdWNlcik7XG4gICAgbGV0IHByZWxvYWRlZFN0YXRlID0gY29udGV4dC5wcmVsb2FkZWRTdGF0ZTtcbiAgICBsZXQgb2JzZXJ2YWJsZSxcbiAgICAgICAgcXVldWUgPSBbXSxcbiAgICAgICAgY3VycmVudFJlZHVjZXIsXG4gICAgICAgIGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgY3VycmVudExpc3RlbmVycyxcbiAgICAgICAgbmV4dExpc3RlbmVycyxcbiAgICAgICAgaXNEaXNwYXRjaGluZztcblxuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbmhhbmNlcihfY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpIHtcbiAgICAgICAgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICAgICAgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICAgICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gICAgICAgIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAgICAgICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgICAgICAgb2JzZXJ2YWJsZSA9IChuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpXG4gICAgICAgICAgICAgICAgLy8gbm8gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgc2V0SW50ZXJ2YWwoZGlzcGF0Y2hRdWV1ZWQsIDI1MCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgICBxdWV1ZURpc3BhdGNoLFxuICAgICAgICAgIGRpc3BhdGNoUXVldWVkLFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICByZXBsYWNlUmVkdWNlcixcbiAgICAgICAgICBvYnNlcnZhYmxlLFxuICAgICAgICAvLyAgIFskJG9ic2VydmFibGVdOiBvYnNlcnZhYmxlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0YXRlKCkgeyByZXR1cm4gY3VycmVudFN0YXRlOyB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBjYXZlYXRzOlxuICAgICAqXG4gICAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAgICpcbiAgICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldFJvb3QgVGhlIHJvb3Qgb2JqZWN0IGZvciB3aGljaCB0byBnZXQgbm90aWZpY2F0aW9ucyAoVE9ETylcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lciwgZ2V0Um9vdCkge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWVcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpXG4gICAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlXG5cbiAgICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKVxuICAgICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWV1ZURpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICBxdWV1ZS5wdXNoKGFjdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hRdWV1ZWQoKSB7XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZGlzcGF0Y2gpO1xuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlXG4gICAgICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24sIGNvbnRleHQpXG4gICAgICAgICAgLy9UT0RPIGlkZW50aWZ5IHBvaW50cyBvZiBzdGF0ZSBkaXZlcmdlbmNlID09PVxuICAgICAgICAgIC8vVE9ETyBjb21wYXJlIHdpdGggbWVtb3J5IGZvciBzZWxlY3RvcnNcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbygndXBkYXRlZCBzdGF0ZScsIGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIC8vVE9ETyBkaWQgc3RhdGUgY2hhbmdlP1xuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzXG4gICAgICAgIGN1cnJlbnRMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcblxuICAgICAgICByZXR1cm4gYWN0aW9uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50UmVkdWNlciA9IG1peGluQ29udGV4dChuZXh0UmVkdWNlcik7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWl4aW5Db250ZXh0KHJlZHVjZXIpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YXRlRnJvbVN0b3JlfSBmcm9tICcuL3N0YXRlRnJvbVN0b3JlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoYWluUmVkdWNlcnMoLi4uY2hhaW4pIHtcbiAgICByZXR1cm4gKHN0YXJ0U3RhdGUsIGFjdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICByZXR1cm4gY2hhaW4ucmVkdWNlKChzdGF0ZSwgZm4pID0+IGZuKHN0YXRlLCBhY3Rpb24sIGNvbnRleHQpLCBzdGFydFN0YXRlKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzIChyZWR1Y2VycyA9IHt9KSB7XG5cdHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcblx0cmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uIChzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcblx0XHR2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdHZhciBuZXh0U3RhdGUgPSB7fTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQga2V5ID0gcmVkdWNlcktleXNbaV07XG5cdFx0XHRuZXh0U3RhdGVba2V5XSA9IHJlZHVjZXJzW2tleV0oc3RhdGVba2V5XSwgYWN0aW9uKTtcblx0XHRcdGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZVtrZXldICE9PSBzdGF0ZVtrZXldO1xuXHRcdH1cblx0XHRyZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVGcm9tQ29uZmx1eEF0dHJpYnV0ZShlbCkge1xuXHRjb25zdCBjb25mbHV4RWwgPSBlbC5jbG9zZXN0KCdbY29uZmx1eF0nKTtcblx0aWYgKGNvbmZsdXhFbCkge1xuXHRcdGlmIChjb25mbHV4RWwuc3RvcmUpIHJldHVybiBjb25mbHV4RWwuc3RvcmU7XG5cdFx0aWYgKGNvbmZsdXhFbC5jcmVhdGVTdG9yZSkge1xuXHRcdFx0Y29uZmx1eEVsLnN0b3JlID0gY29uZmx1eEVsLmNyZWF0ZVN0b3JlKCk7XG5cdFx0XHRyZXR1cm4gY29uZmx1eEVsLnN0b3JlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbmZsdXggPSBjb25mbHV4RWwuZ2V0QXR0cmlidXRlKCdjb25mbHV4Jyk7XG5cbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uQ29udGV4dCA9IHt9OyAvL1RPRE8gcGFnZXdpZGUgY29uZmlnXG5cbiAgICAgICAgY29uZmx1eEVsLnN0b3JlID0gZGVmYXVsdFN0b3JlO1xuXHR9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBc1N1YkNvbXBvbmVudChvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2hNZXRob2RzLFxuICAgIH0gPSBvcHRzO1xuXG4gICAgY29uc3QgeyBkZWNvcmF0ZUNvbXBvbmVudCB9ID0gc3RhdGU/IHN0YXRlKG9wdHMpIDoge307XG5cbiAgICAvL1RPRE8gbWFya2luZyBtZXRob2RzIG9uIGNvbXBvbmVudCBjbGFzcyBhcyBARXhwb3NlT25FbGVtZW50KClcblxuICAgIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IoQmFzZUNvbXBvbmVudCkge1xuXG4gICAgICAgIHJldHVybiBjbGFzcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgICAgICAgICAgc3RhdGljIGdldCBuYW1lKCkgeyByZXR1cm4gQmFzZUNvbXBvbmVudC5uYW1lIH07XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChkZWNvcmF0ZUNvbXBvbmVudCkgZGVjb3JhdGVDb21wb25lbnQodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqIEBqc3ggY3JlYXRlRWxlbWVudCAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBWTm9kZUZyb21KU09OTUwgfSBmcm9tICcuLi9kb20vaW5mZXJub1RyZWVSZW5kZXJlcic7XG5pbXBvcnQgeyBBc1N1YkNvbXBvbmVudCwgaW5jcmVtZW50YWxUZW1wbGF0ZXMgfSBmcm9tICcuLi9kb20nO1xuaW1wb3J0IHsgc3RhdGVGcm9tU3RvcmUgfSBmcm9tICcuLi9kYXRhL2NvbmZsdXgnO1xuXG5AQXNTdWJDb21wb25lbnQoe1xuICAgIHN0YXRlOiBzdGF0ZUZyb21TdG9yZSxcbiAgICBkaXNwYXRjaE1ldGhvZHM6IGRpc3BhdGNoID0+ICh7XG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBzZXRSZXNwb25zZShibG9ja0luZGV4LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdzZXQgcmVzcG9uc2UnLCBibG9ja0luZGV4LCBwYXlsb2FkIH0pO1xuICAgICAgICB9LFxuICAgIH0pLFxufSlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnZlcnNhdGlvbkJsb2NrIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRlbXBsYXRlSWQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiAndGVtcGxhdGUtaWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGV4OiBOdW1iZXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29tcHV0ZWRQcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjbGFzcyc6IGZ1bmN0aW9uKGJhc2UsIHtyZW5kZXJpbmd9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5iYXNlLCAndGhlaXInLCB0aGlzLmJsb2NrU3RhdHMuY2xhc3Nlcy5sZWZ0VGhyZWFkLCByZW5kZXJpbmcgJiYgJ2Jsb2NrLXJlbmRlcmluZyddXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgICAvLyBpZiAobmV4dFByb3BzLnRlbXBsYXRlSWQgJiYgIXRoaXMuYmxvY2tUZW1wbGF0ZSkge1xuICAgICAgICAvLyAgICAgaWYgKHRoaXMuYmxvY2tTdGF0cy5uZXdCbG9jayAmJiBuZXh0UHJvcHMudGVtcGxhdGVJZCkge1xuICAgICAgICAvLyAgICAgICAgIC8vIHRoaXMuXG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICByZW5kZXIocHJvcHMpIHtcbiAgICAgICAgLy8gcmV0dXJuICg8Y29udmVyc2F0aW9uLWJsb2NrIHRpdGxlPVwiSGVsbG8sIFdlIGFyZVwiIGNvbnRlbnQtaWQ9XCJIZWxsb1wiIHRvcGljPVwiY29udmVyc2F0aW9uXCIgY2xhc3M9XCJ0aGVpciBsZWZ0LXRocmVhZFwiPlxuICAgICAgICAvLyAgICAgPHAgY2xhc3M9XCJzdGF0ZW1lbnRcIiBzdHlsZT1cIlwiPkhpLCB3ZSBhcmUgYSBEaWdpdGFsIFRlY2hub2xvZ3kgJmFtcDsgRGVzaWduIEFkdmlzb3J5IGhlbHBpbmcgdGVhbXMgdG8ga2ljayBvZmYgbmV3IHByb2R1Y3RzIHRoYXQgYXJlIGRlc2lnbmVkIGFuZCBlbmdpbmVlcmVkIGZvciBhIGdyZWF0IGV4cGVyaWVuY2UgZnJvbSBkYXkgb25lLjwvcD48cCBjbGFzcz1cInN0YXRlbWVudFwiPkhhdmUgYSBsb29rIGF0IG91ciByZWNlbnQgcHJvamVjdHM8L3A+XG4gICAgICAgIC8vICAgICA8cCBjbGFzcz1cInN0YXRlbWVudFwiPlxuICAgICAgICAvLyAgICAgICAgIDx4LXBvcnRmb2xpby1zcHJlYWQgcG9ydGZvbGlvPVwic2hvd2Nhc2VcIj48ZGl2IGNsYXNzPVwic3ByZWFkLWNvbnRlbnRcIj5cbiAgICAgICAgLy8gICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwcmVhZC1pdGVtXCI+PGltZyBzcmM9XCIvaW1hZ2VzL0hlbnJ5TG9va2luZ1NxIHNtYWxsLmpwZ1wiLz48ZGl2IGNsYXNzPVwidGl0bGVzXCI+PGgyPkhlbnJ5PC9oMj48aDYgY2xhc3M9XCJhdXRob3JcIj5ieSBILiBWZW5kZWxibzwvaDY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cInNwcmVhZC1pdGVtXCI+PGltZyBzcmM9XCIvaW1hZ2VzL0thdHR5LUhlbnJ5IDQ1Ny5qcGdcIi8+PGRpdiBjbGFzcz1cInRpdGxlc1wiPjxoMj5IZW5yeTwvaDI+PGg2IGNsYXNzPVwiYXV0aG9yXCI+YnkgSC4gVmVuZGVsYm88L2g2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcHJlYWQtaXRlbVwiPjxpbWcgc3JjPVwiL2ltYWdlcy9TcGxpdFNoaXJlLTAyMS5qcGdcIi8+PGRpdiBjbGFzcz1cInRpdGxlc1wiPjxoMj5IZW5yeTwvaDI+PGg2IGNsYXNzPVwiYXV0aG9yXCI+YnkgSC4gVmVuZGVsYm88L2g2PjwvZGl2PjwvZGl2PjxidXR0b24gY2xhc3M9XCJwcmV2LWJ0blwiPuKdrjwvYnV0dG9uPjxidXR0b24gY2xhc3M9XCJuZXh0LWJ0blwiPuKdrzwvYnV0dG9uPjwvZGl2PlxuICAgICAgICAvLyAgICAgICAgIDwveC1wb3J0Zm9saW8tc3ByZWFkPjwvcD5cbiAgICAgICAgLy8gICAgIDxwIGNsYXNzPVwic3RhdGVtZW50XCI+PC9wPlxuICAgICAgICAvLyAgICAgPC9jb252ZXJzYXRpb24tYmxvY2s+KTtcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgYmxvY2tUZW1wbGF0ZSA9IGluY3JlbWVudGFsVGVtcGxhdGVzLmdldChwcm9wcy50ZW1wbGF0ZUlkKTtcbiAgICAgICAgaWYgKGJsb2NrVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25NTCA9IGJsb2NrVGVtcGxhdGUucmVuZGVySlNPTk1MKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAganNvbk1MWzFdLmNsYXNzTmFtZSA9IFwidGhlaXIgbGVmdC10aHJlYWRcIjsgLy9UT0RPIHdheSB0byBtaXhpbiB0aGUgY2xhc3NcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrVk5vZGUgPSBWTm9kZUZyb21KU09OTUwoanNvbk1MKTtcbiAgICAgICAgICAgIHJldHVybiBibG9ja1ZOb2RlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByb3BzKSB7XG4gICAgICAgIC8vVE9ETyBkZWxheWVkIHF1ZXN0aW9uXG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT4gLDEwMDApXG4gICAgICAgIC8vIHRoaXMuc2V0UmVzcG9uc2UocHJvcHMuYmxvY2tJbmRleCwgeyBoaWRkZW5SZXNwb25zZTpmYWxzZSB9KTtcbiAgICB9XG59XG4iLCIvKiogQGpzeCBjcmVhdGVFbGVtZW50ICovXG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQsIFZOb2RlRnJvbUpTT05NTCB9IGZyb20gJy4uLy4uL2RvbS9pbmZlcm5vVHJlZVJlbmRlcmVyJztcblxuaW1wb3J0IGluY3JlbWVudGFsVGVtcGxhdGVzIGZyb20gJy4uLy4uL2RvbS9pbmNyZW1lbnRhbFRlbXBsYXRlcyc7XG5cbmZ1bmN0aW9uIHJlbmRlckh0bWxQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiB7XG4gICAgICAgICd0eXBlJzogcHJvcHMudHlwZSxcbiAgICAgICAgJ2Jsb2NrLWluZGV4JzogcHJvcHMuYmxvY2tJbmRleCxcbiAgICAgICAgJ3RlbXBsYXRlLWlkJzogcHJvcHMudGVtcGxhdGVJZCxcbiAgICAgICAgJ2NsYXNzTmFtZSc6IHByb3BzLmJ1YmJsZVJpZ2h0ID8gJ2J1YmJsZSBidWJibGUtcmlnaHQnIDogJycsXG4gICAgICAgICdlZGl0aW5nJzogcHJvcHMuZWRpdGluZyxcbiAgICAgICAgJ25leHQtYmxvY2staWQnOiBwcm9wcy5uZXh0QmxvY2tJZCxcbiAgICAgICAgJ3RvcGljJzogcHJvcHMudG9waWMsXG4gICAgICAgIC8vIG9uY2xpY2s6IHRoaXMuc3RhcnQuYmluZCh0aGlzKSxcbiAgICB9O1xufVxuXG5jb25zdCBlZGl0UmVuZGVyZXJCeVR5cGUgPSB7XG4gICAgc2xpZGVzKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcGFydCB9ID0gcHJvcHM7XG4gICAgICAgIGlmIChwYXJ0ICYmIHBhcnRbMF0gPT09ICdzZWxlY3QnICYmIHBhcnRbMV0udHlwZSA9PT0gJ3RpbWVsaW5lJykge1xuICAgICAgICAgICAgY29uc3Qgc3RhZ2VzID0gcGFydC5zbGljZSgyLDEwMCkubWFwKG9wdGlvbiA9PiAoeyAuLi5vcHRpb25bMV0uYXR0cnMsIHRleHQ6IG9wdGlvblsyXSB8fCAnJyB9KSk7XG4gICAgICAgICAgICByZXR1cm4gKDxvbCBjbGFzc05hbWU9e3Byb3BzLmNob2ljZSAmJiAnbWFkZS1jaG9pY2UnfT57XG4gICAgICAgIFx0XHRzdGFnZXMubWFwKGVudHJ5ID0+IDxsaT48bGFiZWwgaHJlZj48YSBvbmNsaWNrPXsoKSA9PiBwcm9wcy5raWNrb2ZmKGVudHJ5KX0+e2VudHJ5LnRleHR9PC9hPjwvbGFiZWw+PC9saT4pXG4gICAgICAgIFx0fTxsaS8+PC9vbD4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPHNwYW4gY2xhc3NOYW1lPVwiYWN0aW9uLW9wZW5cIj48L3NwYW4+KTtcbiAgICB9LFxuICAgIGRlZmF1bHQocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICg8c3BhbiBjbGFzc05hbWU9XCJhY3Rpb24tb3BlblwiIG9uQ2xpY2s9e3Byb3BzLmxvZ0V2ZW50fSBvbkNoYW5nZT17cHJvcHMuY2hhbmdlRXZlbnR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJsaW5raW5nLWN1cnNvclwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8QWN0aW9uUGFydCB7Li4ucHJvcHN9IHBhcnQ9e3Byb3BzLnBhcnR9IC8+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICk7XG4gICAgfSxcbn07XG5cbmNvbnN0IHNpbmdsZVN0YWdlQnlUeXBlID0ge1xuICAgIHNsaWRlczogdHJ1ZSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25SZW5kZXJlcih0eXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2xpZGVzJzogcmV0dXJuIFNsaWRlc0FjdGlvbjtcbiAgICAgICAgY2FzZSAnbWVzc2FnZSc6IHJldHVybiBNZXNzYWdlQWN0aW9uO1xuICAgICAgICBjYXNlICdub25lJzogcmV0dXJuIE5vQWN0aW9uO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gU2VudGVuY2VBY3Rpb247XG4gICAgfVxufVxuXG5mdW5jdGlvbiBOb0FjdGlvbihwcm9wcykge1xuICAgIHJldHVybiA8dGhyZWFkLWFjdGlvbiBjbGFzc05hbWU9XCJuby1hY3Rpb25cIi8+O1xufVxuXG5mdW5jdGlvbiBTbGlkZXNBY3Rpb24ocHJvcHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8dGhyZWFkLWFjdGlvbiB7Li4ucmVuZGVySHRtbFByb3BzKHByb3BzKX0gZnVsbCBlZGl0aW5nPXtwcm9wcy5lZGl0aW5nfSBjbGFzc05hbWU9XCJ0aW1lbGluZS1raWNrb2ZmXCI+XG4gICAgICAgICAgICA8QWN0aW9uUGFydCB7Li4ucHJvcHN9IHBhcnQ9e3Byb3BzLmlucHV0c1swXSB8fCB7fX0gLz5cbiAgICAgICAgPC90aHJlYWQtYWN0aW9uPlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIE1lc3NhZ2VBY3Rpb24ocHJvcHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8dGhyZWFkLWFjdGlvbj5cbiAgICAgICAgICAgIDxpbnB1dCBuYW1lPVwibWVzc2FnZVwiIHR5cGU9e3Byb3BzLmlucHV0VHlwZX0gY2xhc3NOYW1lPVwiZnJlZS10ZXh0XCIgcGxhY2Vob2xkZXI9e3Byb3BzLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIG9uaW5wdXQ9e3Byb3BzLm9uSW5wdXR9IG9uY2hhbmdlPXtwcm9wcy5vbkNoYW5nZX0gb25ibHVyPXtwcm9wcy5vbkJsdXJ9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgPC90aHJlYWQtYWN0aW9uPlxuICAgICk7XG59XG5cblxuZnVuY3Rpb24gU2VudGVuY2VBY3Rpb24ocHJvcHMpIHtcbiAgICBjb25zdCBzdGF0aWNQYXJ0ID0gcHJvcHMuaW5wdXRzWzBdOyAvL1RPRE8gYWxsIGZpbGxlZCBvbmVzXG4gICAgY29uc3QgbmV4dFBhcnQgPSBwcm9wcy5pbnB1dHNbMV0gOyAvL1RPRE8gZmlyc3QgdW5maWxsZWRcblxuXG4gICAgLy9UT0RPIG1ha2Ugc3RhdGljUGFydCB3aXRoIGFscmVhZHkgY2hvc2VuIGJpdC4gKHNlbnRlbmNlIGNvbnN0cnVjdGlvbilcbiAgICByZXR1cm4gKFxuICAgICAgICA8dGhyZWFkLWFjdGlvbiB7Li4ucmVuZGVySHRtbFByb3BzKHByb3BzKX0gZnVsbCBlZGl0aW5nPXtwcm9wcy5lZGl0aW5nfSBjbGFzc05hbWU9XCJ0aW1lbGluZS1raWNrb2ZmXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhY3Rpb24tY2hvc2VuXCI+e3Byb3BzLnN0YXRpY1BhcnR9PC9zcGFuPlxuXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhY3Rpb24tb3BlblwiIG9uQ2xpY2s9e3Byb3BzLmxvZ0V2ZW50fSBvbkNoYW5nZT17cHJvcHMuY2hhbmdlRXZlbnR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJsaW5raW5nLWN1cnNvclwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8QWN0aW9uUGFydCB7Li4ucHJvcHN9IHBhcnQ9e25leHRQYXJ0ID8gW25leHRQYXJ0LnRhZywgbmV4dFBhcnQuYXR0cnNdLmNvbmNhdChuZXh0UGFydC5jaGlsZHJlbikgOiBbJ3NwYW4nLHt9XX0gLz5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC90aHJlYWQtYWN0aW9uPlxuICAgICk7XG59XG5cbi8qKlxuICoga2lja29mZihlbnRyeSlcbiAqIGNob2ljZVxuICogcGFydCA9IHsgdGFnLCBhdHRycywgY2hpbGRyZW4gfSB8IHN0cmluZ1xuICovXG5mdW5jdGlvbiBBY3Rpb25QYXJ0KHByb3BzKSB7XG4gICAgY29uc3QgeyBwYXJ0IH0gPSBwcm9wcztcbiAgICBzd2l0Y2godHlwZW9mIHBhcnQpIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzogLy8gbm8gaW5wdXRzIGluIGFjdGlvblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDxzcGFuPntwYXJ0fTwvc3Bhbj47XG4gICAgfVxuXG4gICAgLy9UT0RPIGluaXRpYWwgdmFsdWUgLyBjdXJyZW50IHZhbHVlIGZyb20gc3RhdGVcblxuICAgIHN3aXRjaChwYXJ0LnRhZykge1xuICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgaWYgKHBhcnQuYXR0cnMudHlwZSA9PT0gJ3RpbWVsaW5lJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWdlcyA9IHBhcnQuY2hpbGRyZW4ubWFwKG9wdGlvbiA9PiAoeyAuLi5vcHRpb25bMV0uYXR0cnMsIHRleHQ6IG9wdGlvblsyXSB8fCAnJyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICg8b2wgY2xhc3NOYW1lPXtwcm9wcy5jaG9pY2UgJiYgJ21hZGUtY2hvaWNlJ30+e1xuICAgICAgICAgICAgXHRcdHN0YWdlcy5tYXAoZW50cnkgPT4gPGxpPjxsYWJlbCBocmVmPjxhIG9uY2xpY2s9eygpID0+IHByb3BzLmtpY2tvZmYoZW50cnkpfT57ZW50cnkudGV4dH08L2E+PC9sYWJlbD48L2xpPilcbiAgICAgICAgICAgIFx0fTxsaS8+PC9vbD4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBWTm9kZUZyb21KU09OTUwocGFydCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTaG9ydFRocmVhZEFjdGlvbihwcm9wcykge1xuICAgIC8vIGlmICghYWN0aW9uVGVtcGxhdGUpIHJldHVybiBVbmtub3duQWN0aW9uKHByb3BzKTtcbiAgICBjb25zdCBodG1sUHJvcHMgPSByZW5kZXJIdG1sUHJvcHMocHJvcHMpO1xuICAgIHJldHVybiA8dGhyZWFkLWFjdGlvbiB7Li4uaHRtbFByb3BzfSBvbkNsaWNrPXsoKSA9PiBzdGFydEFjdGlvbihwcm9wcyl9IHNob3J0Pnsgc2hvcnRlblRleHQocHJvcHMudGV4dCwyMCkgfTwvdGhyZWFkLWFjdGlvbj47XG59XG5cbi8vIHN0YXJ0IHRoZSBhY3Rpb24gd2l0aGluIGEgcmVzcG9uc2Ugb3IgaW5wdXRcbi8vIEBFeHBvc2VPbkVsZW1lbnQoKVxuZnVuY3Rpb24gc3RhcnRBY3Rpb24ocHJvcHMpIHtcbiAgICBjb25zdCB7IGJsb2NrSW5kZXgsIHRlbXBsYXRlSWQ6YWN0aW9uSWQsIGZpZWxkTmFtZXM6cmVxdWlyZWRGaWVsZHMsIHJlc3BvbnNlVGVtcGxhdGUgfSA9IHByb3BzLFxuICAgICAgICBhY3Rpb25UZW1wbGF0ZSA9IGluY3JlbWVudGFsVGVtcGxhdGVzLmdldChhY3Rpb25JZCwndGhyZWFkLWFjdGlvbicpLFxuICAgICAgICBoaWRkZW5SZXNwb25zZSA9IGZhbHNlO1xuXG4gICAgLy8gbm8gd2F5IHRvIHJlLXN0YXJ0IGFuIGFjdGlvblxuICAgIC8vVE9ETyBpZiAoYWN0aW9uSWQgPT09IHRoaXMuc3RhdGUuYWN0aW9uSWQpIHJldHVybjtcbiAgICBpZiAocHJvcHMuYmV0YSkge1xuICAgICAgICAvLyBXZSdyZSBub3QgYWJsZSB0byBoYXZlIG1vdmUgaW5mb3JtYXRpb25zIGF0IHRoaXMgbW9tZW50LCBzb3JyeS5cbiAgICAgICAgcHJvcHMuZGlzcGF0Y2goe3R5cGU6J3N0YXJ0IHJlc3BvbnNlJywgYmxvY2tJbmRleCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHsgYmxvY2tJbmRleCwgYWN0aW9uSWQsIHJlcXVpcmVkRmllbGRzLCByZXNwb25zZVRlbXBsYXRlLCBoaWRkZW5SZXNwb25zZSB9fSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZmllbGRzKSB7XG4gICAgICAgIHByb3BzLmRpc3BhdGNoKHt0eXBlOidzdGFydCByZXNwb25zZScsIGJsb2NrSW5kZXgsIHBheWxvYWQ6IHsgYmxvY2tJbmRleCwgYWN0aW9uSWQsIHJlcXVpcmVkRmllbGRzLCByZXNwb25zZVRlbXBsYXRlLCBoaWRkZW5SZXNwb25zZSB9fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMuZGlzcGF0Y2goe3R5cGU6J3NldCByZXNwb25zZScsIGJsb2NrSW5kZXgsIHBheWxvYWQ6IHsgYmxvY2tJbmRleCwgYWN0aW9uSWQsIHJlcXVpcmVkRmllbGRzLCByZXNwb25zZVRlbXBsYXRlLCBoaWRkZW5SZXNwb25zZX19KTtcbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiBVbmtub3duQWN0aW9uKHByb3BzKSB7XG4gICAgY29uc3QgaHRtbFByb3BzID0gcmVuZGVySHRtbFByb3BzKHByb3BzKTtcbiAgICByZXR1cm4gKDx0aHJlYWQtYWN0aW9uIHsuLi5odG1sUHJvcHN9IHNob3J0Pio8L3RocmVhZC1hY3Rpb24+KTtcbn1cblxuZnVuY3Rpb24gc2hvcnRlblRleHQodGV4dCwgbWF4KSB7XG4gICAgaWYgKHRleHQubGVuZ3RoIDwgbWF4KSByZXR1cm4gdGV4dDtcbiAgICBsZXQgcGFydHMgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXggKyAyKS5zcGxpdCgnICcpO1xuICAgIC0tcGFydHMubGVuZ3RoO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcgJykgKyAnLi4nO1xufVxuIiwiLyoqIEBqc3ggY3JlYXRlRWxlbWVudCAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBWTm9kZUZyb21KU09OTUwgfSBmcm9tICcuLi9kb20vaW5mZXJub1RyZWVSZW5kZXJlcic7XG5pbXBvcnQgQXNTdWJDb21wb25lbnQgZnJvbSAnLi4vZG9tL0FzU3ViQ29tcG9uZW50JztcbmltcG9ydCB7IHN0YXRlRnJvbVN0b3JlIH0gZnJvbSAnLi4vZGF0YS9jb25mbHV4JztcbmltcG9ydCB7IFNob3J0VGhyZWFkQWN0aW9uLCBhY3Rpb25SZW5kZXJlciB9IGZyb20gJy4vYWN0aW9ucy9UaHJlYWRBY3Rpb24nO1xuaW1wb3J0IGluY3JlbWVudGFsVGVtcGxhdGVzIGZyb20gJy4uL2RvbS9pbmNyZW1lbnRhbFRlbXBsYXRlcyc7XG4vLyBpbXBvcnQgeyByZWR1Y2VyIGFzIGZvcm1SZWR1Y2VyIH0gZnJvbSAncmVkdXgtZm9ybSc7XG5cbmZ1bmN0aW9uIHN0YXRlU2VsZWN0b3Ioc3RvcmVTdGF0ZSwgcHJvcHMpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGluY3JlbWVudGFsVGVtcGxhdGVzLmdldChwcm9wcy50ZW1wbGF0ZUlkKTtcbiAgICBpZiAoIXRlbXBsYXRlKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IGJsb2NrID0gc3RvcmVTdGF0ZS50aHJlYWRbcHJvcHMuaW5kZXhdO1xuICAgIGNvbnN0IG90aGVyQWN0aW9ucyA9IHRlbXBsYXRlLmFjdGlvbnNcbiAgICAgICAgLmZpbHRlcihlbCA9PiBlbC50ZW1wbGF0ZUlkICE9PSBibG9jay5hY3Rpb25JZCAmJiBlbC50eXBlICE9PSAnbWVzc2FnZScpXG4gICAgICAgIC5tYXAoYWN0aW9uID0+IGFjdGlvbi5nZXRSZW5kZXJQcm9wcyhwcm9wcywgYmxvY2spKTtcbiAgICBjb25zdCBhY3Rpb25zID0gdGVtcGxhdGUuYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGVsID0+IGJsb2NrLmFjdGlvbklkID8gZWwudGVtcGxhdGVJZCA9PT0gYmxvY2suYWN0aW9uSWQgOiB0cnVlKVxuICAgICAgICAubWFwKGFjdGlvbiA9PiBhY3Rpb24uZ2V0UmVuZGVyUHJvcHMocHJvcHMsIGJsb2NrKSk7XG4gICAgY29uc3QgbWVzc2FnZUFjdGlvbiA9IGFjdGlvbnMuZmluZChhY3Rpb24gPT4gYWN0aW9uLnR5cGUgPT09ICdtZXNzYWdlJyB8fCBhY3Rpb24udGVtcGxhdGVJZCA9PT0gYmxvY2suYWN0aW9uSWQpO1xuXG4gICAgLy8gVHlwZSBvZiBzZWxlY3RlZCBhY3Rpb24sIG1lc3NhZ2UgaWYgaW4gYXZhaWxhYmxlIGFjdGlvbnMsIG9yIG5vbmUuIFVzZWQgdG8gZGV0ZXJtaW5lIE1lc3NhZ2UgVG9vbGJhclxuICAgIGNvbnN0IGFjdGl2ZUFjdGlvblR5cGUgPSBhY3Rpb25zLmxlbmd0aCA9PT0gMSA/IGFjdGlvbnNbMF0udHlwZSA6IChtZXNzYWdlQWN0aW9uID8gJ21lc3NhZ2UnOidub25lJyk7XG5cbiAgICBjb25zdCBzZWxlY3RlZEFjdGlvblR5cGUgPSBhY3Rpb25zLmxlbmd0aCA9PT0gMSA/IGFjdGlvbnNbMF0udHlwZSA6IG51bGw7XG4gICAgY29uc3QgZW5hYmxlTWVzc2FnZSA9IGFjdGlvbnMucmVkdWNlKChyZXN1bHQsIGFjdGlvbikgPT4gcmVzdWx0IHx8IGFjdGlvbi5lbmFibGVNZXNzYWdlLCBmYWxzZSk7XG5cbiAgICByZXR1cm4geyAuLi4gYmxvY2ssIHRlbXBsYXRlLCBhY3Rpb25zLCBvdGhlckFjdGlvbnMsIHNlbGVjdGVkQWN0aW9uVHlwZSwgYWN0aXZlQWN0aW9uVHlwZSwgZW5hYmxlTWVzc2FnZSwgbWVzc2FnZUFjdGlvbiB9XG59XG5cbkBBc1N1YkNvbXBvbmVudCh7XG4gICAgc3RhdGU6IHN0YXRlRnJvbVN0b3JlLFxuICAgIHN0YXRlU2VsZWN0b3IsXG4gICAgc3RhdGVSZWZpbmVyOiAoc3RhdGUsIHByb3BzKSA9PiBzdGF0ZSxcbiAgICBkaXNwYXRjaE1ldGhvZHM6IGRpc3BhdGNoID0+ICh7XG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBzZXRSZXNwb25zZShwYXlsb2FkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdzZXQgcmVzcG9uc2UnLCBibG9ja0luZGV4OiB0aGlzLmluZGV4IHx8IHRoaXMucHJvcHMuaW5kZXgsIHBheWxvYWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0TWVzc2FnZUVudHJ5KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmFjdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhY3Rpb25JZCB9ID0gdGhpcy5zdGF0ZS5lbmFibGVNZXNzYWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IGFjdGlvbklkIH07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnc2V0IHJlc3BvbnNlJywgYmxvY2tJbmRleDogdGhpcy5pbmRleCB8fCB0aGlzLnByb3BzLmluZGV4LCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdWJtaXRSZXNwb25zZSgpIHtcblxuICAgICAgICB9LFxuICAgIH0pLFxufSlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnZlcnNhdGlvblJlc3BvbnNlIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIC8vIHN0YXRpYyBnZXQgcHJvcHMoKSB7XG4gICAgLy8gICAgIHJldHVybiB7XG4gICAgLy8gICAgICAgICBzdG9yZUNoYW5nZXM6IHByb3AubnVtYmVyKCksIC8vVE9ETyBidWlsZCBpbnRvIGN1c3RvbUV4dGVuc2lvbnMgLyBjb25mbHV4XG4gICAgLy8gICAgICAgICB0ZW1wbGF0ZUlkOiBwcm9wLnN0cmluZyh7IGF0dHJpYnV0ZTogdHJ1ZSB9KSxcbiAgICAvLyAgICAgICAgIGluZGV4OiBwcm9wLm51bWJlcih7IGF0dHJpYnV0ZTogdHJ1ZSB9KSxcbiAgICAvLyAgICAgICAgIGhpZGRlbjogcHJvcC5ib29sZWFuKHsgYXR0cmlidXRlOiB0cnVlIH0pLFxuICAgIC8vICAgICB9O1xuICAgIC8vIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcblxuICAgICAgICBjb25zdCBvdGhlciA9IHRoaXMub3RoZXJQcm9wcyA9IHt9O1xuXG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMubWVzc2FnZVByb3BzID0ge1xuICAgICAgICAgICAgb25JbnB1dDogKHsgdGFyZ2V0IH0pID0+IHRoaXMuc3RhcnRNZXNzYWdlRW50cnkoKSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAoeyB0YXJnZXQgfSkgPT4geyBtc2cudmFsdWUgPSB0YXJnZXQudmFsdWU7IHRoaXMuc3RhcnRNZXNzYWdlRW50cnkoKTsgfSxcbiAgICAgICAgICAgIG9uQmx1cjogKHsgdGFyZ2V0IH0pID0+IHsgbXNnLnZhbHVlID0gdGFyZ2V0LnZhbHVlOyB0aGlzLnN0YXJ0TWVzc2FnZUVudHJ5KCk7IH0sXG4gICAgICAgICAgICBpbnB1dFR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgIG9uU3VibWl0LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdUeXBlIG1lc3NhZ2UgLi4uJyxcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBvblN1Ym1pdChldmVudCkge1xuICAgICAgICAgICAgLy9UT0RPIHN1Ym1pdCByZXNwb25zZVxuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdTdWJtaXQnLCBtc2cudmFsdWUpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG1zZy52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBjb21wdXRlZFByb3BzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2NsYXNzJzogZnVuY3Rpb24oYmFzZSwge3JlbmRlcmluZ30pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZXNwb25zZSkgcmV0dXJuIFsuLi5iYXNlLCAnbXknLCAncmlnaHQtdGhyZWFkJ107XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuYWN0aW9uSWQpIHJldHVybiBbLi4uYmFzZSwgJ215JywgJ3JpZ2h0LXRocmVhZCddO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5iYXNlLCAnbXknLCAnY29tbW9uLXRocmVhZCcsICdwaWNrLXJlc3BvbnNlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyVGVtcGxhdGVBY3Rpb25zKHByb3BzLCB7IHRlbXBsYXRlIH0pIHtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZSB8fCAhdGVtcGxhdGUuYWN0aW9ucykgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gO1xuICAgIH1cblxuICAgIHJlbmRlcihwcm9wcywgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBsZXQgY2xhc3NOYW1lID0gc3RhdGUuYWN0aW9ucy5sZW5ndGg9PTEgPyAnbXkgcmlnaHQtdGhyZWFkIHBpY2stcmVzcG9uc2UnOidteSBjb21tb24tdGhyZWFkIHBpY2stcmVzcG9uc2UnO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gJ215IGNvbW1vbi10aHJlYWQgcGljay1yZXNwb25zZSc7XG5cbiAgICAgICAgICAgIC8vVE9ETyBmaWxsIGludG8gdGhlIHRvb2xiYXIgd2hlbiBhY3Rpb24gaXMgcGlja2VkIGFuZCBub24tc2xpZGVcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGNvbnZlcnNhdGlvbi1yZXNwb25zZSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gaGlkZGVuPXtwcm9wcy5oaWRkZW5SZXNwb25zZX0+XG4gICAgICAgICAgICAgICAgICAgIDxPdGhlckFjdGlvbnMgey4uLnRoaXMub3RoZXJQcm9wc30gYWN0aW9ucz17c3RhdGUub3RoZXJBY3Rpb25zfSBkaXNwYXRjaD17dGhpcy5kaXNwYXRjaH0gaW5kZXg9e3Byb3BzLmluZGV4fSAvPlxuICAgICAgICAgICAgICAgICAgICA8TWVzc2FnZVRvb2xiYXIgey4uLnRoaXMubWVzc2FnZVByb3BzfSBzdGF0ZT17c3RhdGV9IGJsb2NrSW5kZXg9e3Byb3BzLmluZGV4fSAvPlxuICAgICAgICAgICAgICAgIDwvY29udmVyc2F0aW9uLXJlc3BvbnNlPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdoZW4gYWN0aW9uIHdhcyBzdGFydGVkIGFuZCBjYW5jZWwgaXMgc2VsZWN0ZWRcbiAgICBjYW5jZWxBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhY3Rpb24tc3RhcnRlZCcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gT3RoZXJBY3Rpb25zKHByb3BzKSB7XG4gICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNcIj57IHByb3BzLmFjdGlvbnMubWFwKFxuICAgICAgICAgICAgYWN0aW9uID0+IDxTaG9ydFRocmVhZEFjdGlvbiB7Li4uYWN0aW9ufSBibG9ja0luZGV4PXtwcm9wcy5pbmRleH0gZGlzcGF0Y2g9e3Byb3BzLmRpc3BhdGNofSAvPlxuICAgICAgICApXG4gICAgICB9PC9kaXY+KTtcbn1cblxuZnVuY3Rpb24gTWVzc2FnZVRvb2xiYXIocHJvcHMpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBwcm9wcztcbiAgICBjb25zdCBUaHJlYWRBY3Rpb24gPSBhY3Rpb25SZW5kZXJlcihzdGF0ZS5hY3RpdmVBY3Rpb25UeXBlKTtcblxuICAgIC8vID8gPFRocmVhZEFjdGlvbiB7Li4uc3RhdGUuYWN0aW9uc1swXX0gc3RhdGU9e3N0YXRlfSBidWJibGVSaWdodD17dHJ1ZX0gYmxvY2tJbmRleD17cHJvcHMuaW5kZXh9IC8+XG5cbiAgICAvLyBpT1MgZ28gYnV0dG9uXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTY2NTIwMy9nZXR0aW5nLWlwaG9uZS1nby1idXR0b24tdG8tc3VibWl0LWZvcm1cbiAgICByZXR1cm4gKFxuICAgICAgICA8bmF2IGNsYXNzTmFtZT1cInRvb2xiYXJcIj5cbiAgICAgICAgICAgIDxmb3JtIGNsYXNzTmFtZT1cInRleHQtZm9ybVwiIG9uc3VibWl0PXtwcm9wcy5vblN1Ym1pdH0gYWN0aW9uPVwic2VuZCBtZXNzYWdlXCI+XG4gICAgICAgICAgICAgICAgPFRocmVhZEFjdGlvbiB7Li4ucHJvcHN9IHsuLi5zdGF0ZS5tZXNzYWdlQWN0aW9ufSBidWJibGVSaWdodD17dHJ1ZX0gLz5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzc05hbWU9XCJpY29uczgtcGFwZXItcGxhbmUyXCIgLz5cbiAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgPC9uYXY+XG4gICAgKTtcbiAgICAvLyA8YnV0dG9uIGNsYXNzTmFtZT1cInBlcnNvblwiIHR5cGU9XCJidXR0b25cIj7wn5ejPC9idXR0b24+XG4gICAgLy8gPGJ1dHRvbiBjbGFzc05hbWU9XCJzdWJtaXRcIiB0eXBlPVwiYnV0dG9uXCIgb25jbGljaz17c3VibWl0RnJlZVRleHR9PuKHoTwvYnV0dG9uPlxuICAgIC8vIDxidXR0b24gY2xhc3NOYW1lPVwiY2FtZXJhXCIgdHlwZT1cImJ1dHRvblwiPvCfk7c8L2J1dHRvbj5cbiAgICAvLyA8YnV0dG9uIGNsYXNzTmFtZT1cInJlY29yZFwiIHR5cGU9XCJidXR0b25cIj7wn46kPC9idXR0b24+XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnQgdmFyIG5hbWVzID0gW107XG5leHBvcnQgdmFyIHNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydCB2YXIgZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5leHBvcnQgdmFyIGNvbG9ycyA9IFtdO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBjb2xvcnNbcHJldkNvbG9yKysgJSBjb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWRSZXR1cm5lZCgpIHtcbiAgfVxuICBkaXNhYmxlZFJldHVybmVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWRSZXR1cm5lZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgLy8gICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIC8vIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCAvKmV4cG9ydHMubG9nIHx8Ki8gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkUmV0dXJuZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZFJldHVybmVkIDogZGlzYWJsZWRSZXR1cm5lZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChuYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqIEBqc3ggY3JlYXRlRWxlbWVudCAqL1xuLyoqXG4gKiBUaHJlYWRzIGFyZSBjb252ZXJzYXRpb25zIHRoYXQgdGhlIHVzZXIgbWF5IHBpY2sgdXAuIFNvIHRoZXkgc3RhcnQgd2l0aCBhIGNvbnZlcnNhdGlvbiBvcGVuZXIuXG4gKi9cbmltcG9ydCBJbmZlcm5vQ29tcGF0IGZyb20gJ2luZmVybm8tY29tcGF0JztcbmltcG9ydCBBc0N1c3RvbUVsZW1lbnQgZnJvbSAnLi4vZG9tL0FzQ3VzdG9tRWxlbWVudCc7XG5pbXBvcnQgaW5mZXJub1RyZWVSZW5kZXJlciwgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi9kb20vaW5mZXJub1RyZWVSZW5kZXJlcic7XG5cbmltcG9ydCB7IHN0YXRlRnJvbVN0b3JlIH0gZnJvbSAnLi4vZGF0YS9jb25mbHV4JztcbmltcG9ydCB7IGNvbnZlcnNhdGlvblJlZHVjZXIgfSBmcm9tICcuL2FjdGlvbnMnO1xuXG5pbXBvcnQgQ29udmVyc2F0aW9uQmxvY2sgZnJvbSAnLi9Db252ZXJzYXRpb25CbG9jayc7XG5pbXBvcnQgQ29udmVyc2F0aW9uUmVzcG9uc2UgZnJvbSAnLi9Db252ZXJzYXRpb25SZXNwb25zZSc7XG5cbmltcG9ydCBkZWJ1Z0ZuIGZyb20gJy4uL2RlYnVnJztcbmNvbnN0IGRlYnVnID0gZGVidWdGbignY29udmVyc2F0aW9uJyk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RTb3VyY2UoY2hpbGQpIHtcblx0cmV0dXJuIHtcblx0XHRzcmM6IGNoaWxkLnNyYyxcblx0XHRzcmNzZXQ6IGNoaWxkLnNyY3NldCxcblx0XHR0eXBlOiBjaGlsZC50eXBlLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0TGVhZChjaGlsZCkge1xuXHRzd2l0Y2goY2hpbGQubG9jYWxOYW1lKSB7XG5cdFx0Y2FzZSAnaW1nJzpcblx0XHRcdHJldHVybiB7IHR5cGU6J2ltZycsIHNyYzogY2hpbGQuc3JjLCBhbHQ6IGNoaWxkLmdldEF0dHJpYnV0ZSgnYWx0JyksIHdpZHRoOiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIGhlaWdodDogY2hpbGQuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSwgfTtcblx0XHRjYXNlICd2aWRlbyc6XG5cdFx0XHRyZXR1cm4geyB0eXBlOid2aWRlbycsIHNvdXJjZXM6IEFycmF5LmZyb20oY2hpbGQuY2hpbGRyZW4pLm1hcChleHRyYWN0U291cmNlKSwgfTtcblx0fVxuXHQvL1RPRE8gbWFyayBmb3IgcmVtb3ZhbFxufVxuXG5mdW5jdGlvbiBsb2dFbnRyeShlbnRyeSkge1xuXHRjb25zb2xlLmluZm8oZW50cnkpO1xuXHRyZXR1cm4gZW50cnk7XG59XG4vKlxuVGhyZWFkcyBjb3VsZCBwcm92aWRlIGEgLmNvbnRleHQgbGlrZSBpbiBSZWFjdC4gQSBjb250ZXh0IGNoYWluIGNvdWxkIGJlIG1haW4gdXNpbmcgT2JqZWN0LmNyZWF0ZShteUNvbnRleHQpXG4qL1xuQEFzQ3VzdG9tRWxlbWVudCh7XG5cdC8vIHRhZzogJ2NvbnZlcnNhdGlvbi10aHJlYWQnLCBUT0RPIHF1ZXVlIGRlZmluZSBpbnN0ZWFkXG4gICAgdHJlZVJlbmRlcmVyOiBpbmZlcm5vVHJlZVJlbmRlcmVyLFxuXHRzdGF0ZTogc3RhdGVGcm9tU3RvcmUsXG4gICAgc3RhdGVTZWxlY3RvcjogKHN0b3JlU3RhdGUsIHByb3BzKSA9PiBzdG9yZVN0YXRlLnRocmVhZCxcblx0Ly9UT0RPIHN0YXRlIGV4dHJhY3RvciB0byBsb2FkIHBhc3QgY29udmVyc2F0aW9uXG5cdHByb3BzRXh0cmFjdG9yOiAoY2hpbGRyZW4pID0+ICh7IGxlYWRzOiBjaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gY2hpbGQuaGFzQXR0cmlidXRlKCdjb252ZXJzYXRpb24tbGVhZCcpKS5tYXAoZXh0cmFjdExlYWQpIH0pLFxuXHRkaXNwYXRjaE1ldGhvZHM6IGRpc3BhdGNoID0+ICh7XG5cdFx0c3RhcnRUb3BpYyhwYXlsb2FkKSB7XG5cdFx0XHRkaXNwYXRjaCh7IHR5cGU6ICdzdGFydCB0b3BpYycsIHBheWxvYWQgfSlcblx0XHR9LFxuXHR9KSxcbn0pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb252ZXJzYXRpb25UaHJlYWQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9waWM6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnY29udmVyc2F0aW9uJyB9LFxuICAgICAgICAgICAgc3RhcnRCbG9jazogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdyb290JyB9LFxuICAgICAgICAgICAgLy8gc3RhcnRCbG9jazogcHJvcC5zdHJpbmcoeyBhdHRyaWJ1dGU6ICdzdGFydC1ibG9jaycsIGRlZmF1bHQ6ICdyb290JyB9KSAvLyBjb2VyY2UodmFsdWUpID0+IHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICAvKiAxKSBmaXJzdCB2aXNpdCBzaHdvaW5nIGluaXRpYWwgYmxvY2ssIDIpIHN1YnNlcXVlbnQgLSBwaWNrIHVwIG9uZ29pbmcsIDMpIHN1YnNlcXVlbnQgLSBmaW5pc2hlZCwgb3B0aW9uIHRvIHN0YXJ0IG5ldy4gKi9cblxuICAgICAgICAvLyBJZiBsb2NhdGlvbi9yb3V0ZXIgc3BlY2lmaWVzIGEgbG9jYXRpb24gaW4gcGFzdCBjb252ZXJzYXRpb24sIGFkanVzdCBpdFxuICAgICAgICAvLyBJZiBsb2NhdGlvbi9yb3V0ZXIgc3BlY2lmaWVzIGEgcmVzcG9uc2UgdG8gY3VycmVudCBibG9jaywgY3JlYXRlIHJlc3BvbnNlXG4gICAgICAgIC8vIE90aGVyd2lzZSBzdGFydCB3aXRoIHByZS1jb25maWd1cmVkIGJsb2NrXG5cbiAgICAgICAgdGhpcy5zdGFydFRvcGljKHsgdG9waWM6IHRoaXMucHJvcHMudG9waWMsIHN0YXJ0QmxvY2s6IHRoaXMucHJvcHMuc3RhcnRCbG9jayB9KTtcbiAgICB9XG5cblx0Ly8gSlNPTlRNTCA9IEpTT04gVGVtcGxhdGUgTWFya3VwIExhbmd1YWdlIChhZGp1c3RlZCBhdHRyaWJ1dGVzIGFuZCBmdW5jdGlvbnMgc2VtYW50aWMgZm9yIGR5bmFtaWMgY29udGVudClcbiAgICByZW5kZXIocHJvcHMpIHtcblx0XHRsZXQgYmxvY2tzID0gSW5mZXJub0NvbXBhdC5DaGlsZHJlbi5tYXAodGhpcy5zZWxlY3Rvci5zdGF0ZSwgKGJsb2NrLCBpbmRleCkgPT5cblx0XHRcdGJsb2NrLnR5cGUgPT09ICdyZXNwb25zZSdcblx0XHRcdFx0PyA8Q29udmVyc2F0aW9uUmVzcG9uc2Ugey4uLmJsb2NrfSBrZXk9e2luZGV4fSBpbmRleD17aW5kZXh9IHRvcGljPXtwcm9wcy50b3BpY31cblx0XHRcdFx0XHRoaWRkZW49e2Jsb2NrLmhpZGRlblJlc3BvbnNlfSAvPlxuXHRcdFx0XHQ6IDxDb252ZXJzYXRpb25CbG9jayB7Li4uYmxvY2t9IGtleT17aW5kZXh9IGluZGV4PXtpbmRleH0gLz5cblx0XHRcdCk7XG5cdFx0aWYgKGJsb2NrcyA9PT0gbnVsbCkge1xuXHRcdFx0YmxvY2tzID0gWydObyBjb252ZXJzYXRpb24gdGhyZWFkJ107XG5cdFx0fSBlbHNlIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRibG9ja3MucHVzaCg8ZGl2Pk5vIGNvbnZlcnNhdGlvbiBzdGFydGVkPC9kaXY+KTtcblx0XHR9XG5cblx0XHRjb25zdCBMZWFkcyA9IHByb3BzLmxlYWRzLmxlbmd0aCA/IENvbnZlcnNhdGlvbkxlYWRzIDogKCkgPT4gPGhlYWRlci8+O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxMZWFkcyB7Li4ucHJvcHN9IC8+XG4gICAgICAgICAgICAgICAgPHNlY3Rpb24gc2Vzc2lvbj1cIm5ld1wiIGNsYXNzPVwiY29tbW9uLXRocmVhZFwiPntibG9ja3N9PC9zZWN0aW9uPlxuICAgICAgICAgICAgPC9kaXY+KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEF1dGhvckxpbmUocHJvcHMpIHtcblx0cmV0dXJuICg8ZGl2IGNsYXNzPVwiYXV0aG9yXCI+XG5cdFx0PHNwYW4gY2xhc3M9XCJjaGF0LWhlYWRzIHNtYWxsZXItY2hhdC1oZWFkXCI+PGltZyBjbGFzcz1cImJpby1oZWFkXCIgc3JjPXtwcm9wcy5zcmN9IC8+PC9zcGFuPlxuXHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+e3Byb3BzLm5hbWV9PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImxvY2F0aW9uXCI+e3Byb3BzLmxvY2F0aW9ufTwvZGl2PlxuXHQ8L2Rpdj4pO1xufVxuXG5mdW5jdGlvbiBDb252ZXJzYXRpb25MZWFkcyhwcm9wcykge1xuXHRjb25zdCBhdXRob3IgPSB7XG5cdFx0c3JjOiAnL2ltYWdlcy9IZW5yeUxvb2tpbmdTcSBzbWFsbC5qcGcnLFxuXHRcdG5hbWU6ICdIZW5yaWsgVmVuZGVsYm8nLFxuXHRcdGxvY2F0aW9uOiAnWsO8cmljaCwgU3dpdHplcmxhbmQnLFxuXHRcdGNsYXNzTmFtZTogJ2xlYWQnLFxuXHR9O1xuXHRmdW5jdGlvbiBTaW5nbGVMZWFkKGxlYWQpIHtcblx0XHQvL1RPRE8gdHlwZSA9IHZpZGVvXG5cblx0XHRyZXR1cm4gPGltZyB7Li4ubGVhZH0gLz47XG5cdH1cblx0cmV0dXJuICg8aGVhZGVyIGNsYXNzPVwicG9zdFwiPlxuXHRcdDxBdXRob3JMaW5lIHsuLi5hdXRob3J9IC8+XG5cdFx0PGRpdiBjbGFzcz1cImxlYWRzXCI+eyBwcm9wcy5sZWFkcy5tYXAoU2luZ2xlTGVhZCkgfTwvZGl2PlxuXHRcdDwvaGVhZGVyPik7XG59XG4iLCIvKiogQGpzeCBjcmVhdGVFbGVtZW50ICovXG4vKipcbiAqIFByZXNlbnRhdGlvbnMgYXJlIHZpZGVvL2ltYWdlL3NsaWRlcyB0aGF0IHJlcHJlc2VudCBhIGxhcmdlciBwb3N0L2RvY3VtZW50LlxuICovXG5pbXBvcnQgSW5mZXJub0NvbXBhdCBmcm9tICdpbmZlcm5vLWNvbXBhdCc7XG5pbXBvcnQgQXNDdXN0b21FbGVtZW50IGZyb20gJy4uL2RvbS9Bc0N1c3RvbUVsZW1lbnQnO1xuaW1wb3J0IGluZmVybm9UcmVlUmVuZGVyZXIsIHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vZG9tL2luZmVybm9UcmVlUmVuZGVyZXInO1xuXG5pbXBvcnQgeyBzdGF0ZUZyb21TdG9yZSB9IGZyb20gJy4uL2RhdGEvY29uZmx1eCc7XG5pbXBvcnQgeyBjb252ZXJzYXRpb25SZWR1Y2VyIH0gZnJvbSAnLi9hY3Rpb25zJztcblxuQEFzQ3VzdG9tRWxlbWVudCh7XG5cdHRhZzogJ3RocmVhZC1wcmVzZW50YXRpb24nLFxuICAgIHRyZWVSZW5kZXJlcjogaW5mZXJub1RyZWVSZW5kZXJlcixcblx0c3RhdGU6IHN0YXRlRnJvbVN0b3JlLFxuICAgIHN0YXRlU2VsZWN0b3I6IChzdG9yZVN0YXRlLCBwcm9wcykgPT4gc3RvcmVTdGF0ZS50aHJlYWQsXG4gICAgLy8gcHJvcHNFeHRyYWN0b3JTZWxlY3RvcjogJ2Zsb3ctYXV0aG9yJyxcblx0Ly8gcHJvcHNFeHRyYWN0b3I6IChjaGlsZHJlbikgPT4gKHsgYXV0aG9yczogY2hpbGRyZW4ubWFwKGV4dHJhY3RBdXRob3IpIH0pLFxuXHRkaXNwYXRjaE1ldGhvZHM6IGRpc3BhdGNoID0+ICh7XG5cdFx0c3RhcnRUb3BpYyhwYXlsb2FkKSB7XG5cdFx0XHRkaXNwYXRjaCh7IHR5cGU6ICdzdGFydCB0b3BpYycsIHBheWxvYWQgfSlcblx0XHR9LFxuXHR9KSxcbn0pXG5leHBvcnQgY2xhc3MgVGhyZWFkUHJlc2VudGF0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgLy8gcG9zdGVyPVwiL2ltYWdlcy9pbnRyby9vcmctZ2FwLmpwZWdcIiBtcDQ9XCIvb3JnLWdhcC5tNHZcIiBhdXRob3JrZXlzPVwiaGVucmlrIGthdHR5XCJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc3RlcjogU3RyaW5nLFxuICAgICAgICAgICAgbXA0OiBTdHJpbmcsXG4gICAgICAgICAgICBwcmV0ZXh0OiBTdHJpbmcsXG4gICAgICAgICAgICBsZWFkOiBTdHJpbmcsXG4gICAgICAgICAgICBhdXRob3JzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgICAgICAgICAgIGNvZXJjZShhdXRob3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRob3JzLnNwbGl0KCcgJykubWFwKGF1dGhvcktleVRvRGF0YSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVySGVhZHMocHJvcHMpIHtcbiAgICAgICAgLy9UT0RPIGhvdmVyIG92ZXIgaGVhZHMgc3dpdGNoIHRoZSBhdXRob3IgZGV0YWlsIHNob3duXG4gICAgICAgIHJldHVybiA8YSBocmVmPXsgcHJvcHMud2Vic2l0ZSB9IGNsYXNzTmFtZT1cImltYWdlIGF2YXRhciBsaW5lLWl0ZW1cIj48aW1nIGNsYXNzTmFtZT1cIlwiIHNyYz17IHByb3BzLmltZ19zcmMgfSBhbHQ9eyBwcm9wcy5mdWxsX25hbWUgfSAvPjwvYT47XG4gICAgfVxuXG4gICAgcmVuZGVyQXV0aG9yRGV0YWlsKHByb3BzKSB7XG4gICAgICAgIHJldHVybiAoPGRpdiBjbGFzcz1cImRldGFpbFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj17IHByb3BzLndlYnNpdGUgfSBjbGFzc05hbWU9XCJsaW5lLWl0ZW0gbmFtZVwiPjxzdHJvbmc+eyBwcm9wcy5mdWxsX25hbWUgfTwvc3Ryb25nPjwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtwcm9wcy50d2l0dGVyICYmIDxhIGhyZWY9eyBwcm9wcy50d2l0dGVyIH0gY2xhc3NOYW1lPVwibGluZS1pdGVtIHR3aXR0ZXItbG9nbyBpZl90d2l0dGVyXzMxNzcyMFwiPiA8L2E+fVxuICAgICAgICAgICAgICAgICAgICAgICAge3Byb3BzLmxpbmtlZGluICYmIDxhIGhyZWY9eyBwcm9wcy5saW5rZWRpbiB9IGNsYXNzTmFtZT1cImxpbmUtaXRlbSBsaW5rZWRpbi1sb2dvIGlmX2NpcmNsZS1saW5rZWRpbl8zMTc3NTBcIj4gPC9hPn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge3Byb3BzLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHByb3BzKSB7XG4gICAgICAgIHJldHVybiAoPGRpdj5cbiAgICAgICAgICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwid2l0aC1jaGF0LWhlYWRzIHdpdGgtc21hbGxlci1jaGF0LWhlYWRzIGF1dGhvci1saW5lIHdpdGgtYXV0aG9yLWluZm9cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRzXCI+e3Byb3BzLmF1dGhvcnMubWFwKHByb3BzID0+IHRoaXMucmVuZGVySGVhZHMocHJvcHMpKX08L2Rpdj5cbiAgICAgICAgICAgICAgICB7cHJvcHMuYXV0aG9ycy5tYXAocHJvcHMgPT4gdGhpcy5yZW5kZXJBdXRob3JEZXRhaWwocHJvcHMpKX1cbiAgICAgICAgICAgIDwvaGVhZGVyPlxuICAgICAgICAgICAgPHZpZGVvIHBvc3Rlcj17cHJvcHMucG9zdGVyfSBtdXRlZCBwcmVsb2FkPVwiYXV0b1wiIGF1dG9wbGF5IHBsYXlzaW5saW5lPlxuICAgICAgICAgICAgICAgIHtwcm9wcy5tcDQgJiYgPHNvdXJjZSBzcmM9e3Byb3BzLm1wNH0gdHlwZT1cInZpZGVvL21wNDsgY29kZWNzPWF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiIC8+fVxuICAgICAgICAgICAgPC92aWRlbz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZWFkLWJveFwiPlxuICAgICAgICAgICAgICAgIDxwPntwcm9wcy5sZWFkfTwvcD5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHN0eWxlPVwid2lkdGg6IDkwcHg7XCIgaHJlZj1cInZvaWQ6XCI+TGVhcm4gbW9yZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0QXV0aG9yKGVsKSB7XG4gICAgLy8gVE9ETyBhdHRyaWJ1dGVzIC0+IG9iamVjdFxuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bGxfbmFtZTogZWwuZ2V0QXR0cmlidXRlKCdmdWxsLW5hbWUnKSxcbiAgICAgICAgd2Vic2l0ZTogZWwuZ2V0QXR0cmlidXRlKCd3ZWJzaXRlJyksXG4gICAgICAgIGltZ19zcmM6IGVsLmdldEF0dHJpYnV0ZSgnaW1nLXNyYycpLFxuICAgICAgICBiaW86IGVsLmdldEF0dHJpYnV0ZSgnYmlvJyksXG4gICAgICAgIHR3aXR0ZXI6ICdodHRwczovL3R3aXR0ZXIuY29tLycgKyBlbC5nZXRBdHRyaWJ1dGUoJ3R3aXR0ZXInKSxcbiAgICAgICAgbGlua2VkaW46ICdodHRwczovL2xpbmtlZGluLmNvbS9pbi8nICsgZWwuZ2V0QXR0cmlidXRlKCdsaW5rZWRpbicpLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGF1dGhvcktleVRvRGF0YShrZXkpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYG1ldGFba2V5PVwiJHtrZXl9XCJdYCk7XG4gICAgaWYgKCFlbCkgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVsbF9uYW1lOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z1bGwtbmFtZScpLFxuICAgICAgICB3ZWJzaXRlOiBlbC5nZXRBdHRyaWJ1dGUoJ3dlYnNpdGUnKSxcbiAgICAgICAgaW1nX3NyYzogZWwuZ2V0QXR0cmlidXRlKCdpbWctc3JjJyksXG4gICAgICAgIGJpbzogZWwuZ2V0QXR0cmlidXRlKCdiaW8nKSxcbiAgICAgICAgdGl0bGU6IGVsLmdldEF0dHJpYnV0ZSgndGl0bGUnKSxcbiAgICAgICAgdHdpdHRlcjogJ2h0dHBzOi8vdHdpdHRlci5jb20vJyArIGVsLmdldEF0dHJpYnV0ZSgndHdpdHRlcicpLFxuICAgICAgICBsaW5rZWRpbjogJ2h0dHBzOi8vbGlua2VkaW4uY29tL2luLycgKyBlbC5nZXRBdHRyaWJ1dGUoJ2xpbmtlZGluJyksXG4gICAgfTtcbn1cbiIsIi8qKiBAanN4IGNyZWF0ZUVsZW1lbnQgKi9cbi8vIGltcG9ydCAnd2hhdHdnLWZldGNoJztcbmltcG9ydCBBc0N1c3RvbUVsZW1lbnQgZnJvbSAnLi4vLi4vZG9tL0FzQ3VzdG9tRWxlbWVudCc7XG5pbXBvcnQgaW5mZXJub1RyZWVSZW5kZXJlciwgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi8uLi9kb20vaW5mZXJub1RyZWVSZW5kZXJlcic7XG5pbXBvcnQgQ29udmVyc2F0aW9uUmVzcG9uc2UgZnJvbSAnLi4vQ29udmVyc2F0aW9uUmVzcG9uc2UnO1xuXG5pbXBvcnQgeyBzdGF0ZUZyb21TdG9yZSwgc3RvcmVGcm9tQ29uZmx1eEF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL2RhdGEvY29uZmx1eCc7XG4vLyBjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2Zsb3ctY2FyZCcpO1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHMoc3RhZ2VzKSB7XG5cdHJldHVybiB7XG5cdFx0c3RhZ2VzLFxuXHR9O1xufVxuXG5mdW5jdGlvbiB0aW1lRW50cnlGcm9tU2VlZChlbCkge1xuXHRjb25zdCB7IGlkLCBpbm5lclRleHQ6dGV4dCB9ID0gZWw7XG5cdHJldHVybiB7XG5cdFx0aWQsXG5cdFx0dGV4dCxcblx0fTtcbn1cblxuZnVuY3Rpb24gS2lja29mZk1hcmt1cChwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuICg8b2wgY2xhc3NOYW1lPXtwcm9wcy5jaG9pY2UgJiYgJ21hZGUtY2hvaWNlJ30+e1xuXHRcdHByb3BzLnN0YWdlcy5tYXAoZW50cnkgPT4gPGxpPjxsYWJlbCBocmVmPjxhIG9uY2xpY2s9e3Byb3BzLmtpY2tvZmZ9PntlbnRyeS50ZXh0fTwvYT48L2xhYmVsPjwvbGk+KVxuXHR9PGxpLz48L29sPik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEBBc0N1c3RvbUVsZW1lbnQoe1xuXHR0YWc6ICd0aW1lbGluZS1raWNrb2ZmJyxcblx0dHJlZVJlbmRlcmVyOiBpbmZlcm5vVHJlZVJlbmRlcmVyLFxuXHRzdGF0ZTogc3RhdGVGcm9tU3RvcmUsXG5cdHN0YXRlU2VsZWN0b3I6IChzdG9yZVN0YXRlLCBwcm9wcykgPT4gc3RvcmVTdGF0ZS50aHJlYWQuZmlsdGVyKGJsb2NrID0+IGJsb2NrLnRvcGljID09PSBwcm9wcy50b3BpYyksXG5cdHByb3BzRXh0cmFjdG9yOiAoY2hpbGRyZW4pID0+IHtcblx0XHRjb25zb2xlLmluZm8oJ2NoJywgY2hpbGRyZW4pO1xuXHRcdHJldHVybiBleHRyYWN0UHJvcHMoY2hpbGRyZW4uZmlsdGVyKGVsID0+IGVsLmxvY2FsTmFtZSA9PT0gJ3RpbWUnKS5tYXAodGltZUVudHJ5RnJvbVNlZWQpKTtcblx0fSxcblx0ZGlzcGF0Y2hNZXRob2RzOiAoZGlzcGF0Y2gpID0+ICh7XG5cdFx0ZGlzcGF0Y2gsXG5cdFx0a2lja29mZihwYXlsb2FkKSB7XG5cdFx0XHRkaXNwYXRjaCh7IHR5cGU6ICdraWNrb2ZmJywgcGF5bG9hZCB9KTtcblx0XHR9LFxuXHR9KSxcbn0pXG5jbGFzcyBUaW1lbGluZUtpY2tvZmYgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aXRsZTogU3RyaW5nLFxuXHRcdFx0a2lja29mZkdvb2dsZUZvcm06IHsgdHlwZTogU3RyaW5nLCBhdHRyaWJ1dGU6ICdraWNrb2ZmZ29vZ2xlZm9ybScgfSxcblx0XHRcdHN0YWdlczogQXJyYXksXG5cdFx0XHR0b3BpYzogU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cblxuXHRzdWJtaXRHb29nbGVGb3JtKHByb3BzLCBzdGF0ZSkge1xuXHRcdGNvbnN0IGZvcm0gPSB7XG5cdFx0XHRwcm9qZWN0OiB7IG5hbWU6ICdlbnRyeS41NTIxMjM4MTMnIH0sXG5cdFx0XHRzZXNzaW9uOiB7IG5hbWU6ICdlbnRyeS4xMzc0MDkyNzQ2JyB9LFxuXHRcdFx0ZnVsbG5hbWU6IHsgbmFtZTogJ2VudHJ5LjE2NjI4MzUwMjgnIH0sXG5cdFx0XHRwaG9uZTogeyBuYW1lOiAnZW50cnkuNDk0NjI0MicgfSxcblx0XHRcdG1lc3NhZ2U6IHsgbmFtZTogJ2VudHJ5Ljg0NDU3MTk4NycgfSxcblx0XHR9O1xuXHRcdGlmIChwcm9wcy5raWNrb2ZmR29vZ2xlRm9ybSkge1xuXHRcdFx0Y29uc3QgcmVzcG9uc2VVcmwgPSBwcm9wcy5raWNrb2ZmR29vZ2xlRm9ybS5yZXBsYWNlKCcvdmlld2Zvcm0nLCcnKSArICcvZm9ybVJlc3BvbnNlJztcblxuXHRcdFx0ZnVuY3Rpb24gc2VuZERhdGEodXJsLCBkYXRhKSB7XG5cdFx0XHQgIHZhciBmb3JtRGF0YSAgPSBuZXcgRm9ybURhdGEoKTtcblxuXHRcdFx0ICBmb3IoY29uc3QgbmFtZSBpbiBkYXRhKSB7XG5cdFx0XHQgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIGRhdGFbbmFtZV0pO1xuXHRcdFx0ICB9XG5cblx0XHRcdCAgZmV0Y2gocmVzcG9uc2VVcmwsIHtcblx0XHRcdCAgICBtZXRob2Q6ICdQT1NUJyxcblx0XHRcdCAgICBib2R5OiBmb3JtRGF0YVxuXHRcdFx0ICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0ICAgICAvLyAuLi5cbiAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdSZXNwb25zZScsIHJlc3BvbnNlKTtcblx0XHRcdCAgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0fVxuXG5cdHJlbmRlckluaXRpYWwocHJvcHMsIHN0YXRlKSB7XG5cdFx0ZnVuY3Rpb24gYWxlcnRQaWNrT25UaW1lbGluZSgpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdQbGVhc2UgY2hvb3NlIGEgc3RhZ2UnKTtcbiAgICAgICAgfVxuXG5cdFx0Y29uc3QgaW5kZXggPSAxO1xuXHRcdGNvbnN0IGJsb2NrID0ge307XG5cblx0XHQvLyA8S2lja29mZk1hcmt1cCB7Li4ucHJvcHN9IGtpY2tvZmY9e3RoaXMua2lja29mZn0gLz5cblx0XHQvLyA8Q29udmVyc2F0aW9uUmVzcG9uc2Ugey4uLmJsb2NrfSBpbmRleD17aW5kZXh9IGRpc3BhdGNoPXt0aGlzLmRpc3BhdGNofSAvPlxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxoMT57IHByb3BzLnRpdGxlIH08L2gxPlxuXHRcdFx0XHQ8S2lja29mZk1hcmt1cCB7Li4ucHJvcHN9IGtpY2tvZmY9e3RoaXMua2lja29mZn0gLz5cblx0XHRcdFx0PGJ1dHRvbiBoaWRkZW49e3Byb3BzLmNob2ljZX0gb25DbGljaz17YWxlcnRQaWNrT25UaW1lbGluZX0+U3VibWl0PC9idXR0b24+XG5cdFx0XHRcdDxidXR0b24gb25jbGljaz17dGhpcy5zdWJtaXRHb29nbGVGb3JtKHByb3BzLCBzdGF0ZSl9PlNlbmQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2Pik7XG5cdH1cblxuXHRyZW5kZXJFbnRlck1lc3NhZ2UocHJvcHMsIHN0YXRlKSB7XG5cdFx0cmV0dXJuICg8ZGl2PlxuXHRcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIm1lc3NhZ2VcIiB2YWx1ZT1cIlwiLz5cblx0XHQ8L2Rpdj4pO1xuXHR9XG5cblx0cmVuZGVySWRlbnRpdHkocHJvcHMsIHN0YXRlKSB7XG5cdFx0ZnVuY3Rpb24gc3VibWl0SWRlbnRpdHkoKSB7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKDxkaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImlkZW50aXR5XCI+XG5cdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmdWxsbmFtZVwiIHZhbHVlPVwiXCIgcGxhY2Vob2xkZXI9XCJZb3VyIE5hbWVcIiAvPlxuXHRcdFx0XHQ8aW5wdXQgdHlwZT1cInRlbFwiIG5hbWU9XCJwaG9uZVwiIHZhbHVlPVwiXCIgcGxhY2Vob2xkZXI9XCJNb2JpbGUgTm8uXCIgLz5cblx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cInN1Ym1pdFwiIG9uY2xpY2s9e3N1Ym1pdElkZW50aXR5fT5JZGVudGlmeSBZb3Vyc2VsZjwvYnV0dG9uPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+KTtcblx0fVxuXG4gICAgcmVuZGVyQ29udGVudChwcm9wcywgc3RhdGUpIHtcblx0XHRjb25zdCB0aHJlYWQgPSB0aGlzLnNlbGVjdG9yLnN0YXRlO1xuXHRcdGlmICh0aHJlYWQubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFbnRlck1lc3NhZ2UocHJvcHMsIHN0YXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVySW5pdGlhbChwcm9wcywgc3RhdGUpO1xuXHRcdH1cblx0XHQvLyBpZGVudGl0eVxuXHRcdC8vIHN0YXR1c1xuXHRcdC8vIG1lc3NhZ2VcblxuICAgIH1cbiAgICByZW5kZXIocHJvcHMsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNvbnRlbnQocHJvcHMsIHN0YXRlKTtcbiAgICAgICAgLy8gcmV0dXJuIDx0aW1lbGluZS1raWNrb2ZmPnsgdGhpcy5yZW5kZXJDb250ZW50KHByb3BzKSB9PC90aW1lbGluZS1raWNrb2ZmPjtcbiAgICB9XG59XG4iLCJpbXBvcnQge3Bhc3RDb252ZXJzYXRpb259IGZyb20gJy4vdXNlclJlY29yZCc7XG5pbXBvcnQgaW5jcmVtZW50YWxUZW1wbGF0ZXMgZnJvbSAnLi4vZG9tL2luY3JlbWVudGFsVGVtcGxhdGVzJztcblxuaW1wb3J0IEJsb2NrVGVtcGxhdGUgZnJvbSAnLi9ibG9jay50ZW1wbGF0ZSc7XG5pbXBvcnQgU3RhdGVtZW50IGZyb20gJy4vc3RhdGVtZW50LnRlbXBsYXRlJztcbi8vIGltcG9ydCBUaHJlYWRBY3Rpb24gZnJvbSAnLi9hY3Rpb25zL3RocmVhZC1hY3Rpb24uZWxlbWVudCc7XG5pbXBvcnQgQWN0aW9uVGVtcGxhdGUgZnJvbSAnLi9hY3Rpb25zL3RocmVhZC1hY3Rpb24udGVtcGxhdGUnO1xuLy8gaW1wb3J0IENvbnZlcnNhdGlvbkJsb2NrIGZyb20gJy4vY29udmVyc2F0aW9uLWJsb2NrLmVsZW1lbnQnO1xuLy8gaW1wb3J0IENvbnZlcnNhdGlvblJlc3BvbnNlIGZyb20gJy4vY29udmVyc2F0aW9uLXJlc3BvbnNlLmVsZW1lbnQnO1xuaW1wb3J0IENvbnZlcnNhdGlvblRocmVhZCBmcm9tICcuL2NvbnZlcnNhdGlvbi10aHJlYWQuZWxlbWVudCc7XG5pbXBvcnQgJy4vdGhyZWFkLXByZXNlbnRhdGlvbi5lbGVtZW50Jztcbi8vIGltcG9ydCBQb3J0Zm9saW9TcHJlYWQgZnJvbSAnLi9wb3J0Zm9saW8tc3ByZWFkLmVsZW1lbnQnO1xuXG5pbXBvcnQgJy4vYWN0aW9ucy90aW1lbGluZS1raWNrb2ZmLmVsZW1lbnQnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbnRlbnRFbGVtZW50cygpIHtcbiAgICAvLyBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3RocmVhZC1hY3Rpb24nLFRocmVhZEFjdGlvbik7XG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjb252ZXJzYXRpb24tdGhyZWFkJywgQ29udmVyc2F0aW9uVGhyZWFkKTtcbn1cblxuLyoqXG4gKiBUZW1wbGF0ZXMgbWVhbnQgZm9yIGNvbnZlcnNhdGlvbnMgYXJlIGluZGV4ZWQgaW4gYGJsb2Nrc2AgYnkgaWQgYXR0cmlidXRlLlxuICogVGhlIElEIGlzIHJlbW92ZWQgc28gaXQgY2FuIGJlIHJldXNlZCBieSByZWd1bGFyIERPTSBlbGVtZW50cy5cbiAqXG4gKiBJbiBmdXR1cmUgdGhlIElEIHdpbGwgYmUgYSBoYXNoIG9mIHRoZSBjb250ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhblRlbXBsYXRlcygpIHtcbiAgICBpbmNyZW1lbnRhbFRlbXBsYXRlcy5kZWZpbmUoJ3RocmVhZC1hY3Rpb24nLCBBY3Rpb25UZW1wbGF0ZSk7XG4gICAgaW5jcmVtZW50YWxUZW1wbGF0ZXMuZGVmaW5lKCd0ZW1wbGF0ZScsIEJsb2NrVGVtcGxhdGUpOyAvL1RPRE8gJ3RlbXBsYXRlW3RvcGljXScgYW5kIG11bHRpcGxlIGRlZmluZSBzdXBwb3J0XG4gICAgaW5jcmVtZW50YWxUZW1wbGF0ZXMuZGVmaW5lKHRlbXBsYXRlID0+IEFycmF5LmZyb20oKHRlbXBsYXRlLmNvbnRlbnQgfHwgdGVtcGxhdGUpLmNoaWxkcmVuKSwgU3RhdGVtZW50KTsgLy8gaW1taWRpYXRlIGNoaWxkcmVuIGFyZSBhc3N1bWVkIHRvIGJlIHN0YXRlbWVudHNcbiAgICBpbmNyZW1lbnRhbFRlbXBsYXRlcy51cGdyYWRlRE9NKCk7XG4gICAgLy9UT0RPIHNjYW4gY29udmVyc2F0aW9uLWJsb2NrIGVsZW1lbnRzIGFscmVhZHkgcHV0IGluIHRoZSB0aHJlYWQgYnkgc2VydmVyIHJlbmRlcmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRDb252ZXJzYXRpb25zKCkge1xuICAgIGlmICghaW5jcmVtZW50YWxUZW1wbGF0ZXMucmVhZHkpIHtcbiAgICAgICAgaW5jcmVtZW50YWxUZW1wbGF0ZXMudXBncmFkZWQudGhlbihfc3RhcnRDb252ZXJzYXRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfc3RhcnRDb252ZXJzYXRpb25zKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfc3RhcnRDb252ZXJzYXRpb25zKCkge1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBhcmUgZGVmaW5lZCBieSBwdXR0aW5nIHRoZW0gaW4gdGhlIGJvZHkgb3IgaGVhZCB0YWcgb3V0c2lkZSBhIGNvbnZlcnNhdGlvbi10aHJlYWQuXG4gICAgICogVGhleSBhcmUgc2hvd24gaW5zaWRlIGNvbnZlcnNhdGlvbi10aHJlYWRzIGFjY29yZGluZyB0byB0aGUgcmVwbGF5IGFuZCByZXNwb25zZSBydWxlcyBvZlxuICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICovXG4gICAgLy8gY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjb252ZXJzYXRpb24tcmVzcG9uc2UnLCBDb252ZXJzYXRpb25SZXNwb25zZSk7XG5cbiAgICAvL1RPRE8gY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdwb3J0Zm9saW8tc3ByZWFkJywgUG9ydGZvbGlvU3ByZWFkKTtcblxuICAgIC8vIHJlc2V0IHNjcm9sbCBmcm9tIG1haW4gY29udmVyc2F0aW9uIC0gdXBcbiAgICBsZXQgcHJpbWFyeUNvbnZlcnNhdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvbnZlcnNhdGlvbi10aHJlYWQnKTtcbiAgICBmb3IobGV0IGVsPXByaW1hcnlDb252ZXJzYXRpb247IGVsOyBlbCA9IGVsPT09ZG9jdW1lbnQuYm9keT8gbnVsbDplbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IDA7XG4gICAgfVxufVxuXG4vKlxuICBJZGVudGlmeSBibG9ja3Mgd2l0aCBzdGF0ZW1lbnRzXG5cbiAgTmF2aWdhdGlvbiBzdGFydHMgYXQgdGhlIHJvb3QgYmxvY2ssIGFsbCBvdGhlciBibG9ja3MgYXJlIGhpZGRlbiBpbml0aWFsbHkuXG4qL1xuXG4vLyBhY3RpdmF0ZSBibG9jayBwbGFjZXMgaXQgYmVsb3cgdGhlIGxhc3QgYmxvY2sgaW4gY29udmVyc2F0aW9uXG5cbi8vIHBhcmFtIGV2ZW50IG9yIGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0ZVRvSHJlZihldikge1xuICAgIGxldCBlbCA9IGV2LnRhcmdldCB8fCBldjtcbiAgICB3aGlsZShlbCAmJiAhZWwuaHJlZikgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIGlmIChlbCAmJiBlbC5ocmVmKSB7XG4gICAgICAgIGxldCBhY3Rpb24gPSBhcHBseUJsb2NrRnJvbUhhc2goZWwuaHJlZik7XG4gICAgICAgIGlmIChhY3Rpb24gJiYgZXYucHJldmVudERlZmF1bHQpIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuXG4vKlxuYmxvY2tcbmJsb2NrfGFjdGlvbnxoaXN0b3J5PTB8cmVzdD1cbiovXG5mdW5jdGlvbiBkZWNvZGVIYXNoKCkge1xuICAgIHZhciBuYXYgPSAoYXJndW1lbnRzWzBdIHx8IGxvY2F0aW9uLmhhc2gpLnNwbGl0KCd8JyksXG4gICAgICAgIGhhc2hBdCA9IG5hdlswXS5pbmRleE9mKCcjJyk7XG5cbiAgICAvLyBoYXNoIGJhc2VkIFVSTFxuICAgIGlmIChoYXNoQXQ+PTApIHtcbiAgICAgICAgbmF2WzBdID0gbmF2WzBdLnN1YnN0cmluZyhoYXNoQXQrMSk7XG4gICAgfVxuXG4gICAgLy8gcGF0aCBiYXNlZCBVUkxcbiAgICBlbHNlIHtcbiAgICAgICAgbmF2WzBdID0gbmF2WzBdLnNwbGl0KCcvJykucG9wKCk7IC8vIGxlYWYgaXMgYmxvY2sgbmFtZVxuICAgIH1cbiAgICBpZiAobmF2WzBdICYmIGJsb2Nrc1tuYXZbMF1dKSB7XG4gICAgICAgIG5hdi5ibG9jayA9IGJsb2Nrc1tuYXZbMF1dO1xuICAgIH1cbiAgICBpZiAobmF2Lmxlbmd0aD4xKSBuYXYuYWN0aW9uID0gbmF2WzFdO1xuICAgIHJldHVybiBuYXY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUJsb2NrRnJvbUhhc2goaGFzaCxzdGF0ZSkge1xuICAgIHZhciBuYXYgPSBkZWNvZGVIYXNoKGhhc2gpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoPT09Mikge1xuICAgICAgICAvLyBpZiBtb3ZpbmcgYmFjayB0aGVuIHJvbGwgYmFjayB0aGUgY29udmVyc2F0aW9uXG4gICAgfVxuICAgIGlmIChuYXYuYmxvY2spIG5hdi5ibG9jay5hY3RpdmF0ZSgpOyAvL1RPRE8gYm94RWxcblxuICAgIGlmIChuYXYuYWN0aW9uKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBjb252ZXJzYXRpb24uYWN0aXZlQmxvY2suZ2V0QWN0aW9uKG5hdi5hY3Rpb24pO1xuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICBhY3Rpb24uc3RhcnQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5uYXZpZ2F0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZXYpIHtcbiAgICAgICAgLy9UT0RPIHJlYWN0IHRvIFVSTCBjaGFuZ2VzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29uaGFzaGNoYW5nZVxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeV9BUEkjVGhlX3B1c2hTdGF0ZSgpX21ldGhvZFxuICAgICAgICBpZiAoZXYudGFyZ2V0LmFjdGlvbikge1xuICAgICAgICAgICAgZXYudGFyZ2V0LmFjdGlvbi5zdGFydCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXYudGFyZ2V0LmFjdGlvbi5uYXZpZ2F0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgKi9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5SGlzdG9yeVN0YXRlKGhhc2gsc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUucGFzdCkge1xuICAgICAgICAvLyByZWR1Y2UgdGhlIHBhc3RcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBibG9jayBmcm9tIERPTVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUhhc2ggKCkge1xuICAgIHZhciBzY3JvbGxWLCBzY3JvbGxILCBsb2MgPSB3aW5kb3cubG9jYXRpb247XG4gICAgaWYgKFwicHVzaFN0YXRlXCIgaW4gaGlzdG9yeSlcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoXCJcIiwgZG9jdW1lbnQudGl0bGUsIGxvYy5wYXRobmFtZSArIGxvYy5zZWFyY2gpO1xuICAgIGVsc2Uge1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBieSBzdG9yaW5nIHRoZSBwYWdlJ3MgY3VycmVudCBzY3JvbGwgb2Zmc2V0XG4gICAgICAgIHNjcm9sbFYgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgc2Nyb2xsSCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcblxuICAgICAgICBsb2MuaGFzaCA9IFwiXCI7XG5cbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgc2Nyb2xsIG9mZnNldCwgc2hvdWxkIGJlIGZsaWNrZXIgZnJlZVxuICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IHNjcm9sbFY7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA9IHNjcm9sbEg7XG4gICAgfVxufVxuIiwiLyoqIEBqc3ggY3JlYXRlRWxlbWVudCAqL1xuaW1wb3J0IGluZmVybm9UcmVlUmVuZGVyZXIsIHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vZG9tL2luZmVybm9UcmVlUmVuZGVyZXInO1xuXG5leHBvcnQgY2xhc3MgU2hvd2Nhc2VDYXJkIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0b25DbGljayhldmVudCkge1xuXHRcdC8vIGNvbnN0IG9uQ2xpY2sgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdvbi1jbGljaycpO1xuXHRcdC8vIHN3aXRjaChvbkNsaWNrKSB7XG5cdFx0Ly8gXHRjYXNlICdwcmV2aW91cyc6IHJldHVybiB0aGlzLnByZXZpb3VzKCk7XG5cdFx0Ly8gXHRjYXNlICduZXh0JzogcmV0dXJuIHRoaXMubmV4dCgpO1xuXHRcdC8vIH1cblx0XHRsb2NhdGlvbi5ocmVmID0gdGhpcy5wcm9wcy5ocmVmO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH1cblxuXHRvbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG5cblx0cmVuZGVyKHByb3BzKSB7XG4gICAgICAgIC8vIHt0aGlzLnByb3BzLnN1YnRpdGxlICYmIDxoND57dGhpcy5wcm9wcy5zdWJ0aXRsZX08L2g0Pn1cblx0XHQvLyB7dGhpcy5wcm9wcy5hdXRob3IgJiYgPGg2IGNsYXNzPVwiYXV0aG9yXCI+e3RoaXMucHJvcHMuYXV0aG9yfTwvaDY+fVxuICAgICAgICAvLyBhbHJlYWR5IHJlYWQ/IGF1dGhvcj8gY3VycmVudCBtYXJraW5nPyBuZXc/IHJlbGF0ZWQgYXJ0aWNsZXM/IHVwZGF0ZSBidWJibGVzP1xuXG5cdFx0Ly9UT0RPIGNsYXNzTmFtZT1cImFjdGl2ZVwiIGlmIGFjdGl2ZSBwcm9wZXJ0eT9cbiAgICAgICAgcmV0dXJuIChcbiAgICBcdFx0PGZsb3ctY2FyZCB0aXRsZT17cHJvcHMudGl0bGV9IHN0eWxlPXtgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7cHJvcHMuc3JjfSlgfT5cbiAgICBcdFx0PGRpdiBjbGFzc05hbWU9XCJ0aXRsZXNcIiBvbmNsaWNrPXt0aGlzLm9uQ2xpY2t9PlxuICAgIFx0XHRcdHtwcm9wcy50aXRsZSAmJiA8aDI+e3Byb3BzLnRpdGxlfTwvaDI+fVxuICAgIFx0XHRcdHtwcm9wcy5hY3Rpb25UZXh0ICYmIDxoND48YSBocmVmPXtwcm9wcy5ocmVmfT57cHJvcHMuYWN0aW9uVGV4dH08L2E+PC9oND59XG4gICAgXHRcdDwvZGl2PlxuICAgIFx0XHQ8L2Zsb3ctY2FyZD5cbiAgICBcdCk7XG5cdH1cbn1cbiIsIi8qKiBAanN4IGNyZWF0ZUVsZW1lbnQgKi9cbmltcG9ydCB7IGluZmVybm9UcmVlUmVuZGVyZXIsIEFzQ3VzdG9tRWxlbWVudCwgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vZG9tJztcbmltcG9ydCB7IHN0YXRlRnJvbVN0b3JlLCBzdG9yZUZyb21Db25mbHV4QXR0cmlidXRlIH0gZnJvbSAnLi4vZGF0YS9jb25mbHV4JztcbmltcG9ydCB7IFNob3djYXNlQ2FyZCB9IGZyb20gJy4vU2hvd2Nhc2VDYXJkJztcblxuZnVuY3Rpb24gc2hvd2Nhc2VGcm9tU2VlZChlbCkge1xuXHRjb25zdCBpbWcgPSBlbC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcblx0Y29uc3QgYXR0cjEgPSBpbWcgPyBpbWcuc3JjIDpcblx0XHQoKGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZXx8JycpXG5cdFx0XHQucmVwbGFjZSgndXJsKFwidW5kZWZpbmVkXCIpJywnJylcblx0XHRcdC5yZXBsYWNlKCdcIicsJycpXG5cdFx0XHQucmVwbGFjZSgndXJsKCcsJycpLnJlcGxhY2UoJyknLCcnKSk7XG5cdGNvbnN0IHNyYyA9IChlbC5nZXRBdHRyaWJ1dGUoJ2ltZycpIHx8IGF0dHIxKS5yZXBsYWNlKC8gL2csICclMjAnKTtcblx0cmV0dXJuIHtcblx0XHRkYXRlOiBjb2VyY2VEYXRlKGVsLmdldEF0dHJpYnV0ZSgnZGF0ZScpKSxcblx0XHRwcmlvcml0eTogY29lcmNlTnVtYmVyKGVsLmdldEF0dHJpYnV0ZSgncHJpb3JpdHknKSksXG5cdFx0dGl0bGU6IGVsLmdldEF0dHJpYnV0ZSgndGl0bGUnKSxcblx0XHRzdWJ0aXRsZTogZWwuZ2V0QXR0cmlidXRlKCdzdWJ0aXRsZScpLFxuXHRcdGhyZWY6IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuXHRcdGFjdGlvblRleHQ6IGVsLmdldEF0dHJpYnV0ZSgnYWN0aW9uLXRleHQnKSxcblx0XHRhdXRob3JLZXk6IGVsLmdldEF0dHJpYnV0ZSgnYXV0aG9ya2V5JyksXG5cdFx0bG9jYXRpb246IGVsLmdldEF0dHJpYnV0ZSgnbG9jYXRpb24nKSxcblx0XHRzcmMsXG5cdH07XG59XG5cbmZ1bmN0aW9uIGNvZXJjZURhdGUoZGF0ZUxpa2UpIHtcblx0c3dpdGNoKHR5cGVvZiBkYXRlTGlrZSkge1xuXHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRcdHJldHVybiBuZXcgRGF0ZShkYXRlTGlrZSk7XG5cdFx0Y2FzZSAnb2JqZWN0Jzpcblx0XHRcdHJldHVybiBkYXRlTGlrZTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuZnVuY3Rpb24gY29lcmNlTnVtYmVyKG51bWJlckxpa2UpIHtcblx0c3dpdGNoKHR5cGVvZiBudW1iZXJMaWtlKSB7XG5cdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdHJldHVybiBOdW1iZXIobnVtYmVyTGlrZSkgfHwgMDtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIDA7XG5cdH1cbn1cblxuZnVuY3Rpb24gc29ydFNob3djYXNlKGEsIGIpIHtcblx0aWYgKGEucHJpb3JpdHkgJiYgIWIucHJpb3JpdHkpIHJldHVybiAtMTtcblx0aWYgKCFhLnByaW9yaXR5ICYmIGIucHJpb3JpdHkpIHJldHVybiAxO1xuXG5cdGlmIChhLmRhdGUgPiBiLmRhdGUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEuZGF0ZSA8IGIuZGF0ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIGEgbXVzdCBiZSBlcXVhbCB0byBiXG4gICAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBY3Rpb24oc2hvd2Nhc2VzKSB7XG5cdGNvbnN0IHBheWxvYWQgPSBzaG93Y2FzZXMuc29ydChzb3J0U2hvd2Nhc2UpO1xuXHRyZXR1cm4ge1xuXHRcdHR5cGU6ICdzZXQgc2hvd2Nhc2UgbGlzdCcsXG5cdFx0cGF5bG9hZCxcblx0fTtcbn1cblxuLy8gaW5pdCB0aHJvdWdoIHRoZSBET00gKHRoaXMgPSBlbGVtZW50KVxuZnVuY3Rpb24gY29ubmVjdGVkQ2FsbGJhY2soZWwsIHNob3djYXNlKSB7XG5cdGVsLmlubmVySFRNTCA9ICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBAQXNDdXN0b21FbGVtZW50KHtcblx0dGFnOiAnY29udGV4dC1zaG93Y2FzZScsXG5cdHRyZWVSZW5kZXJlcjogaW5mZXJub1RyZWVSZW5kZXJlcixcblx0c3RhdGU6IHN0YXRlRnJvbVN0b3JlLFxuXHRzdGF0ZVNlbGVjdG9yOiAoc3RvcmVTdGF0ZSkgPT4gc3RvcmVTdGF0ZS5zaG93Y2FzZSxcblx0c3RhdGVFeHRyYWN0b3JTZWxlY3RvcjogJ2Zsb3ctY2FyZCxzaG93Y2FzZS1saW5rJyxcblx0c3RhdGVFeHRyYWN0b3I6IChwcm9wcywgY2hpbGRyZW4pID0+IGV4dHJhY3RBY3Rpb24oY2hpbGRyZW4ubWFwKHNob3djYXNlRnJvbVNlZWQpKSxcblx0Y29ubmVjdGVkQ2FsbGJhY2ssXG59KVxuY2xhc3MgQ29udGV4dFNob3djYXNlIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuXHRzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgfVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXG5cdH1cblxuXHRyZW5kZXIocHJvcHMpIHtcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMuc2VsZWN0b3Iuc3RhdGUgfHwgW107XG5cdFx0cmV0dXJuICg8ZGl2Pnsgc3RhdGUubWFwICYmIHN0YXRlLm1hcChlbnRyeSA9PiA8U2hvd2Nhc2VDYXJkIHsuLi5lbnRyeX0gLz4pIH08L2Rpdj4pXG5cdH1cbn1cbiIsImltcG9ydCBDb250ZXh0U2hvd2Nhc2UgZnJvbSAnLi9jb250ZXh0LXNob3djYXNlLmVsZW1lbnQnO1xuLy8gaW1wb3J0IENhcmQgZnJvbSAnLi9mbG93LWNhcmQuZWxlbWVudCc7XG5cbi8vIFRPRE8gY3NzIG9iamVjdC1maXQsIG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCBsb3dTcmMgdXNlIHRvIG1ha2Ugc21hcnQgaW1nIHRhZ3MuXG4iLCIvKiogQGpzeCBjcmVhdGVFbGVtZW50ICovXG5pbXBvcnQgQXNDdXN0b21FbGVtZW50IGZyb20gJy4uL2RvbS9Bc0N1c3RvbUVsZW1lbnQnO1xuaW1wb3J0IGluZmVybm9UcmVlUmVuZGVyZXIsIHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vZG9tL2luZmVybm9UcmVlUmVuZGVyZXInO1xuXG5leHBvcnQgZGVmYXVsdCBAQXNDdXN0b21FbGVtZW50KHtcblx0dGFnOiAnYWx0LXRleHRzJyxcblx0Ly8gdHJlZVJlbmRlcmVyOiBpbmZlcm5vVHJlZVJlbmRlcmVyLFxuXG4gICAgLy8gdHJpZ2dlciB3aGVuIHNjcm9sbGVkIGludG8gdmlld1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKGVsKSB7XG4gICAgICAgIGVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBpZiAoZWwuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIGxldCByZWFsID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQuY2xvbmVOb2RlKCk7XG5cdFx0XHQvLyBhZGQgc29tZXRoaW5nIHdpdGggLmNsb25lTm9kZSgpOyBpZiBhbGwgYXJlIHRlbXBsYXRlc1xuICAgICAgICAgICAgLy9UT0RPIGFkZCBhY3RpdmUtYnViYmxlIHRvIGJ1YmJsZVxuICAgICAgICAgICAgZm9yKGxldCBjaGlsZD1lbC5maXJzdEVsZW1lbnRDaGlsZCwgZGVsYXk9MDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG5cdFx0XHRcdGNoaWxkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdGNvbnN0IHRleHQgPSAoY2hpbGQuY29udGVudCB8fCBjaGlsZCkudGV4dENvbnRlbnRcbiAgICAgICAgICAgICAgICBUd2VlbkxpdGUudG8ocmVhbCwgLjQsIHtkZWxheSx0ZXh0LCBlYXNlOkxpbmVhci5lYXNlTm9uZX0pO1xuICAgICAgICAgICAgICAgIGRlbGF5ICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1RPRE8gd2hlbiBhbmltYXRpb25zIGFyZSBkb25lIHJlbW92ZSBhY3RpdmUtYnViYmxlIGZyb20gYnViYmxlXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChyZWFsKTtcbiAgICAgICAgfVxuICAgIH1cblxufSlcbmNsYXNzIEFsdFRleHRzIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuXHRzY3JvbGxlZEludG9WaWV3Q2FsbGJhY2soKSB7XG5cdFx0Ly9UT0RPIHJlZG8gdGhlIGNvbm5lY3RlZENhbGxiYWNrXG5cdH1cbn1cblxuLypcblxuJChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdCA9IFtcIkNPT0xcIiwgXCJLTk9XTEVER0VcIiwgXCJEWU5BTUlDXCIsIFwiRVhQRVJUU1wiLCBcIk1BUktFVElOR1wiXSxcbiAgICAgICAgJGgxID0gJChcIi53ZWFyZV9fcm90YXRpdmFcIiksXG4gICAgICAgICRzcCA9ICRoMS5maW5kKFwiLndlYXJlX19yb3RhdGl2YS0taGlnaGxpZ2h0XCIpLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgd2lkdGhzID0gW107XG5cbiAgICAkLmVhY2godCwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgdmFyIGVsID0gJCgnPHNwYW4gLz4nLCB7XG4gICAgICAgICAgICB0ZXh0OiB2XG4gICAgICAgIH0pLmFwcGVuZFRvKCRoMSk7XG4gICAgICAgIHdpZHRocy5wdXNoKGVsLndpZHRoKCkpO1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgJHNwLmNzcyh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICB9KTtcblxuICAgIChmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICBpID0gKytpICUgdC5sZW5ndGg7XG4gICAgICAgICRzcC50ZXh0KHRbaV0pLmFuaW1hdGUoe3dpZHRoOiB3aWR0aHNbaV19LCA1MDAsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgIFR3ZWVuTGl0ZS50bygkc3AudGV4dCh0W2ldKSwgMC41LCB7d2lkdGg6d2lkdGhzW2ldLCBvbkNvbXBsZXRlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFR3ZWVuTGl0ZS50bygkc3AudGV4dCh0W2ldKSwgMC41LCB7YXV0b0FscGhhOjF9KTtcbiAgICAgICAgICAgIFR3ZWVuTGl0ZS50bygkc3AudGV4dCh0W2ldKSwgMC41LCB7YXV0b0FscGhhOjAsIGRlbGF5OjIsIG9uQ29tcGxldGU6bG9vcH0pO1xuLy8gICAgICAgICAgICB9fSk7XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG59KTtcblxuXG4qL1xuIiwiLyoqIEBqc3ggY3JlYXRlRWxlbWVudCAqL1xuaW1wb3J0IEFzQ3VzdG9tRWxlbWVudCBmcm9tICcuLi9kb20vQXNDdXN0b21FbGVtZW50JztcbmltcG9ydCBpbmZlcm5vVHJlZVJlbmRlcmVyLCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL2RvbS9pbmZlcm5vVHJlZVJlbmRlcmVyJztcblxuY29uc3QgdGltZXJTeW1ib2wgPSBTeW1ib2woKTtcblxuQEFzQ3VzdG9tRWxlbWVudCh7XG5cdHRhZzogJ3RpbWUtY291bnRkb3duJywgXG4gICAgdHJlZVJlbmRlcmVyOiBpbmZlcm5vVHJlZVJlbmRlcmVyLFxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrIChlbCkge1xuICAgICAgICBpZiAoZWxbdGltZXJTeW1ib2xdKSBjbGVhclRpbWVvdXQoZWxbdGltZXJTeW1ib2xdKTtcbiAgICB9LFxufSlcbmV4cG9ydCBjbGFzcyBUaW1lQ291bnRkb3duIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vVE9ETyBmaXggRGF0ZSBjb2VyY2UgZnJvbSBzdHJpbmdcbiAgICAgICAgICAgIHRpbWU6IHsgdHlwZTogRGF0ZSwgYXR0cmlidXRlOiB0cnVlLCBkZWZhdWx0OiBudWxsfSxcbiAgICAgICAgICAgIHNob3dTZWNvbmRzOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBzdGF0ZTpcbiAgICAvLyBkYXlzOiBOdW1iZXIsXG4gICAgLy8gaG91cnM6IE51bWJlcixcbiAgICAvLyBtaW51dGVzOiBOdW1iZXIsXG4gICAgLy8gc2Vjb25kczogTnVtYmVyLCAgICBcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgZGF5czowLCBob3VyczowLCBtaW51dGVzOjAsIHNlY29uZHM6MCB9O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlVGltZSgpLCAzMCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVGltZSgpIHtcbiAgICAgICAgbGV0IHNlY29uZHNfbGVmdCA9ICgobmV3IERhdGUodGhpcy5wcm9wcy50aW1lKSkuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSkgLyAxMDAwO1xuICAgICAgICBsZXQgZGF5cyA9IDAsIGhvdXJzID0gMCwgbWludXRlcyA9IDAsIHNlY29uZHMgPSAwO1xuXG4gICAgICAgIC8vIGRvIHNvbWUgdGltZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgZGF5cyA9IHBhcnNlSW50KHNlY29uZHNfbGVmdCAvIDg2NDAwKTtcbiAgICAgICAgc2Vjb25kc19sZWZ0ID0gc2Vjb25kc19sZWZ0ICUgODY0MDA7XG5cbiAgICAgICAgaG91cnMgPSBwYXJzZUludChzZWNvbmRzX2xlZnQgLyAzNjAwKTtcbiAgICAgICAgc2Vjb25kc19sZWZ0ID0gc2Vjb25kc19sZWZ0ICUgMzYwMDtcblxuICAgICAgICBtaW51dGVzID0gcGFyc2VJbnQoc2Vjb25kc19sZWZ0IC8gNjApO1xuICAgICAgICBzZWNvbmRzID0gcGFyc2VJbnQoc2Vjb25kc19sZWZ0ICUgNjApO1xuICAgICAgIGlmIChkYXlzID4gMCB8fCBob3VycyA+IDAgfHwgbWludXRlcyA+IDAgfHwgc2Vjb25kcyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1zX2xlZnQgPSAoc2Vjb25kc19sZWZ0ICUgNjApICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5zaG93U2Vjb25kcyA/IChtc19sZWZ0ICUgMTAwMCkgOiBtc19sZWZ0O1xuICAgICAgICAgICAgdGhpc1t0aW1lclN5bWJvbF0gPSBzZXRUaW1lb3V0KHRoaXMudXBkYXRlVGltZS5iaW5kKHRoaXMpLCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIGhvdXJzID0gMDtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSAwO1xuICAgICAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICAgICAgICB0aGlzW3RpbWVyU3ltYm9sXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgfSk7XG4gICAgfVxuXG5cbiAgICByZW5kZXIocHJvcHMsIHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgfSkge1xuICAgICAgICByZXR1cm4gKDxzcGFuPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpbWUtY291bnRkb3duX19kaWdpdCB0aW1lLWNvdW50ZG93bl9fZGF5c1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aW1lIGRheXNcIj57ZGF5cyB8fCAwfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aW1lLWNvdW50ZG93bl9fbGFiZWxcIj5kYXlzPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aW1lLWNvdW50ZG93bl9fZGlnaXQgdGltZS1jb3VudGRvd25fX2hvdXJzXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpbWUgaG91cnNcIj57aG91cnMgfHwgMH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGltZS1jb3VudGRvd25fX2xhYmVsXCI+aG91cnM8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpbWUtY291bnRkb3duX19kaWdpdCB0aW1lLWNvdW50ZG93bl9fbWludXRlc1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aW1lIG1pbnV0ZXNcIj57bWludXRlcyB8fCAwfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aW1lLWNvdW50ZG93bl9fbGFiZWxcIj5taW5zPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHt0aGlzLnNob3dTZWNvbmRzICYmIDxkaXYgY2xhc3M9XCJ0aW1lLWNvdW50ZG93bl9fZGlnaXQgdGltZS1jb3VudGRvd25fX3NlY29uZHNcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGltZSBzZWNvbmRzXCI+e3NlY29uZHMgfHwgMH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGltZS1jb3VudGRvd25fX2xhYmVsXCI+c2Vjb25kczwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+fVxuICAgICAgICA8L3NwYW4+KTtcbiAgICB9XG59XG4iLCJleHBvcnQgeyBob29rcywgc2V0SG9va0NhbGxiYWNrIH07XG5cbnZhciBob29rQ2FsbGJhY2s7XG5cbmZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgIHZhciBrO1xuICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgLy8gZXZlbiBpZiBpdHMgbm90IG93biBwcm9wZXJ0eSBJJ2Qgc3RpbGwgY2FsbCBpdCBub24tZW1wdHlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbn1cbiIsImltcG9ydCBoYXNPd25Qcm9wIGZyb20gJy4vaGFzLW93bi1wcm9wJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVMb2NhbE9yVVRDIH0gZnJvbSAnLi9mcm9tLWFueXRoaW5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG59XG4iLCJmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxuICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgIH1cbiAgICByZXR1cm4gbS5fcGY7XG59XG4iLCJ2YXIgc29tZTtcbmlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbn0gZWxzZSB7XG4gICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgc29tZSBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgZXh0ZW5kIGZyb20gJy4uL3V0aWxzL2V4dGVuZCc7XG5pbXBvcnQgeyBjcmVhdGVVVEMgfSBmcm9tICcuL3V0Yyc7XG5pbXBvcnQgZ2V0UGFyc2luZ0ZsYWdzIGZyb20gJy4uL2NyZWF0ZS9wYXJzaW5nLWZsYWdzJztcbmltcG9ydCBzb21lIGZyb20gJy4uL3V0aWxzL3NvbWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG4iLCJpbXBvcnQgeyBob29rcyB9IGZyb20gJy4uL3V0aWxzL2hvb2tzJztcbmltcG9ydCBoYXNPd25Qcm9wIGZyb20gJy4uL3V0aWxzL2hhcy1vd24tcHJvcCc7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSAnLi4vdXRpbHMvaXMtdW5kZWZpbmVkJztcbmltcG9ydCBnZXRQYXJzaW5nRmxhZ3MgZnJvbSAnLi4vY3JlYXRlL3BhcnNpbmctZmxhZ3MnO1xuXG4vLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4vLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn1cblxudmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbmV4cG9ydCBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAvLyBvYmplY3RzLlxuICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgYWJzRmxvb3IgZnJvbSAnLi9hYnMtZmxvb3InO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iLCJpbXBvcnQgdG9JbnQgZnJvbSAnLi90by1pbnQnO1xuXG4vLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xufVxuIiwiaW1wb3J0IGV4dGVuZCBmcm9tICcuL2V4dGVuZCc7XG5pbXBvcnQgeyBob29rcyB9IGZyb20gJy4vaG9va3MnO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4vaXMtdW5kZWZpbmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCBmbik7XG59XG5cbnZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgfVxuICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICB9XG59XG5cbmhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi4vdXRpbHMvaXMtZnVuY3Rpb24nO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuLi91dGlscy9leHRlbmQnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4uL3V0aWxzL2lzLW9iamVjdCc7XG5pbXBvcnQgaGFzT3duUHJvcCBmcm9tICcuLi91dGlscy9oYXMtb3duLXByb3AnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICB2YXIgcHJvcCwgaTtcbiAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgaGFzT3duUHJvcCBmcm9tICcuL2hhcy1vd24tcHJvcCc7XG5cbnZhciBrZXlzO1xuXG5pZiAoT2JqZWN0LmtleXMpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXM7XG59IGVsc2Uge1xuICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsga2V5cyBhcyBkZWZhdWx0IH07XG4iLCJleHBvcnQgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICBzYW1lRWxzZSA6ICdMJ1xufTtcblxuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi4vdXRpbHMvaXMtZnVuY3Rpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xufVxuIiwiZXhwb3J0IHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgIExUICAgOiAnaDptbSBBJyxcbiAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xufVxuIiwiZXhwb3J0IHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG59XG4iLCJleHBvcnQgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbmV4cG9ydCB2YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xufVxuXG4iLCJleHBvcnQgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgaCAgOiAnYW4gaG91cicsXG4gICAgaGggOiAnJWQgaG91cnMnLFxuICAgIGQgIDogJ2EgZGF5JyxcbiAgICBkZCA6ICclZCBkYXlzJyxcbiAgICBNICA6ICdhIG1vbnRoJyxcbiAgICBNTSA6ICclZCBtb250aHMnLFxuICAgIHkgIDogJ2EgeWVhcicsXG4gICAgeXkgOiAnJWQgeWVhcnMnXG59O1xuXG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuLi91dGlscy9pcy1mdW5jdGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbn1cbiIsImltcG9ydCBoYXNPd25Qcm9wIGZyb20gJy4uL3V0aWxzL2hhcy1vd24tcHJvcCc7XG5cbnZhciBhbGlhc2VzID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICBwcm9wO1xuXG4gICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG59XG5cbiIsInZhciBwcmlvcml0aWVzID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgdmFyIHVuaXRzID0gW107XG4gICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgIH1cbiAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pdHM7XG59XG4iLCJpbXBvcnQgeyBub3JtYWxpemVVbml0cywgbm9ybWFsaXplT2JqZWN0VW5pdHMgfSBmcm9tICcuLi91bml0cy9hbGlhc2VzJztcbmltcG9ydCB7IGdldFByaW9yaXRpemVkVW5pdHMgfSBmcm9tICcuLi91bml0cy9wcmlvcml0aWVzJztcbmltcG9ydCB7IGhvb2tzIH0gZnJvbSAnLi4vdXRpbHMvaG9va3MnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi4vdXRpbHMvaXMtZnVuY3Rpb24nO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldCh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgIGlmIChtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nU2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xufVxuIiwiaW1wb3J0IHplcm9GaWxsIGZyb20gJy4uL3V0aWxzL3plcm8tZmlsbCc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuLi91dGlscy9pcy1mdW5jdGlvbic7XG5cbmV4cG9ydCB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbnZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG52YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbmV4cG9ydCB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuLy8gdG9rZW46ICAgICdNJ1xuLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuLy8gb3JkaW5hbDogICdNbydcbi8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuZXhwb3J0IGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICB9XG4gICAgaWYgKHBhZGRlZCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xufVxuXG5mdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5cbi8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgdmFyIGkgPSA1O1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgIH1cblxuICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpIC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cbiIsImV4cG9ydCB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuZXhwb3J0IHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbmV4cG9ydCB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG5leHBvcnQgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbmV4cG9ydCB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5leHBvcnQgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuZXhwb3J0IHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG5leHBvcnQgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG5leHBvcnQgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuZXhwb3J0IHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG5leHBvcnQgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG5leHBvcnQgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuZXhwb3J0IHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuZXhwb3J0IHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5leHBvcnQgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuZXhwb3J0IHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbi8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuZXhwb3J0IHZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuXG5pbXBvcnQgaGFzT3duUHJvcCBmcm9tICcuLi91dGlscy9oYXMtb3duLXByb3AnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi4vdXRpbHMvaXMtZnVuY3Rpb24nO1xuXG52YXIgcmVnZXhlcyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cbiIsImltcG9ydCBoYXNPd25Qcm9wIGZyb20gJy4uL3V0aWxzL2hhcy1vd24tcHJvcCc7XG5pbXBvcnQgaXNOdW1iZXIgZnJvbSAnLi4vdXRpbHMvaXMtbnVtYmVyJztcbmltcG9ydCB0b0ludCBmcm9tICcuLi91dGlscy90by1pbnQnO1xuXG52YXIgdG9rZW5zID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgIH1cbn1cbiIsImV4cG9ydCB2YXIgWUVBUiA9IDA7XG5leHBvcnQgdmFyIE1PTlRIID0gMTtcbmV4cG9ydCB2YXIgREFURSA9IDI7XG5leHBvcnQgdmFyIEhPVVIgPSAzO1xuZXhwb3J0IHZhciBNSU5VVEUgPSA0O1xuZXhwb3J0IHZhciBTRUNPTkQgPSA1O1xuZXhwb3J0IHZhciBNSUxMSVNFQ09ORCA9IDY7XG5leHBvcnQgdmFyIFdFRUsgPSA3O1xuZXhwb3J0IHZhciBXRUVLREFZID0gODtcbiIsInZhciBpbmRleE9mO1xuXG5pZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG59IGVsc2Uge1xuICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBpbmRleE9mIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IGdldCB9IGZyb20gJy4uL21vbWVudC9nZXQtc2V0JztcbmltcG9ydCBoYXNPd25Qcm9wIGZyb20gJy4uL3V0aWxzL2hhcy1vd24tcHJvcCc7XG5pbXBvcnQgeyBhZGRGb3JtYXRUb2tlbiB9IGZyb20gJy4uL2Zvcm1hdC9mb3JtYXQnO1xuaW1wb3J0IHsgYWRkVW5pdEFsaWFzIH0gZnJvbSAnLi9hbGlhc2VzJztcbmltcG9ydCB7IGFkZFVuaXRQcmlvcml0eSB9IGZyb20gJy4vcHJpb3JpdGllcyc7XG5pbXBvcnQgeyBhZGRSZWdleFRva2VuLCBtYXRjaDF0bzIsIG1hdGNoMiwgbWF0Y2hXb3JkLCByZWdleEVzY2FwZSB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFBhcnNlVG9rZW4gfSBmcm9tICcuLi9wYXJzZS90b2tlbic7XG5pbXBvcnQgeyBob29rcyB9IGZyb20gJy4uL3V0aWxzL2hvb2tzJztcbmltcG9ydCB7IE1PTlRIIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuLi91dGlscy9pcy1hcnJheSc7XG5pbXBvcnQgaXNOdW1iZXIgZnJvbSAnLi4vdXRpbHMvaXMtbnVtYmVyJztcbmltcG9ydCBpbmRleE9mIGZyb20gJy4uL3V0aWxzL2luZGV4LW9mJztcbmltcG9ydCB7IGNyZWF0ZVVUQyB9IGZyb20gJy4uL2NyZWF0ZS91dGMnO1xuaW1wb3J0IGdldFBhcnNpbmdGbGFncyBmcm9tICcuLi9jcmVhdGUvcGFyc2luZy1mbGFncyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbn0pO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICB9XG59KTtcblxuLy8gTE9DQUxFU1xuXG52YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbmV4cG9ydCB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgIHJldHVybiBtb207XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xufVxuXG52YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5leHBvcnQgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5leHBvcnQgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSwgbW9tO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuIiwiaW1wb3J0IHsgbWFrZUdldFNldCB9IGZyb20gJy4uL21vbWVudC9nZXQtc2V0JztcbmltcG9ydCB7IGFkZEZvcm1hdFRva2VuIH0gZnJvbSAnLi4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBhZGRVbml0QWxpYXMgfSBmcm9tICcuL2FsaWFzZXMnO1xuaW1wb3J0IHsgYWRkVW5pdFByaW9yaXR5IH0gZnJvbSAnLi9wcmlvcml0aWVzJztcbmltcG9ydCB7IGFkZFJlZ2V4VG9rZW4sIG1hdGNoMXRvMiwgbWF0Y2gxdG80LCBtYXRjaDF0bzYsIG1hdGNoMiwgbWF0Y2g0LCBtYXRjaDYsIG1hdGNoU2lnbmVkIH0gZnJvbSAnLi4vcGFyc2UvcmVnZXgnO1xuaW1wb3J0IHsgYWRkUGFyc2VUb2tlbiB9IGZyb20gJy4uL3BhcnNlL3Rva2VuJztcbmltcG9ydCB7IGhvb2tzIH0gZnJvbSAnLi4vdXRpbHMvaG9va3MnO1xuaW1wb3J0IHsgWUVBUiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0b0ludCBmcm9tICcuLi91dGlscy90by1pbnQnO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbmFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xufVxuXG4vLyBIT09LU1xuXG5ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG59O1xuXG4vLyBNT01FTlRTXG5cbmV4cG9ydCB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuXG4gICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuIiwiaW1wb3J0IHsgZGF5c0luWWVhciB9IGZyb20gJy4veWVhcic7XG5pbXBvcnQgeyBjcmVhdGVMb2NhbCB9IGZyb20gJy4uL2NyZWF0ZS9sb2NhbCc7XG5pbXBvcnQgeyBjcmVhdGVVVENEYXRlIH0gZnJvbSAnLi4vY3JlYXRlL2RhdGUtZnJvbS1hcnJheSc7XG5cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG5leHBvcnQgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXJcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG4iLCJpbXBvcnQgeyBhZGRGb3JtYXRUb2tlbiB9IGZyb20gJy4uL2Zvcm1hdC9mb3JtYXQnO1xuaW1wb3J0IHsgYWRkVW5pdEFsaWFzIH0gZnJvbSAnLi9hbGlhc2VzJztcbmltcG9ydCB7IGFkZFVuaXRQcmlvcml0eSB9IGZyb20gJy4vcHJpb3JpdGllcyc7XG5pbXBvcnQgeyBhZGRSZWdleFRva2VuLCBtYXRjaDF0bzIsIG1hdGNoMiB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFdlZWtQYXJzZVRva2VuIH0gZnJvbSAnLi4vcGFyc2UvdG9rZW4nO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhbCB9IGZyb20gJy4uL2NyZWF0ZS9sb2NhbCc7XG5pbXBvcnQgeyB3ZWVrT2ZZZWFyIH0gZnJvbSAnLi93ZWVrLWNhbGVuZGFyLXV0aWxzJztcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbmFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTE9DQUxFU1xuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG59XG5cbmV4cG9ydCB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xufVxuXG4vLyBNT01FTlRTXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cbiIsImltcG9ydCB7IGFkZEZvcm1hdFRva2VuIH0gZnJvbSAnLi4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBhZGRVbml0QWxpYXMgfSBmcm9tICcuL2FsaWFzZXMnO1xuaW1wb3J0IHsgYWRkVW5pdFByaW9yaXR5IH0gZnJvbSAnLi9wcmlvcml0aWVzJztcbmltcG9ydCB7IGFkZFJlZ2V4VG9rZW4sIG1hdGNoMXRvMiwgbWF0Y2hXb3JkLCByZWdleEVzY2FwZSB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFdlZWtQYXJzZVRva2VuIH0gZnJvbSAnLi4vcGFyc2UvdG9rZW4nO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuLi91dGlscy9pcy1hcnJheSc7XG5pbXBvcnQgaW5kZXhPZiBmcm9tICcuLi91dGlscy9pbmRleC1vZic7XG5pbXBvcnQgaGFzT3duUHJvcCBmcm9tICcuLi91dGlscy9oYXMtb3duLXByb3AnO1xuaW1wb3J0IHsgY3JlYXRlVVRDIH0gZnJvbSAnLi4vY3JlYXRlL3V0Yyc7XG5pbXBvcnQgZ2V0UGFyc2luZ0ZsYWdzIGZyb20gJy4uL2NyZWF0ZS9wYXJzaW5nLWZsYWdzJztcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbn1cblxuLy8gTE9DQUxFU1xuXG5leHBvcnQgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRheTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG4iLCJpbXBvcnQgeyBtYWtlR2V0U2V0IH0gZnJvbSAnLi4vbW9tZW50L2dldC1zZXQnO1xuaW1wb3J0IHsgYWRkRm9ybWF0VG9rZW4gfSBmcm9tICcuLi9mb3JtYXQvZm9ybWF0JztcbmltcG9ydCB7IGFkZFVuaXRBbGlhcyB9IGZyb20gJy4vYWxpYXNlcyc7XG5pbXBvcnQgeyBhZGRVbml0UHJpb3JpdHkgfSBmcm9tICcuL3ByaW9yaXRpZXMnO1xuaW1wb3J0IHsgYWRkUmVnZXhUb2tlbiwgbWF0Y2gxdG8yLCBtYXRjaDIsIG1hdGNoM3RvNCwgbWF0Y2g1dG82IH0gZnJvbSAnLi4vcGFyc2UvcmVnZXgnO1xuaW1wb3J0IHsgYWRkUGFyc2VUb2tlbiB9IGZyb20gJy4uL3BhcnNlL3Rva2VuJztcbmltcG9ydCB7IEhPVVIsIE1JTlVURSwgU0VDT05EIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5pbXBvcnQgemVyb0ZpbGwgZnJvbSAnLi4vdXRpbHMvemVyby1maWxsJztcbmltcG9ydCBnZXRQYXJzaW5nRmxhZ3MgZnJvbSAnLi4vY3JlYXRlL3BhcnNpbmctZmxhZ3MnO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xufVxuXG5mdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG59XG5cbmFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5mdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgIH0pO1xufVxuXG5tZXJpZGllbSgnYScsIHRydWUpO1xubWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuLy8gUEFSU0lOR1xuXG5mdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbn1cblxuYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG5hZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG5hZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG5hZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbmFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG59KTtcbmFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xufSk7XG5cbi8vIExPQ0FMRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG5leHBvcnQgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgIH1cbn1cblxuXG4vLyBNT01FTlRTXG5cbi8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4vLyB0aGlzIHJ1bGUuXG5leHBvcnQgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuIiwiaW1wb3J0IHsgZGVmYXVsdENhbGVuZGFyIH0gZnJvbSAnLi9jYWxlbmRhcic7XG5pbXBvcnQgeyBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgfSBmcm9tICcuL2Zvcm1hdHMnO1xuaW1wb3J0IHsgZGVmYXVsdEludmFsaWREYXRlIH0gZnJvbSAnLi9pbnZhbGlkJztcbmltcG9ydCB7IGRlZmF1bHRPcmRpbmFsLCBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSB9IGZyb20gJy4vb3JkaW5hbCc7XG5pbXBvcnQgeyBkZWZhdWx0UmVsYXRpdmVUaW1lIH0gZnJvbSAnLi9yZWxhdGl2ZSc7XG5cbi8vIG1vbnRoc1xuaW1wb3J0IHtcbiAgICBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcbn0gZnJvbSAnLi4vdW5pdHMvbW9udGgnO1xuXG4vLyB3ZWVrXG5pbXBvcnQgeyBkZWZhdWx0TG9jYWxlV2VlayB9IGZyb20gJy4uL3VuaXRzL3dlZWsnO1xuXG4vLyB3ZWVrZGF5c1xuaW1wb3J0IHtcbiAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxufSBmcm9tICcuLi91bml0cy9kYXktb2Ytd2Vlayc7XG5cbi8vIG1lcmlkaWVtXG5pbXBvcnQgeyBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSB9IGZyb20gJy4uL3VuaXRzL2hvdXInO1xuXG5leHBvcnQgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXG4gICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXG5cbiAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcbiAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG59O1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi4vdXRpbHMvaXMtYXJyYXknO1xuaW1wb3J0IGhhc093blByb3AgZnJvbSAnLi4vdXRpbHMvaGFzLW93bi1wcm9wJztcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tICcuLi91dGlscy9pcy11bmRlZmluZWQnO1xuaW1wb3J0IGNvbXBhcmVBcnJheXMgZnJvbSAnLi4vdXRpbHMvY29tcGFyZS1hcnJheXMnO1xuaW1wb3J0IHsgZGVwcmVjYXRlU2ltcGxlIH0gZnJvbSAnLi4vdXRpbHMvZGVwcmVjYXRlJztcbmltcG9ydCB7IG1lcmdlQ29uZmlncyB9IGZyb20gJy4vc2V0JztcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4vY29uc3RydWN0b3InO1xuaW1wb3J0IGtleXMgZnJvbSAnLi4vdXRpbHMva2V5cyc7XG5cbmltcG9ydCB7IGJhc2VDb25maWcgfSBmcm9tICcuL2Jhc2UtY29uZmlnJztcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fTtcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xudmFyIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbn1cblxuLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIHJldHVybnMgbG9jYWxlIGRhdGFcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbGUgKGtleSkge1xuICAgIHZhciBsb2NhbGU7XG5cbiAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG59XG4iLCJpbXBvcnQgeyBkYXlzSW5Nb250aCB9IGZyb20gJy4uL3VuaXRzL21vbnRoJztcbmltcG9ydCB7IFlFQVIsIE1PTlRILCBEQVRFLCBIT1VSLCBNSU5VVEUsIFNFQ09ORCwgTUlMTElTRUNPTkQsIFdFRUssIFdFRUtEQVkgfSBmcm9tICcuLi91bml0cy9jb25zdGFudHMnO1xuaW1wb3J0IGdldFBhcnNpbmdGbGFncyBmcm9tICcuLi9jcmVhdGUvcGFyc2luZy1mbGFncyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbiIsImltcG9ydCB7IGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQgfSBmcm9tICcuL2Zyb20tc3RyaW5nLWFuZC1mb3JtYXQnO1xuaW1wb3J0IHsgaG9va3MgfSBmcm9tICcuLi91dGlscy9ob29rcyc7XG5pbXBvcnQgeyBkZXByZWNhdGUgfSBmcm9tICcuLi91dGlscy9kZXByZWNhdGUnO1xuaW1wb3J0IGdldFBhcnNpbmdGbGFncyBmcm9tICcuL3BhcnNpbmctZmxhZ3MnO1xuXG4vLyBpc28gODYwMSByZWdleFxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG52YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxudmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbnZhciBpc29EYXRlcyA9IFtcbiAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuXTtcblxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xudmFyIGlzb1RpbWVzID0gW1xuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEgnLCAvXFxkXFxkL11cbl07XG5cbnZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgdmFyIGksIGwsXG4gICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xudmFyIGJhc2ljUmZjUmVnZXggPSAvXigoPzpNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGQ/XFxkXFxzKD86SmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKD86XFxkXFxkKT9cXGRcXGRcXHMpKFxcZFxcZDpcXGRcXGQpKFxcOlxcZFxcZCk/KFxccyg/OlVUfEdNVHxbRUNNUF1bU0RdVHxbQS1JSy1aYS1pay16XXxbKy1dXFxkezR9KSkkLztcblxuLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgIHZhciBzdHJpbmcsIG1hdGNoLCBkYXlGb3JtYXQsXG4gICAgICAgIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuICAgIHZhciB0aW1lem9uZXMgPSB7XG4gICAgICAgICcgR01UJzogJyArMDAwMCcsXG4gICAgICAgICcgRURUJzogJyAtMDQwMCcsXG4gICAgICAgICcgRVNUJzogJyAtMDUwMCcsXG4gICAgICAgICcgQ0RUJzogJyAtMDUwMCcsXG4gICAgICAgICcgQ1NUJzogJyAtMDYwMCcsXG4gICAgICAgICcgTURUJzogJyAtMDYwMCcsXG4gICAgICAgICcgTVNUJzogJyAtMDcwMCcsXG4gICAgICAgICcgUERUJzogJyAtMDcwMCcsXG4gICAgICAgICcgUFNUJzogJyAtMDgwMCdcbiAgICB9O1xuICAgIHZhciBtaWxpdGFyeSA9ICdZWFdWVVRTUlFQT05aQUJDREVGR0hJS0xNJztcbiAgICB2YXIgdGltZXpvbmUsIHRpbWV6b25lSW5kZXg7XG5cbiAgICBzdHJpbmcgPSBjb25maWcuX2lcbiAgICAgICAgLnJlcGxhY2UoL1xcKFteXFwpXSpcXCl8W1xcblxcdF0vZywgJyAnKSAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZVxuICAgICAgICAucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykgLy8gUmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAucmVwbGFjZSgvXlxcc3xcXHMkL2csICcnKTsgLy8gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICAgIG1hdGNoID0gYmFzaWNSZmNSZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZGF5Rm9ybWF0ID0gbWF0Y2hbMV0gPyAnZGRkJyArICgobWF0Y2hbMV0ubGVuZ3RoID09PSA1KSA/ICcsICcgOiAnICcpIDogJyc7XG4gICAgICAgIGRhdGVGb3JtYXQgPSAnRCBNTU0gJyArICgobWF0Y2hbMl0ubGVuZ3RoID4gMTApID8gJ1lZWVkgJyA6ICdZWSAnKTtcbiAgICAgICAgdGltZUZvcm1hdCA9ICdISDptbScgKyAobWF0Y2hbNF0gPyAnOnNzJyA6ICcnKTtcblxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgIGlmIChtYXRjaFsxXSkgeyAvLyBkYXkgb2Ygd2VlayBnaXZlblxuICAgICAgICAgICAgdmFyIG1vbWVudERhdGUgPSBuZXcgRGF0ZShtYXRjaFsyXSk7XG4gICAgICAgICAgICB2YXIgbW9tZW50RGF5ID0gWydTdW4nLCdNb24nLCdUdWUnLCdXZWQnLCdUaHUnLCdGcmknLCdTYXQnXVttb21lbnREYXRlLmdldERheSgpXTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdLnN1YnN0cigwLDMpICE9PSBtb21lbnREYXkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobWF0Y2hbNV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6IC8vIG1pbGl0YXJ5XG4gICAgICAgICAgICAgICAgaWYgKHRpbWV6b25lSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmUgPSAnICswMDAwJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aW1lem9uZUluZGV4ID0gbWlsaXRhcnkuaW5kZXhPZihtYXRjaFs1XVsxXS50b1VwcGVyQ2FzZSgpKSAtIDEyO1xuICAgICAgICAgICAgICAgICAgICB0aW1lem9uZSA9ICgodGltZXpvbmVJbmRleCA8IDApID8gJyAtJyA6ICcgKycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgoJycgKyB0aW1lem9uZUluZGV4KS5yZXBsYWNlKC9eLT8vLCAnMCcpKS5tYXRjaCgvLi4kLylbMF0gKyAnMDAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDogLy8gWm9uZVxuICAgICAgICAgICAgICAgIHRpbWV6b25lID0gdGltZXpvbmVzW21hdGNoWzVdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIFVUIG9yICsvLTk5OTlcbiAgICAgICAgICAgICAgICB0aW1lem9uZSA9IHRpbWV6b25lc1snIEdNVCddO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoWzVdID0gdGltZXpvbmU7XG4gICAgICAgIGNvbmZpZy5faSA9IG1hdGNoLnNwbGljZSgxKS5qb2luKCcnKTtcbiAgICAgICAgdHpGb3JtYXQgPSAnIFpaJztcbiAgICAgICAgY29uZmlnLl9mID0gZGF5Rm9ybWF0ICsgZGF0ZUZvcm1hdCArIHRpbWVGb3JtYXQgKyB0ekZvcm1hdDtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5leHBvcnQgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xufVxuXG5ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgIH1cbik7XG4iLCIvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG4iLCJpbXBvcnQgeyBob29rcyB9IGZyb20gJy4uL3V0aWxzL2hvb2tzJztcbmltcG9ydCB7IGNyZWF0ZURhdGUsIGNyZWF0ZVVUQ0RhdGUgfSBmcm9tICcuL2RhdGUtZnJvbS1hcnJheSc7XG5pbXBvcnQgeyBkYXlzSW5ZZWFyIH0gZnJvbSAnLi4vdW5pdHMveWVhcic7XG5pbXBvcnQgeyB3ZWVrT2ZZZWFyLCB3ZWVrc0luWWVhciwgZGF5T2ZZZWFyRnJvbVdlZWtzIH0gZnJvbSAnLi4vdW5pdHMvd2Vlay1jYWxlbmRhci11dGlscyc7XG5pbXBvcnQgeyBZRUFSLCBNT05USCwgREFURSwgSE9VUiwgTUlOVVRFLCBTRUNPTkQsIE1JTExJU0VDT05EIH0gZnJvbSAnLi4vdW5pdHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2FsIH0gZnJvbSAnLi9sb2NhbCc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vdXRpbHMvZGVmYXVsdHMnO1xuaW1wb3J0IGdldFBhcnNpbmdGbGFncyBmcm9tICcuL3BhcnNpbmctZmxhZ3MnO1xuXG5mdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XG4gICAgfVxuICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbn1cblxuLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4vLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4vLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgIH1cblxuICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgfVxuXG4gICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgdyA9IGNvbmZpZy5fdztcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgIGRvdyA9IDE7XG4gICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY29uZmlnRnJvbUlTTywgY29uZmlnRnJvbVJGQzI4MjIgfSBmcm9tICcuL2Zyb20tc3RyaW5nJztcbmltcG9ydCB7IGNvbmZpZ0Zyb21BcnJheSB9IGZyb20gJy4vZnJvbS1hcnJheSc7XG5pbXBvcnQgeyBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gfSAgIGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFRpbWVUb0FycmF5RnJvbVRva2VuIH0gZnJvbSAnLi4vcGFyc2UvdG9rZW4nO1xuaW1wb3J0IHsgZXhwYW5kRm9ybWF0LCBmb3JtYXRUb2tlbkZ1bmN0aW9ucywgZm9ybWF0dGluZ1Rva2VucyB9IGZyb20gJy4uL2Zvcm1hdC9mb3JtYXQnO1xuaW1wb3J0IGNoZWNrT3ZlcmZsb3cgZnJvbSAnLi9jaGVjay1vdmVyZmxvdyc7XG5pbXBvcnQgeyBIT1VSIH0gZnJvbSAnLi4vdW5pdHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGhvb2tzIH0gZnJvbSAnLi4vdXRpbHMvaG9va3MnO1xuaW1wb3J0IGdldFBhcnNpbmdGbGFncyBmcm9tICcuL3BhcnNpbmctZmxhZ3MnO1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG5ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25maWcuX2EgPSBbXTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgIH1cblxuICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbn1cblxuXG5mdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICB2YXIgaXNQbTtcblxuICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxuICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY29weUNvbmZpZyB9IGZyb20gJy4uL21vbWVudC9jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0IH0gZnJvbSAnLi9mcm9tLXN0cmluZy1hbmQtZm9ybWF0JztcbmltcG9ydCBnZXRQYXJzaW5nRmxhZ3MgZnJvbSAnLi9wYXJzaW5nLWZsYWdzJztcbmltcG9ydCB7IGlzVmFsaWQgfSBmcm9tICcuL3ZhbGlkJztcbmltcG9ydCBleHRlbmQgZnJvbSAnLi4vdXRpbHMvZXh0ZW5kJztcblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbmV4cG9ydCBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgIGksXG4gICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xufVxuIiwiaW1wb3J0IHsgbm9ybWFsaXplT2JqZWN0VW5pdHMgfSBmcm9tICcuLi91bml0cy9hbGlhc2VzJztcbmltcG9ydCB7IGNvbmZpZ0Zyb21BcnJheSB9IGZyb20gJy4vZnJvbS1hcnJheSc7XG5pbXBvcnQgbWFwIGZyb20gJy4uL3V0aWxzL21hcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xufVxuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi4vdXRpbHMvaXMtYXJyYXknO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4uL3V0aWxzL2lzLW9iamVjdCc7XG5pbXBvcnQgaXNPYmplY3RFbXB0eSBmcm9tICcuLi91dGlscy9pcy1vYmplY3QtZW1wdHknO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4uL3V0aWxzL2lzLXVuZGVmaW5lZCc7XG5pbXBvcnQgaXNOdW1iZXIgZnJvbSAnLi4vdXRpbHMvaXMtbnVtYmVyJztcbmltcG9ydCBpc0RhdGUgZnJvbSAnLi4vdXRpbHMvaXMtZGF0ZSc7XG5pbXBvcnQgbWFwIGZyb20gJy4uL3V0aWxzL21hcCc7XG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkIH0gZnJvbSAnLi92YWxpZCc7XG5pbXBvcnQgeyBNb21lbnQsIGlzTW9tZW50IH0gZnJvbSAnLi4vbW9tZW50L2NvbnN0cnVjdG9yJztcbmltcG9ydCB7IGdldExvY2FsZSB9IGZyb20gJy4uL2xvY2FsZS9sb2NhbGVzJztcbmltcG9ydCB7IGhvb2tzIH0gZnJvbSAnLi4vdXRpbHMvaG9va3MnO1xuaW1wb3J0IGNoZWNrT3ZlcmZsb3cgZnJvbSAnLi9jaGVjay1vdmVyZmxvdyc7XG5pbXBvcnQgeyBpc1ZhbGlkIH0gZnJvbSAnLi92YWxpZCc7XG5cbmltcG9ydCB7IGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheSB9ICBmcm9tICcuL2Zyb20tc3RyaW5nLWFuZC1hcnJheSc7XG5pbXBvcnQgeyBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0IH0gZnJvbSAnLi9mcm9tLXN0cmluZy1hbmQtZm9ybWF0JztcbmltcG9ydCB7IGNvbmZpZ0Zyb21TdHJpbmcgfSAgICAgICAgICBmcm9tICcuL2Zyb20tc3RyaW5nJztcbmltcG9ydCB7IGNvbmZpZ0Zyb21BcnJheSB9ICAgICAgICAgICBmcm9tICcuL2Zyb20tYXJyYXknO1xuaW1wb3J0IHsgY29uZmlnRnJvbU9iamVjdCB9ICAgICAgICAgIGZyb20gJy4vZnJvbS1vYmplY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgIH1cblxuICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSAgZWxzZSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgIH1cblxuICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICBjLl9sID0gbG9jYWxlO1xuICAgIGMuX2kgPSBpbnB1dDtcbiAgICBjLl9mID0gZm9ybWF0O1xuICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlTG9jYWxPclVUQyB9IGZyb20gJy4vZnJvbS1hbnl0aGluZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xufVxuIiwiaW1wb3J0IHsgZGVwcmVjYXRlIH0gZnJvbSAnLi4vdXRpbHMvZGVwcmVjYXRlJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4uL3V0aWxzL2lzLWFycmF5JztcbmltcG9ydCB7IGNyZWF0ZUxvY2FsIH0gZnJvbSAnLi4vY3JlYXRlL2xvY2FsJztcbmltcG9ydCB7IGNyZWF0ZUludmFsaWQgfSBmcm9tICcuLi9jcmVhdGUvdmFsaWQnO1xuXG5leHBvcnQgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG5leHBvcnQgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG4vLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuLy9cbi8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2Vcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG5mdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICB2YXIgcmVzLCBpO1xuICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgIH1cbiAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgIH1cbiAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuZXhwb3J0IGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbn1cbiIsImV4cG9ydCB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xufTtcbiIsImltcG9ydCB0b0ludCBmcm9tICcuLi91dGlscy90by1pbnQnO1xuaW1wb3J0IHtEdXJhdGlvbn0gZnJvbSAnLi9jb25zdHJ1Y3Rvcic7XG5pbXBvcnQge2NyZWF0ZUR1cmF0aW9ufSBmcm9tICcuL2NyZWF0ZSc7XG5cbnZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgIGlmICghKG9yZGVyaW5nLmluZGV4T2Yoa2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG59XG4iLCJpbXBvcnQgeyBub3JtYWxpemVPYmplY3RVbml0cyB9IGZyb20gJy4uL3VuaXRzL2FsaWFzZXMnO1xuaW1wb3J0IHsgZ2V0TG9jYWxlIH0gZnJvbSAnLi4vbG9jYWxlL2xvY2FsZXMnO1xuaW1wb3J0IGlzRHVyYXRpb25WYWxpZCBmcm9tICcuL3ZhbGlkLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgd2Vla3MgKiA3O1xuICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICB0aGlzLl9idWJibGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgIH1cbn1cbiIsImltcG9ydCB6ZXJvRmlsbCBmcm9tICcuLi91dGlscy96ZXJvLWZpbGwnO1xuaW1wb3J0IHsgY3JlYXRlRHVyYXRpb24gfSBmcm9tICcuLi9kdXJhdGlvbi9jcmVhdGUnO1xuaW1wb3J0IHsgYWRkU3VidHJhY3QgfSBmcm9tICcuLi9tb21lbnQvYWRkLXN1YnRyYWN0JztcbmltcG9ydCB7IGlzTW9tZW50LCBjb3B5Q29uZmlnIH0gZnJvbSAnLi4vbW9tZW50L2NvbnN0cnVjdG9yJztcbmltcG9ydCB7IGFkZEZvcm1hdFRva2VuIH0gZnJvbSAnLi4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBhZGRSZWdleFRva2VuLCBtYXRjaE9mZnNldCwgbWF0Y2hTaG9ydE9mZnNldCB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFBhcnNlVG9rZW4gfSBmcm9tICcuLi9wYXJzZS90b2tlbic7XG5pbXBvcnQgeyBjcmVhdGVMb2NhbCB9IGZyb20gJy4uL2NyZWF0ZS9sb2NhbCc7XG5pbXBvcnQgeyBwcmVwYXJlQ29uZmlnIH0gZnJvbSAnLi4vY3JlYXRlL2Zyb20tYW55dGhpbmcnO1xuaW1wb3J0IHsgY3JlYXRlVVRDIH0gZnJvbSAnLi4vY3JlYXRlL3V0Yyc7XG5pbXBvcnQgaXNEYXRlIGZyb20gJy4uL3V0aWxzL2lzLWRhdGUnO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSAnLi4vdXRpbHMvaXMtdW5kZWZpbmVkJztcbmltcG9ydCBjb21wYXJlQXJyYXlzIGZyb20gJy4uL3V0aWxzL2NvbXBhcmUtYXJyYXlzJztcbmltcG9ydCB7IGhvb2tzIH0gZnJvbSAnLi4vdXRpbHMvaG9va3MnO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgfSk7XG59XG5cbm9mZnNldCgnWicsICc6Jyk7XG5vZmZzZXQoJ1paJywgJycpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyB0aW1lem9uZSBjaHVua2VyXG4vLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbi8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxudmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG5mdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgMCA6XG4gICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xufVxuXG4vLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICB2YXIgcmVzLCBkaWZmO1xuICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG59XG5cbi8vIEhPT0tTXG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbi8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbi8vIE1PTUVOVFNcblxuLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuLy9cbi8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4vLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4vLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2Vcbi8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgIGxvY2FsQWRqdXN0O1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIHZhciBjID0ge307XG5cbiAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgaWYgKGMuX2EpIHtcbiAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG59XG4iLCJpbXBvcnQgeyBEdXJhdGlvbiwgaXNEdXJhdGlvbiB9IGZyb20gJy4vY29uc3RydWN0b3InO1xuaW1wb3J0IGlzTnVtYmVyIGZyb20gJy4uL3V0aWxzL2lzLW51bWJlcic7XG5pbXBvcnQgdG9JbnQgZnJvbSAnLi4vdXRpbHMvdG8taW50JztcbmltcG9ydCBhYnNSb3VuZCBmcm9tICcuLi91dGlscy9hYnMtcm91bmQnO1xuaW1wb3J0IGhhc093blByb3AgZnJvbSAnLi4vdXRpbHMvaGFzLW93bi1wcm9wJztcbmltcG9ydCB7IERBVEUsIEhPVVIsIE1JTlVURSwgU0VDT05ELCBNSUxMSVNFQ09ORCB9IGZyb20gJy4uL3VuaXRzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjbG9uZVdpdGhPZmZzZXQgfSBmcm9tICcuLi91bml0cy9vZmZzZXQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYWwgfSBmcm9tICcuLi9jcmVhdGUvbG9jYWwnO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZCBhcyBpbnZhbGlkIH0gZnJvbSAnLi92YWxpZCc7XG5cbi8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxudmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbi8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbnZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgcmV0LFxuICAgICAgICBkaWZmUmVzO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5jcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gaW52YWxpZDtcblxuZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG59XG5cbmZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgLS1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXM7XG4gICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICB9XG5cbiAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuIiwiaW1wb3J0IHsgZ2V0LCBzZXQgfSBmcm9tICcuL2dldC1zZXQnO1xuaW1wb3J0IHsgc2V0TW9udGggfSBmcm9tICcuLi91bml0cy9tb250aCc7XG5pbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4uL2R1cmF0aW9uL2NyZWF0ZSc7XG5pbXBvcnQgeyBkZXByZWNhdGVTaW1wbGUgfSBmcm9tICcuLi91dGlscy9kZXByZWNhdGUnO1xuaW1wb3J0IHsgaG9va3MgfSBmcm9tICcuLi91dGlscy9ob29rcyc7XG5pbXBvcnQgYWJzUm91bmQgZnJvbSAnLi4vdXRpbHMvYWJzLXJvdW5kJztcblxuXG4vLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG5mdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAoZGF5cykge1xuICAgICAgICBzZXQobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbmV4cG9ydCB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiIsImltcG9ydCB7IGNyZWF0ZUxvY2FsIH0gZnJvbSAnLi4vY3JlYXRlL2xvY2FsJztcbmltcG9ydCB7IGNsb25lV2l0aE9mZnNldCB9IGZyb20gJy4uL3VuaXRzL29mZnNldCc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuLi91dGlscy9pcy1mdW5jdGlvbic7XG5pbXBvcnQgeyBob29rcyB9IGZyb20gJy4uL3V0aWxzL2hvb2tzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGVuZGFyICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbn1cbiIsImltcG9ydCB7IE1vbWVudCB9IGZyb20gJy4vY29uc3RydWN0b3InO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xufVxuIiwiaW1wb3J0IHsgaXNNb21lbnQgfSBmcm9tICcuL2NvbnN0cnVjdG9yJztcbmltcG9ydCB7IG5vcm1hbGl6ZVVuaXRzIH0gZnJvbSAnLi4vdW5pdHMvYWxpYXNlcyc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhbCB9IGZyb20gJy4uL2NyZWF0ZS9sb2NhbCc7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSAnLi4vdXRpbHMvaXMtdW5kZWZpbmVkJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICBpbnB1dE1zO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbn1cbiIsImltcG9ydCBhYnNGbG9vciBmcm9tICcuLi91dGlscy9hYnMtZmxvb3InO1xuaW1wb3J0IHsgY2xvbmVXaXRoT2Zmc2V0IH0gZnJvbSAnLi4vdW5pdHMvb2Zmc2V0JztcbmltcG9ydCB7IG5vcm1hbGl6ZVVuaXRzIH0gZnJvbSAnLi4vdW5pdHMvYWxpYXNlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICB2YXIgdGhhdCxcbiAgICAgICAgem9uZURlbHRhLFxuICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIGlmICh1bml0cyA9PT0gJ3llYXInIHx8IHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMztcbiAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIG91dHB1dCA9IHVuaXRzID09PSAnc2Vjb25kJyA/IGRlbHRhIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgdW5pdHMgPT09ICdkYXknID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDg2NGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICB9XG5cbiAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG59XG4iLCJpbXBvcnQgeyBmb3JtYXRNb21lbnQgfSBmcm9tICcuLi9mb3JtYXQvZm9ybWF0JztcbmltcG9ydCB7IGhvb2tzIH0gZnJvbSAnLi4vdXRpbHMvaG9va3MnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi4vdXRpbHMvaXMtZnVuY3Rpb24nO1xuXG5ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbmhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAqXG4gKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgIHZhciB6b25lID0gJyc7XG4gICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgem9uZSA9ICdaJztcbiAgICB9XG4gICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi4vZHVyYXRpb24vY3JlYXRlJztcbmltcG9ydCB7IGNyZWF0ZUxvY2FsIH0gZnJvbSAnLi4vY3JlYXRlL2xvY2FsJztcbmltcG9ydCB7IGlzTW9tZW50IH0gZnJvbSAnLi4vbW9tZW50L2NvbnN0cnVjdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi4vZHVyYXRpb24vY3JlYXRlJztcbmltcG9ydCB7IGNyZWF0ZUxvY2FsIH0gZnJvbSAnLi4vY3JlYXRlL2xvY2FsJztcbmltcG9ydCB7IGlzTW9tZW50IH0gZnJvbSAnLi4vbW9tZW50L2NvbnN0cnVjdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cbiIsImltcG9ydCB7IGdldExvY2FsZSB9IGZyb20gJy4uL2xvY2FsZS9sb2NhbGVzJztcbmltcG9ydCB7IGRlcHJlY2F0ZSB9IGZyb20gJy4uL3V0aWxzL2RlcHJlY2F0ZSc7XG5cbi8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbi8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG59XG4iLCJpbXBvcnQgeyBub3JtYWxpemVVbml0cyB9IGZyb20gJy4uL3VuaXRzL2FsaWFzZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9XG5cbiAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgfVxuICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICB9XG5cbiAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXggKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICB2YXIgbSA9IHRoaXM7XG4gICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuIiwiaW1wb3J0IHsgaXNWYWxpZCBhcyBfaXNWYWxpZCB9IGZyb20gJy4uL2NyZWF0ZS92YWxpZCc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4uL3V0aWxzL2V4dGVuZCc7XG5pbXBvcnQgZ2V0UGFyc2luZ0ZsYWdzIGZyb20gJy4uL2NyZWF0ZS9wYXJzaW5nLWZsYWdzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQgKCkge1xuICAgIHJldHVybiBfaXNWYWxpZCh0aGlzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgYWRkRm9ybWF0VG9rZW4gfSBmcm9tICcuLi9mb3JtYXQvZm9ybWF0JztcbmltcG9ydCB7IGFkZFVuaXRBbGlhcyB9IGZyb20gJy4vYWxpYXNlcyc7XG5pbXBvcnQgeyBhZGRVbml0UHJpb3JpdHkgfSBmcm9tICcuL3ByaW9yaXRpZXMnO1xuaW1wb3J0IHsgYWRkUmVnZXhUb2tlbiwgbWF0Y2gxdG8yLCBtYXRjaDF0bzQsIG1hdGNoMXRvNiwgbWF0Y2gyLCBtYXRjaDQsIG1hdGNoNiwgbWF0Y2hTaWduZWQgfSBmcm9tICcuLi9wYXJzZS9yZWdleCc7XG5pbXBvcnQgeyBhZGRXZWVrUGFyc2VUb2tlbiB9IGZyb20gJy4uL3BhcnNlL3Rva2VuJztcbmltcG9ydCB7IHdlZWtPZlllYXIsIHdlZWtzSW5ZZWFyLCBkYXlPZlllYXJGcm9tV2Vla3MgfSBmcm9tICcuL3dlZWstY2FsZW5kYXItdXRpbHMnO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5pbXBvcnQgeyBob29rcyB9IGZyb20gJy4uL3V0aWxzL2hvb2tzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2FsIH0gZnJvbSAnLi4vY3JlYXRlL2xvY2FsJztcbmltcG9ydCB7IGNyZWF0ZVVUQ0RhdGUgfSBmcm9tICcuLi9jcmVhdGUvZGF0ZS1mcm9tLWFycmF5JztcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbn1cblxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCB7IGFkZEZvcm1hdFRva2VuIH0gZnJvbSAnLi4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBhZGRVbml0QWxpYXMgfSBmcm9tICcuL2FsaWFzZXMnO1xuaW1wb3J0IHsgYWRkVW5pdFByaW9yaXR5IH0gZnJvbSAnLi9wcmlvcml0aWVzJztcbmltcG9ydCB7IGFkZFJlZ2V4VG9rZW4sIG1hdGNoMSB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFBhcnNlVG9rZW4gfSBmcm9tICcuLi9wYXJzZS90b2tlbic7XG5pbXBvcnQgeyBNT05USCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0b0ludCBmcm9tICcuLi91dGlscy90by1pbnQnO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbn1cbiIsImltcG9ydCB7IG1ha2VHZXRTZXQgfSBmcm9tICcuLi9tb21lbnQvZ2V0LXNldCc7XG5pbXBvcnQgeyBhZGRGb3JtYXRUb2tlbiB9IGZyb20gJy4uL2Zvcm1hdC9mb3JtYXQnO1xuaW1wb3J0IHsgYWRkVW5pdEFsaWFzIH0gZnJvbSAnLi9hbGlhc2VzJztcbmltcG9ydCB7IGFkZFVuaXRQcmlvcml0eSB9IGZyb20gJy4vcHJpb3JpdGllcyc7XG5pbXBvcnQgeyBhZGRSZWdleFRva2VuLCBtYXRjaDF0bzIsIG1hdGNoMiB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFBhcnNlVG9rZW4gfSBmcm9tICcuLi9wYXJzZS90b2tlbic7XG5pbXBvcnQgeyBEQVRFIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuLy8gUFJJT1JPSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG5hZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmV4cG9ydCB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcbiIsImltcG9ydCB7IGFkZEZvcm1hdFRva2VuIH0gZnJvbSAnLi4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBhZGRVbml0QWxpYXMgfSBmcm9tICcuL2FsaWFzZXMnO1xuaW1wb3J0IHsgYWRkVW5pdFByaW9yaXR5IH0gZnJvbSAnLi9wcmlvcml0aWVzJztcbmltcG9ydCB7IGFkZFJlZ2V4VG9rZW4sIG1hdGNoMywgbWF0Y2gxdG8zIH0gZnJvbSAnLi4vcGFyc2UvcmVnZXgnO1xuaW1wb3J0IHsgZGF5c0luWWVhciB9IGZyb20gJy4veWVhcic7XG5pbXBvcnQgeyBjcmVhdGVVVENEYXRlIH0gZnJvbSAnLi4vY3JlYXRlL2RhdGUtZnJvbS1hcnJheSc7XG5pbXBvcnQgeyBhZGRQYXJzZVRva2VuIH0gZnJvbSAnLi4vcGFyc2UvdG9rZW4nO1xuaW1wb3J0IHRvSW50IGZyb20gJy4uL3V0aWxzL3RvLWludCc7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG5hZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbmFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIE1PTUVOVFNcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbn1cbiIsImltcG9ydCB7IG1ha2VHZXRTZXQgfSBmcm9tICcuLi9tb21lbnQvZ2V0LXNldCc7XG5pbXBvcnQgeyBhZGRGb3JtYXRUb2tlbiB9IGZyb20gJy4uL2Zvcm1hdC9mb3JtYXQnO1xuaW1wb3J0IHsgYWRkVW5pdEFsaWFzIH0gZnJvbSAnLi9hbGlhc2VzJztcbmltcG9ydCB7IGFkZFVuaXRQcmlvcml0eSB9IGZyb20gJy4vcHJpb3JpdGllcyc7XG5pbXBvcnQgeyBhZGRSZWdleFRva2VuLCBtYXRjaDF0bzIsIG1hdGNoMiB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFBhcnNlVG9rZW4gfSBmcm9tICcuLi9wYXJzZS90b2tlbic7XG5pbXBvcnQgeyBNSU5VVEUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuLy8gTU9NRU5UU1xuXG5leHBvcnQgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG4iLCJpbXBvcnQgeyBtYWtlR2V0U2V0IH0gZnJvbSAnLi4vbW9tZW50L2dldC1zZXQnO1xuaW1wb3J0IHsgYWRkRm9ybWF0VG9rZW4gfSBmcm9tICcuLi9mb3JtYXQvZm9ybWF0JztcbmltcG9ydCB7IGFkZFVuaXRBbGlhcyB9IGZyb20gJy4vYWxpYXNlcyc7XG5pbXBvcnQgeyBhZGRVbml0UHJpb3JpdHkgfSBmcm9tICcuL3ByaW9yaXRpZXMnO1xuaW1wb3J0IHsgYWRkUmVnZXhUb2tlbiwgbWF0Y2gxdG8yLCBtYXRjaDIgfSBmcm9tICcuLi9wYXJzZS9yZWdleCc7XG5pbXBvcnQgeyBhZGRQYXJzZVRva2VuIH0gZnJvbSAnLi4vcGFyc2UvdG9rZW4nO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbi8vIE1PTUVOVFNcblxuZXhwb3J0IHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuIiwiaW1wb3J0IHsgbWFrZUdldFNldCB9IGZyb20gJy4uL21vbWVudC9nZXQtc2V0JztcbmltcG9ydCB7IGFkZEZvcm1hdFRva2VuIH0gZnJvbSAnLi4vZm9ybWF0L2Zvcm1hdCc7XG5pbXBvcnQgeyBhZGRVbml0QWxpYXMgfSBmcm9tICcuL2FsaWFzZXMnO1xuaW1wb3J0IHsgYWRkVW5pdFByaW9yaXR5IH0gZnJvbSAnLi9wcmlvcml0aWVzJztcbmltcG9ydCB7IGFkZFJlZ2V4VG9rZW4sIG1hdGNoMSwgbWF0Y2gyLCBtYXRjaDMsIG1hdGNoMXRvMywgbWF0Y2hVbnNpZ25lZCB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFBhcnNlVG9rZW4gfSBmcm9tICcuLi9wYXJzZS90b2tlbic7XG5pbXBvcnQgeyBNSUxMSVNFQ09ORCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0b0ludCBmcm9tICcuLi91dGlscy90by1pbnQnO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xufSk7XG5cblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG52YXIgdG9rZW47XG5mb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbn1cblxuZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xufVxuLy8gTU9NRU5UU1xuXG5leHBvcnQgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuIiwiaW1wb3J0IHsgYWRkRm9ybWF0VG9rZW4gfSBmcm9tICcuLi9mb3JtYXQvZm9ybWF0JztcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbmFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4vLyBNT01FTlRTXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG59XG4iLCJpbXBvcnQgeyBNb21lbnQgfSBmcm9tICcuL2NvbnN0cnVjdG9yJztcblxudmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuaW1wb3J0IHsgYWRkLCBzdWJ0cmFjdCB9IGZyb20gJy4vYWRkLXN1YnRyYWN0JztcbmltcG9ydCB7IGNhbGVuZGFyLCBnZXRDYWxlbmRhckZvcm1hdCB9IGZyb20gJy4vY2FsZW5kYXInO1xuaW1wb3J0IHsgY2xvbmUgfSBmcm9tICcuL2Nsb25lJztcbmltcG9ydCB7IGlzQmVmb3JlLCBpc0JldHdlZW4sIGlzU2FtZSwgaXNBZnRlciwgaXNTYW1lT3JBZnRlciwgaXNTYW1lT3JCZWZvcmUgfSBmcm9tICcuL2NvbXBhcmUnO1xuaW1wb3J0IHsgZGlmZiB9IGZyb20gJy4vZGlmZic7XG5pbXBvcnQgeyBmb3JtYXQsIHRvU3RyaW5nLCB0b0lTT1N0cmluZywgaW5zcGVjdCB9IGZyb20gJy4vZm9ybWF0JztcbmltcG9ydCB7IGZyb20sIGZyb21Ob3cgfSBmcm9tICcuL2Zyb20nO1xuaW1wb3J0IHsgdG8sIHRvTm93IH0gZnJvbSAnLi90byc7XG5pbXBvcnQgeyBzdHJpbmdHZXQsIHN0cmluZ1NldCB9IGZyb20gJy4vZ2V0LXNldCc7XG5pbXBvcnQgeyBsb2NhbGUsIGxvY2FsZURhdGEsIGxhbmcgfSBmcm9tICcuL2xvY2FsZSc7XG5pbXBvcnQgeyBwcm90b3R5cGVNaW4sIHByb3RvdHlwZU1heCB9IGZyb20gJy4vbWluLW1heCc7XG5pbXBvcnQgeyBzdGFydE9mLCBlbmRPZiB9IGZyb20gJy4vc3RhcnQtZW5kLW9mJztcbmltcG9ydCB7IHZhbHVlT2YsIHRvRGF0ZSwgdG9BcnJheSwgdG9PYmplY3QsIHRvSlNPTiwgdW5peCB9IGZyb20gJy4vdG8tdHlwZSc7XG5pbXBvcnQgeyBpc1ZhbGlkLCBwYXJzaW5nRmxhZ3MsIGludmFsaWRBdCB9IGZyb20gJy4vdmFsaWQnO1xuaW1wb3J0IHsgY3JlYXRpb25EYXRhIH0gZnJvbSAnLi9jcmVhdGlvbi1kYXRhJztcblxucHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XG5wcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyO1xucHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbnByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbnByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG5wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbnByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbnByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbnByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG5wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xucHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG5wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbnByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbnByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG5wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbnByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xucHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xucHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbnByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZDtcbnByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbnByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xucHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xucHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG5wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbnByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xucHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG5wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG5wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xucHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xucHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbnByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xucHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbnByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcbnByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xucHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbnByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbnByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbnByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4vLyBZZWFyXG5pbXBvcnQgeyBnZXRTZXRZZWFyLCBnZXRJc0xlYXBZZWFyIH0gZnJvbSAnLi4vdW5pdHMveWVhcic7XG5wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbnByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4vLyBXZWVrIFllYXJcbmltcG9ydCB7IGdldFNldFdlZWtZZWFyLCBnZXRTZXRJU09XZWVrWWVhciwgZ2V0V2Vla3NJblllYXIsIGdldElTT1dlZWtzSW5ZZWFyIH0gZnJvbSAnLi4vdW5pdHMvd2Vlay15ZWFyJztcbnByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG5wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4vLyBRdWFydGVyXG5pbXBvcnQgeyBnZXRTZXRRdWFydGVyIH0gZnJvbSAnLi4vdW5pdHMvcXVhcnRlcic7XG5wcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4vLyBNb250aFxuaW1wb3J0IHsgZ2V0U2V0TW9udGgsIGdldERheXNJbk1vbnRoIH0gZnJvbSAnLi4vdW5pdHMvbW9udGgnO1xucHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbnByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbi8vIFdlZWtcbmltcG9ydCB7IGdldFNldFdlZWssIGdldFNldElTT1dlZWsgfSBmcm9tICcuLi91bml0cy93ZWVrJztcbnByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbnByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbnByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG5wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4vLyBEYXlcbmltcG9ydCB7IGdldFNldERheU9mTW9udGggfSBmcm9tICcuLi91bml0cy9kYXktb2YtbW9udGgnO1xuaW1wb3J0IHsgZ2V0U2V0RGF5T2ZXZWVrLCBnZXRTZXRJU09EYXlPZldlZWssIGdldFNldExvY2FsZURheU9mV2VlayB9IGZyb20gJy4uL3VuaXRzL2RheS1vZi13ZWVrJztcbmltcG9ydCB7IGdldFNldERheU9mWWVhciB9IGZyb20gJy4uL3VuaXRzL2RheS1vZi15ZWFyJztcbnByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xucHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG5wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xucHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbnByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbi8vIEhvdXJcbmltcG9ydCB7IGdldFNldEhvdXIgfSBmcm9tICcuLi91bml0cy9ob3VyJztcbnByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbi8vIE1pbnV0ZVxuaW1wb3J0IHsgZ2V0U2V0TWludXRlIH0gZnJvbSAnLi4vdW5pdHMvbWludXRlJztcbnByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbi8vIFNlY29uZFxuaW1wb3J0IHsgZ2V0U2V0U2Vjb25kIH0gZnJvbSAnLi4vdW5pdHMvc2Vjb25kJztcbnByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbi8vIE1pbGxpc2Vjb25kXG5pbXBvcnQgeyBnZXRTZXRNaWxsaXNlY29uZCB9IGZyb20gJy4uL3VuaXRzL21pbGxpc2Vjb25kJztcbnByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbi8vIE9mZnNldFxuaW1wb3J0IHtcbiAgICBnZXRTZXRPZmZzZXQsXG4gICAgc2V0T2Zmc2V0VG9VVEMsXG4gICAgc2V0T2Zmc2V0VG9Mb2NhbCxcbiAgICBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCxcbiAgICBoYXNBbGlnbmVkSG91ck9mZnNldCxcbiAgICBpc0RheWxpZ2h0U2F2aW5nVGltZSxcbiAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQsXG4gICAgZ2V0U2V0Wm9uZSxcbiAgICBpc0xvY2FsLFxuICAgIGlzVXRjT2Zmc2V0LFxuICAgIGlzVXRjXG59IGZyb20gJy4uL3VuaXRzL29mZnNldCc7XG5wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbnByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG5wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG5wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xucHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbnByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG5wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG5wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xucHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbnByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbi8vIFRpbWV6b25lXG5pbXBvcnQgeyBnZXRab25lQWJiciwgZ2V0Wm9uZU5hbWUgfSBmcm9tICcuLi91bml0cy90aW1lem9uZSc7XG5wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xucHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuLy8gRGVwcmVjYXRpb25zXG5pbXBvcnQgeyBkZXByZWNhdGUgfSBmcm9tICcuLi91dGlscy9kZXByZWNhdGUnO1xucHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xucHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG5wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbnByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbnByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XG5cbmV4cG9ydCBkZWZhdWx0IHByb3RvO1xuIiwiaW1wb3J0IHsgY3JlYXRlTG9jYWwgfSBmcm9tICcuLi9jcmVhdGUvbG9jYWwnO1xuaW1wb3J0IHsgY3JlYXRlVVRDIH0gZnJvbSAnLi4vY3JlYXRlL3V0Yyc7XG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkIH0gZnJvbSAnLi4vY3JlYXRlL3ZhbGlkJztcbmltcG9ydCB7IGlzTW9tZW50IH0gZnJvbSAnLi9jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBtaW4sIG1heCB9IGZyb20gJy4vbWluLW1heCc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL25vdyc7XG5pbXBvcnQgbW9tZW50UHJvdG90eXBlIGZyb20gJy4vcHJvdG90eXBlJztcblxuZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbn1cblxuZXhwb3J0IHtcbiAgICBub3csXG4gICAgbWluLFxuICAgIG1heCxcbiAgICBpc01vbWVudCxcbiAgICBjcmVhdGVVVEMsXG4gICAgY3JlYXRlVW5peCxcbiAgICBjcmVhdGVMb2NhbCxcbiAgICBjcmVhdGVJblpvbmUsXG4gICAgY3JlYXRlSW52YWxpZCxcbiAgICBtb21lbnRQcm90b3R5cGVcbn07XG4iLCJleHBvcnQgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuIiwiaW1wb3J0IHsgTG9jYWxlIH0gZnJvbSAnLi9jb25zdHJ1Y3Rvcic7XG5cbnZhciBwcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbmltcG9ydCB7IGNhbGVuZGFyIH0gZnJvbSAnLi9jYWxlbmRhcic7XG5pbXBvcnQgeyBsb25nRGF0ZUZvcm1hdCB9IGZyb20gJy4vZm9ybWF0cyc7XG5pbXBvcnQgeyBpbnZhbGlkRGF0ZSB9IGZyb20gJy4vaW52YWxpZCc7XG5pbXBvcnQgeyBvcmRpbmFsIH0gZnJvbSAnLi9vcmRpbmFsJztcbmltcG9ydCB7IHByZVBhcnNlUG9zdEZvcm1hdCB9IGZyb20gJy4vcHJlLXBvc3QtZm9ybWF0JztcbmltcG9ydCB7IHJlbGF0aXZlVGltZSwgcGFzdEZ1dHVyZSB9IGZyb20gJy4vcmVsYXRpdmUnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi9zZXQnO1xuXG5wcm90by5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbnByb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xucHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG5wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xucHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xucHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbnByb3RvLnNldCAgICAgICAgICAgICA9IHNldDtcblxuLy8gTW9udGhcbmltcG9ydCB7XG4gICAgbG9jYWxlTW9udGhzUGFyc2UsXG4gICAgbG9jYWxlTW9udGhzLFxuICAgIGxvY2FsZU1vbnRoc1Nob3J0LFxuICAgIG1vbnRoc1JlZ2V4LFxuICAgIG1vbnRoc1Nob3J0UmVnZXhcbn0gZnJvbSAnLi4vdW5pdHMvbW9udGgnO1xuXG5wcm90by5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG5wcm90by5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbnByb3RvLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xucHJvdG8ubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbnByb3RvLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcblxuLy8gV2Vla1xuaW1wb3J0IHsgbG9jYWxlV2VlaywgbG9jYWxlRmlyc3REYXlPZlllYXIsIGxvY2FsZUZpcnN0RGF5T2ZXZWVrIH0gZnJvbSAnLi4vdW5pdHMvd2Vlayc7XG5wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbnByb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG5wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4vLyBEYXkgb2YgV2Vla1xuaW1wb3J0IHtcbiAgICBsb2NhbGVXZWVrZGF5c1BhcnNlLFxuICAgIGxvY2FsZVdlZWtkYXlzLFxuICAgIGxvY2FsZVdlZWtkYXlzTWluLFxuICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICB3ZWVrZGF5c1JlZ2V4LFxuICAgIHdlZWtkYXlzU2hvcnRSZWdleCxcbiAgICB3ZWVrZGF5c01pblJlZ2V4XG59IGZyb20gJy4uL3VuaXRzL2RheS1vZi13ZWVrJztcblxucHJvdG8ud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG5wcm90by53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbnByb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG5wcm90by53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG5wcm90by53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG5wcm90by53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbnByb3RvLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuLy8gSG91cnNcbmltcG9ydCB7IGxvY2FsZUlzUE0sIGxvY2FsZU1lcmlkaWVtIH0gZnJvbSAnLi4vdW5pdHMvaG91cic7XG5cbnByb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xucHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcbiIsImltcG9ydCBpc051bWJlciBmcm9tICcuLi91dGlscy9pcy1udW1iZXInO1xuaW1wb3J0IHsgZ2V0TG9jYWxlIH0gZnJvbSAnLi9sb2NhbGVzJztcbmltcG9ydCB7IGNyZWF0ZVVUQyB9IGZyb20gJy4uL2NyZWF0ZS91dGMnO1xuXG5mdW5jdGlvbiBnZXQgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldChmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLy8gKClcbi8vICg1KVxuLy8gKGZtdCwgNSlcbi8vIChmbXQpXG4vLyAodHJ1ZSlcbi8vICh0cnVlLCA1KVxuLy8gKHRydWUsIGZtdCwgNSlcbi8vICh0cnVlLCBmbXQpXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldChmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbn1cbiIsImltcG9ydCAnLi9wcm90b3R5cGUnO1xuaW1wb3J0IHsgZ2V0U2V0R2xvYmFsTG9jYWxlIH0gZnJvbSAnLi9sb2NhbGVzJztcbmltcG9ydCB0b0ludCBmcm9tICcuLi91dGlscy90by1pbnQnO1xuXG5nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgIH1cbn0pO1xuIiwiLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuaW1wb3J0ICcuL3Byb3RvdHlwZSc7XG5cbmltcG9ydCB7XG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlLFxuICAgIGRlZmluZUxvY2FsZSxcbiAgICB1cGRhdGVMb2NhbGUsXG4gICAgZ2V0TG9jYWxlLFxuICAgIGxpc3RMb2NhbGVzXG59IGZyb20gJy4vbG9jYWxlcyc7XG5cbmltcG9ydCB7XG4gICAgbGlzdE1vbnRocyxcbiAgICBsaXN0TW9udGhzU2hvcnQsXG4gICAgbGlzdFdlZWtkYXlzLFxuICAgIGxpc3RXZWVrZGF5c1Nob3J0LFxuICAgIGxpc3RXZWVrZGF5c01pblxufSBmcm9tICcuL2xpc3RzJztcblxuZXhwb3J0IHtcbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUsXG4gICAgZGVmaW5lTG9jYWxlLFxuICAgIHVwZGF0ZUxvY2FsZSxcbiAgICBnZXRMb2NhbGUsXG4gICAgbGlzdExvY2FsZXMsXG4gICAgbGlzdE1vbnRocyxcbiAgICBsaXN0TW9udGhzU2hvcnQsXG4gICAgbGlzdFdlZWtkYXlzLFxuICAgIGxpc3RXZWVrZGF5c1Nob3J0LFxuICAgIGxpc3RXZWVrZGF5c01pblxufTtcblxuaW1wb3J0IHsgZGVwcmVjYXRlIH0gZnJvbSAnLi4vdXRpbHMvZGVwcmVjYXRlJztcbmltcG9ydCB7IGhvb2tzIH0gZnJvbSAnLi4vdXRpbHMvaG9va3MnO1xuXG5ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG5ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbmltcG9ydCAnLi9lbic7XG4iLCJ2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG5leHBvcnQgZnVuY3Rpb24gYWJzICgpIHtcbiAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi9jcmVhdGUnO1xuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbmV4cG9ydCBmdW5jdGlvbiBhZGQgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgYWJzRmxvb3IgZnJvbSAnLi4vdXRpbHMvYWJzLWZsb29yJztcbmltcG9ydCBhYnNDZWlsIGZyb20gJy4uL3V0aWxzL2Ficy1jZWlsJztcbmltcG9ydCB7IGNyZWF0ZVVUQ0RhdGUgfSBmcm9tICcuLi9jcmVhdGUvZGF0ZS1mcm9tLWFycmF5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgbW9udGhzID0gMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cbiAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5Nztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG59XG4iLCJpbXBvcnQgeyBkYXlzVG9Nb250aHMsIG1vbnRoc1RvRGF5cyB9IGZyb20gJy4vYnViYmxlJztcbmltcG9ydCB7IG5vcm1hbGl6ZVVuaXRzIH0gZnJvbSAnLi4vdW5pdHMvYWxpYXNlcyc7XG5pbXBvcnQgdG9JbnQgZnJvbSAnLi4vdXRpbHMvdG8taW50JztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIGRheXM7XG4gICAgdmFyIG1vbnRocztcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuZXhwb3J0IHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuZXhwb3J0IHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuZXhwb3J0IHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuZXhwb3J0IHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuZXhwb3J0IHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuZXhwb3J0IHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuZXhwb3J0IHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuIiwiaW1wb3J0IHsgbm9ybWFsaXplVW5pdHMgfSBmcm9tICcuLi91bml0cy9hbGlhc2VzJztcbmltcG9ydCBhYnNGbG9vciBmcm9tICcuLi91dGlscy9hYnMtZmxvb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0ICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgfTtcbn1cblxuZXhwb3J0IHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbmV4cG9ydCB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuZXhwb3J0IHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG5leHBvcnQgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG5leHBvcnQgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbmV4cG9ydCB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG5leHBvcnQgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4vY3JlYXRlJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciB0aHJlc2hvbGRzID0ge1xuICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG59O1xuXG4vLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICBhWzRdID0gbG9jYWxlO1xuICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgIH1cbiAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cbiIsImltcG9ydCBhYnNGbG9vciBmcm9tICcuLi91dGlscy9hYnMtZmxvb3InO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgc2Vjb25kcyA9IGFicyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzKHRoaXMuX2RheXMpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBhYnModGhpcy5fbW9udGhzKTtcbiAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBzZWNvbmRzICU9IDYwO1xuICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICB2YXIgWSA9IHllYXJzO1xuICAgIHZhciBNID0gbW9udGhzO1xuICAgIHZhciBEID0gZGF5cztcbiAgICB2YXIgaCA9IGhvdXJzO1xuICAgIHZhciBtID0gbWludXRlcztcbiAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgIHJldHVybiAnUDBEJztcbiAgICB9XG5cbiAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICdQJyArXG4gICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgIChEID8gRCArICdEJyA6ICcnKSArXG4gICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgKG0gPyBtICsgJ00nIDogJycpICtcbiAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xufVxuIiwiaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL2NvbnN0cnVjdG9yJztcblxudmFyIHByb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG5pbXBvcnQgeyBhYnMgfSBmcm9tICcuL2Ficyc7XG5pbXBvcnQgeyBhZGQsIHN1YnRyYWN0IH0gZnJvbSAnLi9hZGQtc3VidHJhY3QnO1xuaW1wb3J0IHsgYXMsIGFzTWlsbGlzZWNvbmRzLCBhc1NlY29uZHMsIGFzTWludXRlcywgYXNIb3VycywgYXNEYXlzLCBhc1dlZWtzLCBhc01vbnRocywgYXNZZWFycywgdmFsdWVPZiB9IGZyb20gJy4vYXMnO1xuaW1wb3J0IHsgYnViYmxlIH0gZnJvbSAnLi9idWJibGUnO1xuaW1wb3J0IHsgZ2V0LCBtaWxsaXNlY29uZHMsIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCBkYXlzLCBtb250aHMsIHllYXJzLCB3ZWVrcyB9IGZyb20gJy4vZ2V0JztcbmltcG9ydCB7IGh1bWFuaXplIH0gZnJvbSAnLi9odW1hbml6ZSc7XG5pbXBvcnQgeyB0b0lTT1N0cmluZyB9IGZyb20gJy4vaXNvLXN0cmluZyc7XG5pbXBvcnQgeyBsYW5nLCBsb2NhbGUsIGxvY2FsZURhdGEgfSBmcm9tICcuLi9tb21lbnQvbG9jYWxlJztcbmltcG9ydCB7IGlzVmFsaWQgfSBmcm9tICcuL3ZhbGlkJztcblxucHJvdG8uaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkO1xucHJvdG8uYWJzICAgICAgICAgICAgPSBhYnM7XG5wcm90by5hZGQgICAgICAgICAgICA9IGFkZDtcbnByb3RvLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3Q7XG5wcm90by5hcyAgICAgICAgICAgICA9IGFzO1xucHJvdG8uYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbnByb3RvLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xucHJvdG8uYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG5wcm90by5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG5wcm90by5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbnByb3RvLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbnByb3RvLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG5wcm90by5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG5wcm90by52YWx1ZU9mICAgICAgICA9IHZhbHVlT2Y7XG5wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbnByb3RvLmdldCAgICAgICAgICAgID0gZ2V0O1xucHJvdG8ubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG5wcm90by5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG5wcm90by5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG5wcm90by5ob3VycyAgICAgICAgICA9IGhvdXJzO1xucHJvdG8uZGF5cyAgICAgICAgICAgPSBkYXlzO1xucHJvdG8ud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbnByb3RvLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xucHJvdG8ueWVhcnMgICAgICAgICAgPSB5ZWFycztcbnByb3RvLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG5wcm90by50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nO1xucHJvdG8udG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbnByb3RvLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmc7XG5wcm90by5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbnByb3RvLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuLy8gRGVwcmVjYXRpb25zXG5pbXBvcnQgeyBkZXByZWNhdGUgfSBmcm9tICcuLi91dGlscy9kZXByZWNhdGUnO1xuXG5wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyk7XG5wcm90by5sYW5nID0gbGFuZztcbiIsIi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbmltcG9ydCAnLi9wcm90b3R5cGUnO1xuXG5pbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4vY3JlYXRlJztcbmltcG9ydCB7IGlzRHVyYXRpb24gfSBmcm9tICcuL2NvbnN0cnVjdG9yJztcbmltcG9ydCB7XG4gICAgZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcsXG4gICAgZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkXG59IGZyb20gJy4vaHVtYW5pemUnO1xuXG5leHBvcnQge1xuICAgIGNyZWF0ZUR1cmF0aW9uLFxuICAgIGlzRHVyYXRpb24sXG4gICAgZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcsXG4gICAgZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkXG59O1xuIiwiaW1wb3J0IHsgYWRkRm9ybWF0VG9rZW4gfSBmcm9tICcuLi9mb3JtYXQvZm9ybWF0JztcbmltcG9ydCB7IGFkZFJlZ2V4VG9rZW4sIG1hdGNoVGltZXN0YW1wLCBtYXRjaFNpZ25lZCB9IGZyb20gJy4uL3BhcnNlL3JlZ2V4JztcbmltcG9ydCB7IGFkZFBhcnNlVG9rZW4gfSBmcm9tICcuLi9wYXJzZS90b2tlbic7XG5pbXBvcnQgdG9JbnQgZnJvbSAnLi4vdXRpbHMvdG8taW50JztcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG5hZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG5hZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xufSk7XG4iLCIvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5pbXBvcnQgJy4vZGF5LW9mLW1vbnRoJztcbmltcG9ydCAnLi9kYXktb2Ytd2Vlayc7XG5pbXBvcnQgJy4vZGF5LW9mLXllYXInO1xuaW1wb3J0ICcuL2hvdXInO1xuaW1wb3J0ICcuL21pbGxpc2Vjb25kJztcbmltcG9ydCAnLi9taW51dGUnO1xuaW1wb3J0ICcuL21vbnRoJztcbmltcG9ydCAnLi9vZmZzZXQnO1xuaW1wb3J0ICcuL3F1YXJ0ZXInO1xuaW1wb3J0ICcuL3NlY29uZCc7XG5pbXBvcnQgJy4vdGltZXN0YW1wJztcbmltcG9ydCAnLi90aW1lem9uZSc7XG5pbXBvcnQgJy4vd2Vlay15ZWFyJztcbmltcG9ydCAnLi93ZWVrJztcbmltcG9ydCAnLi95ZWFyJztcblxuaW1wb3J0IHsgbm9ybWFsaXplVW5pdHMgfSBmcm9tICcuL2FsaWFzZXMnO1xuXG5leHBvcnQgeyBub3JtYWxpemVVbml0cyB9O1xuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjE4LjFcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG5pbXBvcnQgeyBob29rcyBhcyBtb21lbnQsIHNldEhvb2tDYWxsYmFjayB9IGZyb20gJy4vbGliL3V0aWxzL2hvb2tzJztcblxubW9tZW50LnZlcnNpb24gPSAnMi4xOC4xJztcblxuaW1wb3J0IHtcbiAgICBtaW4sXG4gICAgbWF4LFxuICAgIG5vdyxcbiAgICBpc01vbWVudCxcbiAgICBtb21lbnRQcm90b3R5cGUgYXMgZm4sXG4gICAgY3JlYXRlVVRDICAgICAgIGFzIHV0YyxcbiAgICBjcmVhdGVVbml4ICAgICAgYXMgdW5peCxcbiAgICBjcmVhdGVMb2NhbCAgICAgYXMgbG9jYWwsXG4gICAgY3JlYXRlSW52YWxpZCAgIGFzIGludmFsaWQsXG4gICAgY3JlYXRlSW5ab25lICAgIGFzIHBhcnNlWm9uZVxufSBmcm9tICcuL2xpYi9tb21lbnQvbW9tZW50JztcblxuaW1wb3J0IHtcbiAgICBnZXRDYWxlbmRhckZvcm1hdFxufSBmcm9tICcuL2xpYi9tb21lbnQvY2FsZW5kYXInO1xuXG5pbXBvcnQge1xuICAgIGRlZmluZUxvY2FsZSxcbiAgICB1cGRhdGVMb2NhbGUsXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlIGFzIGxvY2FsZSxcbiAgICBnZXRMb2NhbGUgICAgICAgICAgYXMgbG9jYWxlRGF0YSxcbiAgICBsaXN0TG9jYWxlcyAgICAgICAgYXMgbG9jYWxlcyxcbiAgICBsaXN0TW9udGhzICAgICAgICAgYXMgbW9udGhzLFxuICAgIGxpc3RNb250aHNTaG9ydCAgICBhcyBtb250aHNTaG9ydCxcbiAgICBsaXN0V2Vla2RheXMgICAgICAgYXMgd2Vla2RheXMsXG4gICAgbGlzdFdlZWtkYXlzTWluICAgIGFzIHdlZWtkYXlzTWluLFxuICAgIGxpc3RXZWVrZGF5c1Nob3J0ICBhcyB3ZWVrZGF5c1Nob3J0XG59IGZyb20gJy4vbGliL2xvY2FsZS9sb2NhbGUnO1xuXG5pbXBvcnQge1xuICAgIGlzRHVyYXRpb24sXG4gICAgY3JlYXRlRHVyYXRpb24gYXMgZHVyYXRpb24sXG4gICAgZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgYXMgcmVsYXRpdmVUaW1lUm91bmRpbmcsXG4gICAgZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkIGFzIHJlbGF0aXZlVGltZVRocmVzaG9sZFxufSBmcm9tICcuL2xpYi9kdXJhdGlvbi9kdXJhdGlvbic7XG5cbmltcG9ydCB7IG5vcm1hbGl6ZVVuaXRzIH0gZnJvbSAnLi9saWIvdW5pdHMvdW5pdHMnO1xuXG5pbXBvcnQgaXNEYXRlIGZyb20gJy4vbGliL3V0aWxzL2lzLWRhdGUnO1xuXG5zZXRIb29rQ2FsbGJhY2sobG9jYWwpO1xuXG5tb21lbnQuZm4gICAgICAgICAgICAgICAgICAgID0gZm47XG5tb21lbnQubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xubW9tZW50Lm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbm1vbWVudC5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG5tb21lbnQudXRjICAgICAgICAgICAgICAgICAgID0gdXRjO1xubW9tZW50LnVuaXggICAgICAgICAgICAgICAgICA9IHVuaXg7XG5tb21lbnQubW9udGhzICAgICAgICAgICAgICAgID0gbW9udGhzO1xubW9tZW50LmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbm1vbWVudC5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGU7XG5tb21lbnQuaW52YWxpZCAgICAgICAgICAgICAgID0gaW52YWxpZDtcbm1vbWVudC5kdXJhdGlvbiAgICAgICAgICAgICAgPSBkdXJhdGlvbjtcbm1vbWVudC5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbm1vbWVudC53ZWVrZGF5cyAgICAgICAgICAgICAgPSB3ZWVrZGF5cztcbm1vbWVudC5wYXJzZVpvbmUgICAgICAgICAgICAgPSBwYXJzZVpvbmU7XG5tb21lbnQubG9jYWxlRGF0YSAgICAgICAgICAgID0gbG9jYWxlRGF0YTtcbm1vbWVudC5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xubW9tZW50Lm1vbnRoc1Nob3J0ICAgICAgICAgICA9IG1vbnRoc1Nob3J0O1xubW9tZW50LndlZWtkYXlzTWluICAgICAgICAgICA9IHdlZWtkYXlzTWluO1xubW9tZW50LmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbm1vbWVudC51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG5tb21lbnQubG9jYWxlcyAgICAgICAgICAgICAgID0gbG9jYWxlcztcbm1vbWVudC53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSB3ZWVrZGF5c1Nob3J0O1xubW9tZW50Lm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xubW9tZW50LnJlbGF0aXZlVGltZVJvdW5kaW5nID0gcmVsYXRpdmVUaW1lUm91bmRpbmc7XG5tb21lbnQucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gcmVsYXRpdmVUaW1lVGhyZXNob2xkO1xubW9tZW50LmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xubW9tZW50LnByb3RvdHlwZSAgICAgICAgICAgICA9IGZuO1xuXG5leHBvcnQgZGVmYXVsdCBtb21lbnQ7XG4iLCIvKiogQGpzeCBjcmVhdGVFbGVtZW50ICovXG5pbXBvcnQgQXNDdXN0b21FbGVtZW50IGZyb20gJy4uL2RvbS9Bc0N1c3RvbUVsZW1lbnQnO1xuaW1wb3J0IGluZmVybm9UcmVlUmVuZGVyZXIsIHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vZG9tL2luZmVybm9UcmVlUmVuZGVyZXInO1xuXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5cbmltcG9ydCBkZWJ1Z0ZuIGZyb20gJy4uL2RlYnVnJztcbmNvbnN0IGRlYnVnID0gZGVidWdGbignc2xpZGVzJyk7XG5cbmNsYXNzIFRyYWNrUGxhbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGFzdFRyYWNrTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgfVxuXG4gICAgYWRkKGVsKSB7XG4gICAgICAgIGxldCB0cmFja05hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3RyYWNrJyk7XG4gICAgICAgIGlmICh0cmFja05hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNrTmFtZSA9IHRoaXMubGFzdFRyYWNrTmFtZSA/IFN0cmluZy5mcm9tQ29kZVBvaW50KHRyYWNrTmFtZS5jb2RlUG9pbnRBdCgwKSArIDEpIDogJ2EnO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrTmFtZSA9IHRyYWNrTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmxhc3RUcmFja05hbWUgPSB0cmFja05hbWU7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gfHwgW107XG5cbiAgICAgICAgdHJhY2sucHVzaChlbCk7XG4gICAgfVxuXG4gICAgZm9yRWFjaENvbHVtbihmbikge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykuZm9yRWFjaCgodHJhY2tOYW1lKSA9PiB7XG4gICAgICAgICAgICBmbih0cmFja05hbWUsIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IHRpbWVyU3ltYm9sID0gU3ltYm9sKCk7XG5cbkBBc0N1c3RvbUVsZW1lbnQoe1xuXHR0YWc6ICdmbG93LXNsaWRlcycsIFxuICAgIHRyZWVSZW5kZXJlcjogaW5mZXJub1RyZWVSZW5kZXJlcixcbiAgICBjb25uZWN0ZWRDYWxsYmFjayhlbCwgcHJvcHMpIHtcbiAgICAgICAgY29uc3Qgc2VlZGVycyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2VlZC1zbGlkZXMnKSk7XG4gICAgICAgIGNvbnN0IHBsYW4gPSBuZXcgVHJhY2tQbGFuKCk7XG5cbiAgICAgICAgc2VlZGVycy5mb3JFYWNoKChzZWVkZXIpID0+IHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oc2VlZGVyLmNoaWxkcmVuKS5mb3JFYWNoKChzbGlkZUNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBwbGFuLmFkZChzbGlkZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHNsaWRlQ29udGVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNsaWRlQ29udGVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGxhbi5mb3JFYWNoQ29sdW1uKCh0cmFjaywgZWxlbWVudHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zsb3ctY29sdW1uJyk7XG4gICAgICAgICAgICBjb2x1bW4uY2xhc3NMaXN0LmFkZCgnZmxvdy1zbGlkZXNfX2NvbHVtbicpO1xuICAgICAgICAgICAgY29sdW1uLmNsYXNzTGlzdC5hZGQoYGZsb3ctc2xpZGVzX19jb2x1bW4tJHt0cmFja31gKTtcbiAgICAgICAgICAgIGlmICh0cmFjayA9PT0gJ2InKSBjb2x1bW4uc3R5bGUub3JkZXIgPSAnLTEnO1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbGlkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zsb3ctc2xpZGUnKTtcbiAgICAgICAgICAgICAgICBzbGlkZS5jbGFzc0xpc3QuYWRkKCdmbG93LXNsaWRlc19fc2xpZGUnKTtcbiAgICAgICAgICAgICAgICBzbGlkZS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgY29sdW1uLmFwcGVuZENoaWxkKHNsaWRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY29sdW1uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gMyBjb2x1bW5zIGFyZSBhZGRlZCBidXQgdGhlIG1pZGRlbCBkaXNhcHBlYXJzPz8/XG5cbiAgICAgICAgbGV0IGFuaW1hdGluZztcbiAgICAgICAgbGV0IHJ1bnMgPSAwO1xuXG4gICAgICAgIGNvbnN0IGFuaW1hdGVOZXh0Q29sdW1uID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gc2hvdyBtdWNoIGxlc3MgYWZ0ZXIgMTIgYW5pbWF0aW9uc1xuICAgICAgICAgICAgaWYgKHJ1bnMgPiAxMiAmJiAocnVucyAlIDUpICE9IDApIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGFuaW1hdGluZykgYW5pbWF0aW5nLmNsYXNzTGlzdC5yZW1vdmUoJ2Zsb3ctc2xpZGVzX19hbmltYXRpbmcnKTtcbiAgICAgICAgICAgIGFuaW1hdGluZyA9IChhbmltYXRpbmcgJiYgYW5pbWF0aW5nLm5leHRFbGVtZW50U2libGluZykgfHwgZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICBhbmltYXRpbmcuY2xhc3NMaXN0LmFkZCgnZmxvdy1zbGlkZXNfX2FuaW1hdGluZycpO1xuICAgICAgICAgICAgKytydW5zO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFuaW1hdGVOZXh0Q29sdW1uKCk7XG4gICAgICAgIHNldEludGVydmFsKGFuaW1hdGVOZXh0Q29sdW1uLCAxMCAqIDEwMDApO1xuICAgIH0sXG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayhlbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGVsW3RpbWVyU3ltYm9sXSk7XG4gICAgfSxcbn0pXG5cbmV4cG9ydCBjbGFzcyBGbG93U2xpZGVzIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGV0aW1lOiB7IHR5cGU6IERhdGUsIGF0dHJpYnV0ZTogdHJ1ZSwgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgZm9ybWF0OiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2RkZGQsIE1NTU0gRG8gWVlZWSwgaGg6bW0nIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiLyoqIEBqc3ggY3JlYXRlRWxlbWVudCAqL1xuaW1wb3J0IEFzQ3VzdG9tRWxlbWVudCBmcm9tICcuLi9kb20vQXNDdXN0b21FbGVtZW50JztcbmltcG9ydCBpbmZlcm5vVHJlZVJlbmRlcmVyLCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL2RvbS9pbmZlcm5vVHJlZVJlbmRlcmVyJztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcblxubW9tZW50LmxvY2FsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyB8fCAnZW4nKTtcblxuY29uc3QgdGltZXJTeW1ib2wgPSBTeW1ib2woKTtcblxuQEFzQ3VzdG9tRWxlbWVudCh7XG5cdHRhZzogJ2Zsb3ctdGltZScsIFxuICAgIHRyZWVSZW5kZXJlcjogaW5mZXJub1RyZWVSZW5kZXJlcixcbn0pXG5leHBvcnQgY2xhc3MgRmxvd1RpbWUgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZXRpbWU6IHsgdHlwZTogRGF0ZSwgYXR0cmlidXRlOiB0cnVlLCBkZWZhdWx0OiBudWxsfSwgXG4gICAgICAgICAgICBmb3JtYXQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnZGRkZCwgTU1NTSBEbyBZWVlZLCBISDptbScgfSxcbiAgICAgICAgICAgIHNob3dVdGM6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9LFxuICAgICAgICAgICAgLy9UT0RPIGNoaWxkcmVuIHsgY2hpbGRyZW5mb3JtYXQ6ICdqc29ubWwnfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJlbmRlcihwcm9wcykge1xuICAgICAgICBpZiAoIXByb3BzLmRhdGV0aW1lKSByZXR1cm4gcHJvcHMub3JpZ2luYWxDaGlsZHJlbjtcbiAgICAgICAgcmV0dXJuIHByb3BzLnNob3dVdGMgPyBtb21lbnQocHJvcHMuZGF0ZXRpbWUpLnV0YygpLmZvcm1hdChwcm9wcy5mb3JtYXQpIDogbW9tZW50KHByb3BzLmRhdGV0aW1lKS5mb3JtYXQocHJvcHMuZm9ybWF0KTtcbiAgICB9XG59XG4iLCJ2YXIgaW5kZXggPSB0eXBlb2YgU3ltYm9sID09PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuXHRyZXR1cm4gJ0AnICsgKGRlc2NyaXB0aW9uIHx8ICdAJykgKyBNYXRoLnJhbmRvbSgpO1xufSA6IFN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7IiwiLyohIG5wbS5pbS9pbnRlcnZhbG9tZXRlciAqL1xuZnVuY3Rpb24gaW50ZXJ2YWxvbWV0ZXIoY2IsIHJlcXVlc3QsIGNhbmNlbCwgcmVxdWVzdFBhcmFtZXRlcikge1xuXHR2YXIgcmVxdWVzdElkO1xuXHR2YXIgcHJldmlvdXNMb29wVGltZTtcblx0ZnVuY3Rpb24gbG9vcChub3cpIHtcblx0XHQvLyBtdXN0IGJlIHJlcXVlc3RlZCBiZWZvcmUgY2IoKSBiZWNhdXNlIHRoYXQgbWlnaHQgY2FsbCAuc3RvcCgpXG5cdFx0cmVxdWVzdElkID0gcmVxdWVzdChsb29wLCByZXF1ZXN0UGFyYW1ldGVyKTtcblxuXHRcdC8vIGNhbGxlZCB3aXRoIFwibXMgc2luY2UgbGFzdCBjYWxsXCIuIDAgb24gc3RhcnQoKVxuXHRcdGNiKG5vdyAtIChwcmV2aW91c0xvb3BUaW1lIHx8IG5vdykpO1xuXG5cdFx0cHJldmlvdXNMb29wVGltZSA9IG5vdztcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcblx0XHRcdGlmICghcmVxdWVzdElkKSB7IC8vIHByZXZlbnQgZG91YmxlIHN0YXJ0c1xuXHRcdFx0XHRsb29wKDApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRcdGNhbmNlbChyZXF1ZXN0SWQpO1xuXHRcdFx0cmVxdWVzdElkID0gbnVsbDtcblx0XHRcdHByZXZpb3VzTG9vcFRpbWUgPSAwO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gZnJhbWVJbnRlcnZhbG9tZXRlcihjYikge1xuXHRyZXR1cm4gaW50ZXJ2YWxvbWV0ZXIoY2IsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUpO1xufVxuXG5mdW5jdGlvbiB0aW1lckludGVydmFsb21ldGVyKGNiLCBkZWxheSkge1xuXHRyZXR1cm4gaW50ZXJ2YWxvbWV0ZXIoY2IsIHNldFRpbWVvdXQsIGNsZWFyVGltZW91dCwgZGVsYXkpO1xufVxuXG5leHBvcnQgeyBpbnRlcnZhbG9tZXRlciwgZnJhbWVJbnRlcnZhbG9tZXRlciwgdGltZXJJbnRlcnZhbG9tZXRlciB9OyIsIi8qISBucG0uaW0vaXBob25lLWlubGluZS12aWRlbyAqL1xuaW1wb3J0IFN5bWJvbCBmcm9tICdwb29yLW1hbnMtc3ltYm9sJztcbmltcG9ydCB7IGZyYW1lSW50ZXJ2YWxvbWV0ZXIgfSBmcm9tICdpbnRlcnZhbG9tZXRlcic7XG5cbmZ1bmN0aW9uIHByZXZlbnRFdmVudChlbGVtZW50LCBldmVudE5hbWUsIHRvZ2dsZVByb3BlcnR5LCBwcmV2ZW50V2l0aFByb3BlcnR5KSB7XG5cdGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuXHRcdGlmIChCb29sZWFuKGVsZW1lbnRbdG9nZ2xlUHJvcGVydHldKSA9PT0gQm9vbGVhbihwcmV2ZW50V2l0aFByb3BlcnR5KSkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGV2ZW50TmFtZSwgJ3ByZXZlbnRlZCBvbicsIGVsZW1lbnQpO1xuXHRcdH1cblx0XHRkZWxldGUgZWxlbWVudFt0b2dnbGVQcm9wZXJ0eV07XG5cdH1cblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdC8vIFJldHVybiBoYW5kbGVyIHRvIGFsbG93IHRvIGRpc2FibGUgdGhlIHByZXZlbnRpb24uIFVzYWdlOlxuXHQvLyBjb25zdCBwcmV2ZW50aW9uSGFuZGxlciA9IHByZXZlbnRFdmVudChlbCwgJ2NsaWNrJyk7XG5cdC8vIGVsLnJlbW92ZUV2ZW50SGFuZGxlcignY2xpY2snLCBwcmV2ZW50aW9uSGFuZGxlcik7XG5cdHJldHVybiBoYW5kbGVyO1xufVxuXG5mdW5jdGlvbiBwcm94eVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHlOYW1lLCBzb3VyY2VPYmplY3QsIGNvcHlGaXJzdCkge1xuXHRmdW5jdGlvbiBnZXQoKSB7XG5cdFx0cmV0dXJuIHNvdXJjZU9iamVjdFtwcm9wZXJ0eU5hbWVdO1xuXHR9XG5cdGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuXHRcdHNvdXJjZU9iamVjdFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG5cdH1cblxuXHRpZiAoY29weUZpcnN0KSB7XG5cdFx0c2V0KG9iamVjdFtwcm9wZXJ0eU5hbWVdKTtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwge2dldDogZ2V0LCBzZXQ6IHNldH0pO1xufVxuXG5mdW5jdGlvbiBwcm94eUV2ZW50KG9iamVjdCwgZXZlbnROYW1lLCBzb3VyY2VPYmplY3QpIHtcblx0c291cmNlT2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmplY3QuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoZXZlbnROYW1lKSk7IH0pO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50QXN5bmMoZWxlbWVudCwgdHlwZSkge1xuXHRQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KHR5cGUpKTtcblx0fSk7XG59XG5cbi8vIGlPUyAxMCBhZGRzIHN1cHBvcnQgZm9yIG5hdGl2ZSBpbmxpbmUgcGxheWJhY2sgKyBzaWxlbnQgYXV0b3BsYXlcbnZhciBpc1doaXRlbGlzdGVkID0gJ29iamVjdC1maXQnIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgJiYgL2lQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhbWF0Y2hNZWRpYSgnKC13ZWJraXQtdmlkZW8tcGxheWFibGUtaW5saW5lKScpLm1hdGNoZXM7XG5cbnZhciDgsqAgPSBTeW1ib2woKTtcbnZhciDgsqBldmVudCA9IFN5bWJvbCgpO1xudmFyIOCyoHBsYXkgPSBTeW1ib2woJ25hdGl2ZXBsYXknKTtcbnZhciDgsqBwYXVzZSA9IFN5bWJvbCgnbmF0aXZlcGF1c2UnKTtcblxuLyoqXG4gKiBVVElMU1xuICovXG5cbmZ1bmN0aW9uIGdldEF1ZGlvRnJvbVZpZGVvKHZpZGVvKSB7XG5cdHZhciBhdWRpbyA9IG5ldyBBdWRpbygpO1xuXHRwcm94eUV2ZW50KHZpZGVvLCAncGxheScsIGF1ZGlvKTtcblx0cHJveHlFdmVudCh2aWRlbywgJ3BsYXlpbmcnLCBhdWRpbyk7XG5cdHByb3h5RXZlbnQodmlkZW8sICdwYXVzZScsIGF1ZGlvKTtcblx0YXVkaW8uY3Jvc3NPcmlnaW4gPSB2aWRlby5jcm9zc09yaWdpbjtcblxuXHQvLyAnZGF0YTonIGNhdXNlcyBhdWRpby5uZXR3b3JrU3RhdGUgPiAwXG5cdC8vIHdoaWNoIHRoZW4gYWxsb3dzIHRvIGtlZXAgPGF1ZGlvPiBpbiBhIHJlc3VtYWJsZSBwbGF5aW5nIHN0YXRlXG5cdC8vIGkuZS4gb25jZSB5b3Ugc2V0IGEgcmVhbCBzcmMgaXQgd2lsbCBrZWVwIHBsYXlpbmcgaWYgaXQgd2FzIGlmIC5wbGF5KCkgd2FzIGNhbGxlZFxuXHRhdWRpby5zcmMgPSB2aWRlby5zcmMgfHwgdmlkZW8uY3VycmVudFNyYyB8fCAnZGF0YTonO1xuXG5cdC8vIGlmIChhdWRpby5zcmMgPT09ICdkYXRhOicpIHtcblx0Ly8gICBUT0RPOiB3YWl0IGZvciB2aWRlbyB0byBiZSBzZWxlY3RlZFxuXHQvLyB9XG5cdHJldHVybiBhdWRpbztcbn1cblxudmFyIGxhc3RSZXF1ZXN0cyA9IFtdO1xudmFyIHJlcXVlc3RJbmRleCA9IDA7XG52YXIgbGFzdFRpbWV1cGRhdGVFdmVudDtcblxuZnVuY3Rpb24gc2V0VGltZSh2aWRlbywgdGltZSwgcmVtZW1iZXJPbmx5KSB7XG5cdC8vIGFsbG93IG9uZSB0aW1ldXBkYXRlIGV2ZW50IGV2ZXJ5IDIwMCsgbXNcblx0aWYgKChsYXN0VGltZXVwZGF0ZUV2ZW50IHx8IDApICsgMjAwIDwgRGF0ZS5ub3coKSkge1xuXHRcdHZpZGVvW+CyoGV2ZW50XSA9IHRydWU7XG5cdFx0bGFzdFRpbWV1cGRhdGVFdmVudCA9IERhdGUubm93KCk7XG5cdH1cblx0aWYgKCFyZW1lbWJlck9ubHkpIHtcblx0XHR2aWRlby5jdXJyZW50VGltZSA9IHRpbWU7XG5cdH1cblx0bGFzdFJlcXVlc3RzWysrcmVxdWVzdEluZGV4ICUgM10gPSB0aW1lICogMTAwIHwgMCAvIDEwMDtcbn1cblxuZnVuY3Rpb24gaXNQbGF5ZXJFbmRlZChwbGF5ZXIpIHtcblx0cmV0dXJuIHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUgPj0gcGxheWVyLnZpZGVvLmR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUodGltZURpZmYpIHtcblx0dmFyIHBsYXllciA9IHRoaXM7XG5cdC8vIGNvbnNvbGUubG9nKCd1cGRhdGUnLCBwbGF5ZXIudmlkZW8ucmVhZHlTdGF0ZSwgcGxheWVyLnZpZGVvLm5ldHdvcmtTdGF0ZSwgcGxheWVyLmRyaXZlci5yZWFkeVN0YXRlLCBwbGF5ZXIuZHJpdmVyLm5ldHdvcmtTdGF0ZSwgcGxheWVyLmRyaXZlci5wYXVzZWQpO1xuXHRpZiAocGxheWVyLnZpZGVvLnJlYWR5U3RhdGUgPj0gcGxheWVyLnZpZGVvLkhBVkVfRlVUVVJFX0RBVEEpIHtcblx0XHRpZiAoIXBsYXllci5oYXNBdWRpbykge1xuXHRcdFx0cGxheWVyLmRyaXZlci5jdXJyZW50VGltZSA9IHBsYXllci52aWRlby5jdXJyZW50VGltZSArICgodGltZURpZmYgKiBwbGF5ZXIudmlkZW8ucGxheWJhY2tSYXRlKSAvIDEwMDApO1xuXHRcdFx0aWYgKHBsYXllci52aWRlby5sb29wICYmIGlzUGxheWVyRW5kZWQocGxheWVyKSkge1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0c2V0VGltZShwbGF5ZXIudmlkZW8sIHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUpO1xuXHR9IGVsc2UgaWYgKHBsYXllci52aWRlby5uZXR3b3JrU3RhdGUgPT09IHBsYXllci52aWRlby5ORVRXT1JLX0lETEUgJiYgIXBsYXllci52aWRlby5idWZmZXJlZC5sZW5ndGgpIHtcblx0XHQvLyB0aGlzIHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgc291cmNlIGlzIGF2YWlsYWJsZSBidXQ6XG5cdFx0Ly8gLSBpdCdzIHBvdGVudGlhbGx5IHBsYXlpbmcgKC5wYXVzZWQgPT09IGZhbHNlKVxuXHRcdC8vIC0gaXQncyBub3QgcmVhZHkgdG8gcGxheVxuXHRcdC8vIC0gaXQncyBub3QgbG9hZGluZ1xuXHRcdC8vIElmIGl0IGhhc0F1ZGlvLCB0aGF0IHdpbGwgYmUgbG9hZGVkIGluIHRoZSAnZW1wdGllZCcgaGFuZGxlciBiZWxvd1xuXHRcdHBsYXllci52aWRlby5sb2FkKCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ1dpbGwgbG9hZCcpO1xuXHR9XG5cblx0Ly8gY29uc29sZS5hc3NlcnQocGxheWVyLnZpZGVvLmN1cnJlbnRUaW1lID09PSBwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lLCAnVmlkZW8gbm90IHVwZGF0aW5nIScpO1xuXG5cdGlmIChwbGF5ZXIudmlkZW8uZW5kZWQpIHtcblx0XHRkZWxldGUgcGxheWVyLnZpZGVvW+CyoGV2ZW50XTsgLy8gYWxsb3cgdGltZXVwZGF0ZSBldmVudFxuXHRcdHBsYXllci52aWRlby5wYXVzZSh0cnVlKTtcblx0fVxufVxuXG4vKipcbiAqIE1FVEhPRFNcbiAqL1xuXG5mdW5jdGlvbiBwbGF5KCkge1xuXHQvLyBjb25zb2xlLmxvZygncGxheScpO1xuXHR2YXIgdmlkZW8gPSB0aGlzO1xuXHR2YXIgcGxheWVyID0gdmlkZW9b4LKgXTtcblxuXHQvLyBpZiBpdCdzIGZ1bGxzY3JlZW4sIHVzZSB0aGUgbmF0aXZlIHBsYXllclxuXHRpZiAodmlkZW8ud2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4pIHtcblx0XHR2aWRlb1vgsqBwbGF5XSgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChwbGF5ZXIuZHJpdmVyLnNyYyAhPT0gJ2RhdGE6JyAmJiBwbGF5ZXIuZHJpdmVyLnNyYyAhPT0gdmlkZW8uc3JjKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coJ3NyYyBjaGFuZ2VkIG9uIHBsYXknLCB2aWRlby5zcmMpO1xuXHRcdHNldFRpbWUodmlkZW8sIDAsIHRydWUpO1xuXHRcdHBsYXllci5kcml2ZXIuc3JjID0gdmlkZW8uc3JjO1xuXHR9XG5cblx0aWYgKCF2aWRlby5wYXVzZWQpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0cGxheWVyLnBhdXNlZCA9IGZhbHNlO1xuXG5cdGlmICghdmlkZW8uYnVmZmVyZWQubGVuZ3RoKSB7XG5cdFx0Ly8gLmxvYWQoKSBjYXVzZXMgdGhlIGVtcHRpZWQgZXZlbnRcblx0XHQvLyB0aGUgYWx0ZXJuYXRpdmUgaXMgLnBsYXkoKSsucGF1c2UoKSBidXQgdGhhdCB0cmlnZ2VycyBwbGF5L3BhdXNlIGV2ZW50cywgZXZlbiB3b3JzZVxuXHRcdC8vIHBvc3NpYmx5IHRoZSBhbHRlcm5hdGl2ZSBpcyBwcmV2ZW50aW5nIHRoaXMgZXZlbnQgb25seSBvbmNlXG5cdFx0dmlkZW8ubG9hZCgpO1xuXHR9XG5cblx0cGxheWVyLmRyaXZlci5wbGF5KCk7XG5cdHBsYXllci51cGRhdGVyLnN0YXJ0KCk7XG5cblx0aWYgKCFwbGF5ZXIuaGFzQXVkaW8pIHtcblx0XHRkaXNwYXRjaEV2ZW50QXN5bmModmlkZW8sICdwbGF5Jyk7XG5cdFx0aWYgKHBsYXllci52aWRlby5yZWFkeVN0YXRlID49IHBsYXllci52aWRlby5IQVZFX0VOT1VHSF9EQVRBKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnb25wbGF5Jyk7XG5cdFx0XHRkaXNwYXRjaEV2ZW50QXN5bmModmlkZW8sICdwbGF5aW5nJyk7XG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiBwYXVzZShmb3JjZUV2ZW50cykge1xuXHQvLyBjb25zb2xlLmxvZygncGF1c2UnKTtcblx0dmFyIHZpZGVvID0gdGhpcztcblx0dmFyIHBsYXllciA9IHZpZGVvW+CyoF07XG5cblx0cGxheWVyLmRyaXZlci5wYXVzZSgpO1xuXHRwbGF5ZXIudXBkYXRlci5zdG9wKCk7XG5cblx0Ly8gaWYgaXQncyBmdWxsc2NyZWVuLCB0aGUgZGV2ZWxvcGVyIHRoZSBuYXRpdmUgcGxheWVyLnBhdXNlKClcblx0Ly8gVGhpcyBpcyBhdCB0aGUgZW5kIG9mIHBhdXNlKCkgYmVjYXVzZSBpdCBhbHNvXG5cdC8vIG5lZWRzIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBzaW11bGF0aW9uIGlzIHBhdXNlZFxuXHRpZiAodmlkZW8ud2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4pIHtcblx0XHR2aWRlb1vgsqBwYXVzZV0oKTtcblx0fVxuXG5cdGlmIChwbGF5ZXIucGF1c2VkICYmICFmb3JjZUV2ZW50cykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHBsYXllci5wYXVzZWQgPSB0cnVlO1xuXHRpZiAoIXBsYXllci5oYXNBdWRpbykge1xuXHRcdGRpc3BhdGNoRXZlbnRBc3luYyh2aWRlbywgJ3BhdXNlJyk7XG5cdH1cblx0aWYgKHZpZGVvLmVuZGVkKSB7XG5cdFx0dmlkZW9b4LKgZXZlbnRdID0gdHJ1ZTtcblx0XHRkaXNwYXRjaEV2ZW50QXN5bmModmlkZW8sICdlbmRlZCcpO1xuXHR9XG59XG5cbi8qKlxuICogU0VUVVBcbiAqL1xuXG5mdW5jdGlvbiBhZGRQbGF5ZXIodmlkZW8sIGhhc0F1ZGlvKSB7XG5cdHZhciBwbGF5ZXIgPSB2aWRlb1vgsqBdID0ge307XG5cdHBsYXllci5wYXVzZWQgPSB0cnVlOyAvLyB0cmFjayB3aGV0aGVyICdwYXVzZScgZXZlbnRzIGhhdmUgYmVlbiBmaXJlZFxuXHRwbGF5ZXIuaGFzQXVkaW8gPSBoYXNBdWRpbztcblx0cGxheWVyLnZpZGVvID0gdmlkZW87XG5cdHBsYXllci51cGRhdGVyID0gZnJhbWVJbnRlcnZhbG9tZXRlcih1cGRhdGUuYmluZChwbGF5ZXIpKTtcblxuXHRpZiAoaGFzQXVkaW8pIHtcblx0XHRwbGF5ZXIuZHJpdmVyID0gZ2V0QXVkaW9Gcm9tVmlkZW8odmlkZW8pO1xuXHR9IGVsc2Uge1xuXHRcdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXZpZGVvLnBhdXNlZCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnb25jYW5wbGF5Jyk7XG5cdFx0XHRcdGRpc3BhdGNoRXZlbnRBc3luYyh2aWRlbywgJ3BsYXlpbmcnKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRwbGF5ZXIuZHJpdmVyID0ge1xuXHRcdFx0c3JjOiB2aWRlby5zcmMgfHwgdmlkZW8uY3VycmVudFNyYyB8fCAnZGF0YTonLFxuXHRcdFx0bXV0ZWQ6IHRydWUsXG5cdFx0XHRwYXVzZWQ6IHRydWUsXG5cdFx0XHRwYXVzZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLnBhdXNlZCA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0cGxheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLnBhdXNlZCA9IGZhbHNlO1xuXHRcdFx0XHQvLyBtZWRpYSBhdXRvbWF0aWNhbGx5IGdvZXMgdG8gMCBpZiAucGxheSgpIGlzIGNhbGxlZCB3aGVuIGl0J3MgZG9uZVxuXHRcdFx0XHRpZiAoaXNQbGF5ZXJFbmRlZChwbGF5ZXIpKSB7XG5cdFx0XHRcdFx0c2V0VGltZSh2aWRlbywgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXQgZW5kZWQoKSB7XG5cdFx0XHRcdHJldHVybiBpc1BsYXllckVuZGVkKHBsYXllcik7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIC5sb2FkKCkgY2F1c2VzIHRoZSBlbXB0aWVkIGV2ZW50XG5cdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coJ2RyaXZlciBzcmMgaXMnLCBwbGF5ZXIuZHJpdmVyLnNyYyk7XG5cdFx0dmFyIHdhc0VtcHR5ID0gIXBsYXllci5kcml2ZXIuc3JjIHx8IHBsYXllci5kcml2ZXIuc3JjID09PSAnZGF0YTonO1xuXHRcdGlmIChwbGF5ZXIuZHJpdmVyLnNyYyAmJiBwbGF5ZXIuZHJpdmVyLnNyYyAhPT0gdmlkZW8uc3JjKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnc3JjIGNoYW5nZWQgdG8nLCB2aWRlby5zcmMpO1xuXHRcdFx0c2V0VGltZSh2aWRlbywgMCwgdHJ1ZSk7XG5cdFx0XHRwbGF5ZXIuZHJpdmVyLnNyYyA9IHZpZGVvLnNyYztcblx0XHRcdC8vIHBsYXlpbmcgdmlkZW9zIHdpbGwgb25seSBrZWVwIHBsYXlpbmcgaWYgbm8gc3JjIHdhcyBwcmVzZW50IHdoZW4gLnBsYXkoKeKAmWVkXG5cdFx0XHRpZiAod2FzRW1wdHkpIHtcblx0XHRcdFx0cGxheWVyLmRyaXZlci5wbGF5KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwbGF5ZXIudXBkYXRlci5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCBmYWxzZSk7XG5cblx0Ly8gc3RvcCBwcm9ncmFtbWF0aWMgcGxheWVyIHdoZW4gT1MgdGFrZXMgb3ZlclxuXHR2aWRlby5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF2aWRlby5wYXVzZWQpIHtcblx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSA8YXVkaW8+IGFuZCB0aGUgc3luY2VyL3VwZGF0ZXIgYXJlIHN0b3BwZWRcblx0XHRcdHZpZGVvLnBhdXNlKCk7XG5cblx0XHRcdC8vIHBsYXkgdmlkZW8gbmF0aXZlbHlcblx0XHRcdHZpZGVvW+CyoHBsYXldKCk7XG5cdFx0fSBlbHNlIGlmIChoYXNBdWRpbyAmJiAhcGxheWVyLmRyaXZlci5idWZmZXJlZC5sZW5ndGgpIHtcblx0XHRcdC8vIGlmIHRoZSBmaXJzdCBwbGF5IGlzIG5hdGl2ZSxcblx0XHRcdC8vIHRoZSA8YXVkaW8+IG5lZWRzIHRvIGJlIGJ1ZmZlcmVkIG1hbnVhbGx5XG5cdFx0XHQvLyBzbyB3aGVuIHRoZSBmdWxsc2NyZWVuIGVuZHMsIGl0IGNhbiBiZSBzZXQgdG8gdGhlIHNhbWUgY3VycmVudCB0aW1lXG5cdFx0XHRwbGF5ZXIuZHJpdmVyLmxvYWQoKTtcblx0XHR9XG5cdH0pO1xuXHRpZiAoaGFzQXVkaW8pIHtcblx0XHR2aWRlby5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gc3luYyBhdWRpbyB0byBuZXcgdmlkZW8gcG9zaXRpb25cblx0XHRcdHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcblx0XHRcdC8vIGNvbnNvbGUuYXNzZXJ0KHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUgPT09IHZpZGVvLmN1cnJlbnRUaW1lLCAnQXVkaW8gbm90IHN5bmNlZCcpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gYWxsb3cgc2Vla2luZ1xuXHRcdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAobGFzdFJlcXVlc3RzLmluZGV4T2YodmlkZW8uY3VycmVudFRpbWUgKiAxMDAgfCAwIC8gMTAwKSA8IDApIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1VzZXItcmVxdWVzdGVkIHNlZWtpbmcnKTtcblx0XHRcdFx0cGxheWVyLmRyaXZlci5jdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG92ZXJsb2FkQVBJKHZpZGVvKSB7XG5cdHZhciBwbGF5ZXIgPSB2aWRlb1vgsqBdO1xuXHR2aWRlb1vgsqBwbGF5XSA9IHZpZGVvLnBsYXk7XG5cdHZpZGVvW+CyoHBhdXNlXSA9IHZpZGVvLnBhdXNlO1xuXHR2aWRlby5wbGF5ID0gcGxheTtcblx0dmlkZW8ucGF1c2UgPSBwYXVzZTtcblx0cHJveHlQcm9wZXJ0eSh2aWRlbywgJ3BhdXNlZCcsIHBsYXllci5kcml2ZXIpO1xuXHRwcm94eVByb3BlcnR5KHZpZGVvLCAnbXV0ZWQnLCBwbGF5ZXIuZHJpdmVyLCB0cnVlKTtcblx0cHJveHlQcm9wZXJ0eSh2aWRlbywgJ3BsYXliYWNrUmF0ZScsIHBsYXllci5kcml2ZXIsIHRydWUpO1xuXHRwcm94eVByb3BlcnR5KHZpZGVvLCAnZW5kZWQnLCBwbGF5ZXIuZHJpdmVyKTtcblx0cHJveHlQcm9wZXJ0eSh2aWRlbywgJ2xvb3AnLCBwbGF5ZXIuZHJpdmVyLCB0cnVlKTtcblx0cHJldmVudEV2ZW50KHZpZGVvLCAnc2Vla2luZycpO1xuXHRwcmV2ZW50RXZlbnQodmlkZW8sICdzZWVrZWQnKTtcblx0cHJldmVudEV2ZW50KHZpZGVvLCAndGltZXVwZGF0ZScsIOCyoGV2ZW50LCBmYWxzZSk7XG5cdHByZXZlbnRFdmVudCh2aWRlbywgJ2VuZGVkJywg4LKgZXZlbnQsIGZhbHNlKTsgLy8gcHJldmVudCBvY2Nhc2lvbmFsIG5hdGl2ZSBlbmRlZCBldmVudHNcbn1cblxuZnVuY3Rpb24gZW5hYmxlSW5saW5lVmlkZW8odmlkZW8sIGhhc0F1ZGlvLCBvbmx5V2hpdGVsaXN0ZWQpIHtcblx0aWYgKCBoYXNBdWRpbyA9PT0gdm9pZCAwICkgaGFzQXVkaW8gPSB0cnVlO1xuXHRpZiAoIG9ubHlXaGl0ZWxpc3RlZCA9PT0gdm9pZCAwICkgb25seVdoaXRlbGlzdGVkID0gdHJ1ZTtcblxuXHRpZiAoKG9ubHlXaGl0ZWxpc3RlZCAmJiAhaXNXaGl0ZWxpc3RlZCkgfHwgdmlkZW9b4LKgXSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRhZGRQbGF5ZXIodmlkZW8sIGhhc0F1ZGlvKTtcblx0b3ZlcmxvYWRBUEkodmlkZW8pO1xuXHR2aWRlby5jbGFzc0xpc3QuYWRkKCdJSVYnKTtcblx0aWYgKCFoYXNBdWRpbyAmJiB2aWRlby5hdXRvcGxheSkge1xuXHRcdHZpZGVvLnBsYXkoKTtcblx0fVxuXHRpZiAoIS9pUGhvbmV8aVBvZHxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpIHtcblx0XHRjb25zb2xlLndhcm4oJ2lwaG9uZS1pbmxpbmUtdmlkZW8gaXMgbm90IGd1YXJhbnRlZWQgdG8gd29yayBpbiBlbXVsYXRlZCBlbnZpcm9ubWVudHMnKTtcblx0fVxufVxuXG5lbmFibGVJbmxpbmVWaWRlby5pc1doaXRlbGlzdGVkID0gaXNXaGl0ZWxpc3RlZDtcblxuZXhwb3J0IGRlZmF1bHQgZW5hYmxlSW5saW5lVmlkZW87IiwiaW1wb3J0IG1ha2VWaWRlb1BsYXlhYmxlSW5saW5lIGZyb20gJ2lwaG9uZS1pbmxpbmUtdmlkZW8nO1xuaW1wb3J0IGRlYnVnRm4gZnJvbSAnLi4vZGVidWcnO1xuY29uc3QgZGVidWcgPSBkZWJ1Z0ZuKCdmbG93LXZpZGVvJyk7XG5cbi8qXG4gICAgdmlkZW8gd2lsbCBwbGF5IGF1dG9tYXRpY2FsbHkgbXV0ZWQgd2hlbiBwYWdlIGxvYWRzXG4gICAgdW5tdXRlIGJ1dHRvbiBpcyBzaG93blxuICAgIG9uY2UgcGxheWVkIGZpcnN0IHRpbWUgYSBwbGF5IGJ1dHRvbiBpcyBzaG93blxuICAgIHZpZGVvIG9ubHkgcGxheXMgd2hlbiB2aXNpYmxlIChzY3JvbGwgYW5kIHBhZ2UgdmlzaWJpbGl0eSlcblxuICAgIFZpZGVvIHNob3VsZCBiZSAqYXV0b3BsYXlpbmcqIHdoZW5cbiAgICAqIGluIHZpZXdcbiAgICAqIHdhcyBub3QgbWFudWFsbHkgcGF1c2VkIG9yIGVuZGVkXG5cbiAgICBWaWRlbyBzdGFydHMgcGxheWluZyBtdXRlZCB3aGVuIHBhZ2UgbG9hZHNcblxuXG4gICAgVE9ETyBPbmx5IHBsYXkgb25lIHZpZGVvIGF0IGEgdGltZSBpbiB0aGUgZmxvdy5cbiovXG5cbi8vVE9ETyBhY3RpdmF0ZS9kZWFjdGl2YXRlIHBhdXNlL2NvbnRpbnVlXG5cbi8vIGFjdGl2ZSBGbG93VmlldyBlbGVtZW50c1xudmFyIHZpZGVvcyA9IFtdO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZXYgPT4ge1xuICAgIHZpZGVvcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLmlzSW5WaWV3KCkgJiYgIWVsLnBsYXlpbmcpIGVsLnBsYXkoKTtcbiAgICAgICAgaWYgKCFlbC5pc0luVmlldygpICYmIGVsLnBsYXlpbmcpIGVsLnBhdXNlKCk7XG4gICAgfSk7XG59KTtcblxuLy8gaWYgbm90IHRvdWNoXG4vKlxuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldiA9PiB7XG4gICAgdmlkZW9zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBpZiAoZWwuY29udGFpbnMoZXYudGFyZ2V0KSkgZWwudW5tdXRlKCk7XG4gICAgICAgIGVsc2UgZWwubXV0ZSgpO1xuICAgIH0pO1xufSk7XG4qL1xuXG4vLyBTZXQgdGhlIG5hbWUgb2YgdGhlIGhpZGRlbiBwcm9wZXJ0eSBhbmQgdGhlIGNoYW5nZSBldmVudCBmb3IgdmlzaWJpbGl0eVxudmFyIGhpZGRlbkRvYywgdmlzaWJpbGl0eUNoYW5nZTtcbmlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuICE9PSBcInVuZGVmaW5lZFwiKSB7IC8vIE9wZXJhIDEyLjEwIGFuZCBGaXJlZm94IDE4IGFuZCBsYXRlciBzdXBwb3J0XG4gIGhpZGRlbkRvYyA9IFwiaGlkZGVuXCI7XG4gIHZpc2liaWxpdHlDaGFuZ2UgPSBcInZpc2liaWxpdHljaGFuZ2VcIjtcbn0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1zSGlkZGVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGhpZGRlbkRvYyA9IFwibXNIaWRkZW5cIjtcbiAgdmlzaWJpbGl0eUNoYW5nZSA9IFwibXN2aXNpYmlsaXR5Y2hhbmdlXCI7XG59IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgaGlkZGVuRG9jID0gXCJ3ZWJraXRIaWRkZW5cIjtcbiAgdmlzaWJpbGl0eUNoYW5nZSA9IFwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiO1xufVxuXG4vLyBIYW5kbGUgcGFnZSB2aXNpYmlsaXR5IGNoYW5nZVxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2aXNpYmlsaXR5Q2hhbmdlLCBmdW5jdGlvbihldikge1xuICAgIHZpZGVvcy5mb3JFYWNoKGVsID0+IHtcblxuICAgICAgICAvLyBJZiB0aGUgcGFnZSBpcyBoaWRkZW4sIHBhdXNlIHRoZSB2aWRlbztcbiAgICAgICAgLy8gaWYgdGhlIHBhZ2UgaXMgc2hvd24sIHBsYXkgdGhlIHZpZGVvXG4gICAgICAgIGlmIChkb2N1bWVudFtoaWRkZW5Eb2NdKSB7XG4gICAgICAgICAgZWwucGF1c2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbC5pc0luVmlldygpICYmICFlbC5wbGF5aW5nKSB7XG4gICAgICAgICAgZWwucGxheSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59LCBmYWxzZSk7XG5cbi8vVE9ETyB0YXAgdmlkZW8gb3ZlciBob3ZlciBpdCB0byBleHBvc2UgZXh0cmEgQ29udHJvbHNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxvd1ZpZGVvIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gICAgcGxheShldiwgaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgbGV0IHZpZGVvID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuXG4gICAgICAgIGlmICghdGhpcy5wbGF5aW5nICYmICh0aGlzLmF1dG9wbGF5aW5nIHx8IGludGVyYWN0aXZlKSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nID0gMTtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsYXlpbmcgPT09IDEpIHsgLy8gdW5sZXNzIHBhdXNlZCBpbmJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvLmN1cnJlbnRUaW1lID09PSB2aWRlby5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGl2ZSkgdGhpcy51bm11dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlpbmcgPSAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3BsYXlpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvcGxheWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdwbGF5aW5nIHZpZGVvJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXVzZShldiwgaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgbGV0IHZpZGVvID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuXG4gICAgICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBsYXlpbmcgPT09IDIpIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLnBsYXlpbmcgPSAwO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdwbGF5aW5nJyk7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZygncGF1c2VkIHZpZGVvJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdXRlKGV2LGludGVyYWN0aXZlKSB7XG4gICAgICAgIGxldCB2aWRlbyA9IHRoaXMucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgICAgICAgdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ211dGVkJyk7XG4gICAgICAgIGlmIChpbnRlcmFjdGl2ZSkgdGhpcy51c2VyTXV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHVubXV0ZShldixpbnRlcmFjdGl2ZSkge1xuICAgICAgICBsZXQgdmlkZW8gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgIC8vIGlmIHN0aWxsIGhvdmVyaW5nIGFmdGVyIGEgd2hpbGUgdW5tdXRlXG4gICAgICAgIHZpZGVvLm11dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnbXV0ZWQnKTtcbiAgICAgICAgaWYgKGludGVyYWN0aXZlKSB0aGlzLnVzZXJNdXRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBhdXRvcGxheWluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9wbGF5aW5nO1xuICAgIH1cblxuICAgIHNldCBhdXRvcGxheWluZyhhKSB7XG4gICAgICAgIHRoaXMuX2F1dG9wbGF5aW5nID0gYTtcbiAgICAgICAgaWYgKGEpIHRoaXMuY2xhc3NMaXN0LmFkZCgnYXV0b3BsYXlpbmcnKTtcbiAgICAgICAgZWxzZSB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2F1dG9wbGF5aW5nJyk7XG4gICAgfVxuXG4gICAgLy8gYXR0ciBmYXZvci1vbmNlID0gd2hlbiBzaG93biBmdWxseSBkb24ndCBzdGFydCBvdmVyXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMucGxheWluZyA9IDA7IC8vIDA9bm8sIDE9d2lsbC1wbGF5LCAyPXBsYXlpbmdcblxuICAgICAgICBsZXQgdmlkZW8gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgIGxldCBtYXJrZWRNdXRlID0gdmlkZW8ubXV0ZWQ7XG4gICAgICAgIHZpZGVvLnZvbHVtZSA9IDAuNTsgLy8gbm8gc28gbG91ZFxuXG4gICAgICAgIG1ha2VWaWRlb1BsYXlhYmxlSW5saW5lKHZpZGVvLG1hcmtlZE11dGUpO1xuXG4gICAgICAgIGlmIChtYXJrZWRNdXRlKSB0aGlzLmNsYXNzTGlzdC5hZGQoJ211dGVkJyk7XG5cbiAgICAgICAgLy9UT0RPIHBlcmhhcHMgdXNlIHJpb3Qub2JzZXJ2ZSh2aWRlbylcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBldiA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsYXlpbmcgPSAwO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdwbGF5aW5nJyk7XG4gICAgICAgICAgICB0aGlzLmF1dG9wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGV2ID0+IHtcbiAgICAgICAgICAgIHRoaXMucGxheWluZyA9IDA7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3BsYXlpbmcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGZsb3dCdXR0b25zID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbi5mbG93LWNvbnRyb2wnKSk7XG4gICAgICAgIGZsb3dCdXR0b25zLmZvckVhY2goY3RsID0+IHtcbiAgICAgICAgICAgIGN0bC50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFueSBidXR0b24gaW4gZmxvdy12aWRlbyBjYW4gaGF2ZSBhIGZsb3ctY29udHJvbCBhdHRyaWJ1dGVcbiAgICAgICAgY29uc3QgdGFwQnV0dG9uID0gZXYgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2LnRhcmdldC5jbG9zZXN0KCdidXR0b24nKTtcbiAgICAgICAgICAgIGlmIChidXR0b24pIHtcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2Zsb3ctY29udHJvbCcpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlIGluIHRoaXMpIHRoaXNbdHlwZV0oZXYsdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRhcEJ1dHRvbik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0YXBCdXR0b24pO1xuXG4gICAgICAgIC8vIGlmIGhvdmVyIHVubXV0ZSBvciBpZiB1bm11dGUgY2xpY2tlZFxuXG4gICAgICAgIC8vIHRyYWNrIG1hbnVhbCB2b2x1bWUgY2hhbmdlIHRvIHNldCB0aGUgbGV2ZWwgZm9yIHVubXV0ZVxuICAgICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZvbHVtZWNoYW5nZScpO1xuXG4gICAgICAgIHZpZGVvcy5wdXNoKHRoaXMpO1xuXG4gICAgICAgIC8vIHN0YXJ0cyBvdXQgYXV0b3BsYXlpbmdcbiAgICAgICAgdmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9wbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgLy9UT0RPIHBsYXkgaWYgaW4gdmlld1xuXG4gICAgICAgIC8vIGluaXRpYWxseSBubyBhdXRvcGxheSBvbmx5IHdoZW4gY29ubmVjdGVkXG4gICAgICAgIHZpZGVvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaXNJblZpZXcoKSkgdGhpcy5wbGF5KCk7XG4gICAgICAgIGVsc2UgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBsZXQgaWR4ID0gdmlkZW9zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpZHggPj0gMCkgdmlkZW9zLnNwbGljZShpZHgsMSk7XG4gICAgfVxuXG4gICAgaXNJblZpZXcoKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyB0YWtlcyBzY3JvbGwgaW50byBhY2NvdW50XG5cbiAgICAgICAgLy8gdGFiIHZpc2libGVcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY3QudG9wID49IDAgJiZcbiAgICAgICAgICAgIHJlY3QubGVmdCA+PSAwICYmXG4gICAgICAgICAgICByZWN0LmJvdHRvbSA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpICYmIC8qb3IgJCh3aW5kb3cpLmhlaWdodCgpICovXG4gICAgICAgICAgICByZWN0LnJpZ2h0IDw9ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpIC8qb3IgJCh3aW5kb3cpLndpZHRoKCkgKi9cbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCIvKiogQGpzeCBjcmVhdGVFbGVtZW50ICovXG5pbXBvcnQgQXNDdXN0b21FbGVtZW50IGZyb20gJy4uL2RvbS9Bc0N1c3RvbUVsZW1lbnQnO1xuaW1wb3J0IGluZmVybm9UcmVlUmVuZGVyZXIsIHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vZG9tL2luZmVybm9UcmVlUmVuZGVyZXInO1xuXG5AQXNDdXN0b21FbGVtZW50KHtcblx0dGFnOiAndHlwZWZvcm0tc2hhcmUtYnV0dG9uJywgXG4gICAgdHJlZVJlbmRlcmVyOiBpbmZlcm5vVHJlZVJlbmRlcmVyLFxufSlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVmb3JtU2hhcmVCdXR0b24gZXh0ZW5kcyBDb21wb25lbnQge1xuXG5cdFx0Lypcblx0XHQ8c2NyaXB0PlxuXHRcdFx0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBxcyxqcyxxLHMsZD1kb2N1bWVudCxnaT1kLmdldEVsZW1lbnRCeUlkLGNlPWQuY3JlYXRlRWxlbWVudCxcblx0XHRcdFx0Z3Q9ZC5nZXRFbGVtZW50c0J5VGFnTmFtZSxpZD0ndHlwZWZfb3JtJyxcblx0XHRcdFx0Yj0naHR0cHM6Ly9zMy1ldS13ZXN0LTEuYW1hem9uYXdzLmNvbS9zaGFyZS50eXBlZm9ybS5jb20vJztcblx0XHRcdFx0aWYoIWdpLmNhbGwoZCxpZCkpe2pzPWNlLmNhbGwoZCwnc2NyaXB0Jyk7XG5cdFx0XHRcdGpzLmlkPWlkO2pzLnNyYz1iKyd3aWRnZXQuanMnO1xuXHRcdFx0XHRxPWd0LmNhbGwoZCwnc2NyaXB0JylbMF07XG5cdFx0XHRcdHEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoanMscSlcblx0XHRcdH19KSgpXG5cdFx0XHRcdDwvc2NyaXB0PlxuXHRcdCovXG5cblx0cmVuZGVyKHByb3BzKSB7XG5cdFx0Y29uc3QgY29kZSA9ICc5YjdiM2JhZjU1OGQ1M2JlYTdiZThlNWIzZjBkYTYwMmRkZmIzYTNmJztcblx0XHRyZXR1cm5cblx0XHRcdDxzcGFuPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ0eXBlZm9ybS13aWRnZXRcIiBkYXRhLXVybD1cImh0dHBzOi8vaWdub3JldGhlZ2FwLnR5cGVmb3JtLmNvbS90by97Y29kZX1cIiBkYXRhLXRleHQ9XCJVWCBSZXNlYXJjaCBRdWVzdGlvbm5haXJlXCIgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDo1MDBweDtcIj48L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IHN0eWxlPVwiZm9udC1mYW1pbHk6IFNhbnMtU2VyaWY7Zm9udC1zaXplOiAxMnB4O2NvbG9yOiAjOTk5O29wYWNpdHk6IDAuNTsgcGFkZGluZy10b3A6IDVweDtcIj5cblx0XHRcdFx0XHRcdDxhIGhyZWY9XCJodHRwczovL3d3dy50eXBlZm9ybS5jb20vZXhhbXBsZXMvc3VydmV5cy8/dXRtX2NhbXBhaWduPXtjb2RlfSZhbXA7dXRtX3NvdXJjZT10eXBlZm9ybS5jb20tMzQ3MTI4OS1CYXNpYyZhbXA7dXRtX21lZGl1bT10eXBlZm9ybSZhbXA7dXRtX2NvbnRlbnQ9dHlwZWZvcm0tZW1iZWRkZWQtb25saW5lc3VydmV5JmFtcDt1dG1fdGVybT1FTlwiIHN0eWxlPVwiY29sb3I6ICM5OTlcIiB0YXJnZXQ9XCJfYmxhbmtcIj5PbmxpbmUgc3VydmV5PC9hPlxuXHRcdFx0XHRcdFx0cG93ZXJlZCBieSBUeXBlZm9ybVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9zcGFuPjtcblxuXHR9XG59XG4iLCJpbXBvcnQgJy4vdGltZS1jb3VudGRvd24uZWxlbWVudCc7XG5pbXBvcnQgJy4vZmxvdy1zbGlkZXMuZWxlbWVudCc7XG5pbXBvcnQgJy4vZmxvdy10aW1lLmVsZW1lbnQnO1xuaW1wb3J0IEZsb3dWaWRlbyBmcm9tICcuL2Zsb3ctdmlkZW8uZWxlbWVudCc7XG5pbXBvcnQgJy4vdHlwZWZvcm0tc2hhcmUtYnV0dG9uLmVsZW1lbnQnO1xuXG5jbGFzcyBNRExDYXJkIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLnRlc3RUZXN0ID0gJ3Rlc3QnO1xuICAgIH1cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbWRsLWNhcmQnLCBNRExDYXJkKTtcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdmbG93LXZpZGVvJywgRmxvd1ZpZGVvKTtcbi8vIFRPRE8gY3NzIG9iamVjdC1maXQsIG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCBsb3dTcmMgdXNlIHRvIG1ha2Ugc21hcnQgaW1nIHRhZ3MuXG4iLCJpbXBvcnQgJy4vc2hpbXMnO1xuXG5pbXBvcnQgU3VydmV5IGZyb20gJy4vY29udmVyc2F0aW9uL1N1cnZleSc7XG5pbXBvcnQge1xuICAgIHJlZ2lzdGVyQ29udGVudEVsZW1lbnRzLFxuICAgIHNjYW5UZW1wbGF0ZXMsXG4gICAgc3RhcnRDb252ZXJzYXRpb25zLFxuICAgIGFwcGx5QmxvY2tGcm9tSGFzaCwgcmVtb3ZlSGFzaCxcbiAgICBhcHBseUhpc3RvcnlTdGF0ZSxcbiAgICBuYXZpZ2F0ZVRvSHJlZlxufSBmcm9tICcuL2NvbnZlcnNhdGlvbic7XG5pbXBvcnQgJy4vc2hvd2Nhc2UnO1xuaW1wb3J0ICcuL3R5cG9ncmFwaHknO1xuaW1wb3J0ICcuL2NvbnRlbnQnO1xuXG5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbm8tanMnKTtcbmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcycpO1xuXG4vL1RPRE8gZG9jdW1lbnQgbGF5b3V0IHByaW5jaXBsZSAvIHNlbWFudGljXG5jb25zdCBvdmVybGF5ZWRUb3BpY3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcub3ZlcmxheWVkLXRvcGljJyk7XG5pZiAob3ZlcmxheWVkVG9waWNzLmxlbmd0aCAmJiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBBcnJheS5mcm9tKG92ZXJsYXllZFRvcGljcykuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QuYWRkKCd0b3VjaC1zY3JvbGwnKSk7XG59XG5cbmRvY3VtZW50LlN1cnZleSA9IFN1cnZleTtcblxuLy9UT0RPIHNwbGl0IG91dCBpbiBcImNvbnZlcnNhdGlvbi1mbG93LmpzXCJcbi8vIGVuc3VyZUNvbnZlcnNhdGlvbkRPTSgpO1xuLy8gbWVhc3VyZURPTSgpO1xuXG4vLyBUT0RPIG1hZ2ljIGxpbmtzIHRoYXQgY2FuIGRlZHVjdCBwcm9ncmVzcyBvZiBjb252ZXJzYXRpb24gYW5kIGFkanVzdCBVSVxuLy8gZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG5hdmlnYXRlVG9IcmVmLCB0cnVlKTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgIC8vVE9ETyBhZGp1c3QgY29udGVudC92aWV3IGhlaWdodFxufSk7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsKGV2KSA9PiB7XG4gICAgLy8gY29uc29sZS5pbmZvKCdwb3AnLGV2LnBhdGhbMF0ubG9jYXRpb24sZXYpO1xuICAgIGFwcGx5SGlzdG9yeVN0YXRlKGRvY3VtZW50LmxvY2F0aW9uLmhhc2gsZXYuc3RhdGUpO1xufSk7XG5cbnNjYW5UZW1wbGF0ZXMoKTtcbnJlZ2lzdGVyQ29udGVudEVsZW1lbnRzKCk7XG4vLyBhcHBseUJsb2NrRnJvbUhhc2goKTsgZnV0dXJlIGZvcndhcmRpbmcgdGhlIGNvbnZlcnNhdGlvblxuLy8gcmVtb3ZlSGFzaCgpO1xuLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBhcHBseUJsb2NrRnJvbUhhc2gpO1xuXG5zdGFydENvbnZlcnNhdGlvbnMoKTsgLy9UT0RPIG9ubHkgc3RhcnQgaXQgaWYgdGhlIGNvbnZlcnNhdGlvbiBtYXJrdXAgaXMgcHJlc2VudFxuIl0sIm5hbWVzIjpbImdsb2JhbCIsIm1vZHVsZSIsIndpbmRvdyIsIk1hdGgiLCJzZWxmIiwiRnVuY3Rpb24iLCJfX2ciLCJjb3JlIiwidmVyc2lvbiIsIl9fZSIsIml0IiwiaXNPYmplY3QiLCJyZXF1aXJlIiwiVHlwZUVycm9yIiwiZXhlYyIsImUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImEiLCJkb2N1bWVudCIsImlzIiwiY3JlYXRlRWxlbWVudCIsIlMiLCJmbiIsInZhbCIsInRvU3RyaW5nIiwiY2FsbCIsInZhbHVlT2YiLCJhbk9iamVjdCIsIklFOF9ET01fREVGSU5FIiwidG9QcmltaXRpdmUiLCJkUCIsImV4cG9ydHMiLCJPIiwiUCIsIkF0dHJpYnV0ZXMiLCJ2YWx1ZSIsImJpdG1hcCIsImNyZWF0ZURlc2MiLCJvYmplY3QiLCJrZXkiLCJmIiwiaGFzT3duUHJvcGVydHkiLCJpZCIsInB4IiwicmFuZG9tIiwiY29uY2F0IiwidW5kZWZpbmVkIiwiaGlkZSIsImhhcyIsIlNSQyIsIlRPX1NUUklORyIsIiR0b1N0cmluZyIsIlRQTCIsInNwbGl0IiwiaW5zcGVjdFNvdXJjZSIsInNhZmUiLCJpc0Z1bmN0aW9uIiwiam9pbiIsIlN0cmluZyIsInByb3RvdHlwZSIsImFGdW5jdGlvbiIsInRoYXQiLCJsZW5ndGgiLCJiIiwiYyIsImFwcGx5IiwiYXJndW1lbnRzIiwicmVkZWZpbmUiLCJjdHgiLCJQUk9UT1RZUEUiLCIkZXhwb3J0IiwidHlwZSIsIm5hbWUiLCJzb3VyY2UiLCJJU19GT1JDRUQiLCJGIiwiSVNfR0xPQkFMIiwiRyIsIklTX1NUQVRJQyIsIklTX1BST1RPIiwiSVNfQklORCIsIkIiLCJ0YXJnZXQiLCJleHBQcm90byIsIm93biIsIm91dCIsImV4cCIsIlUiLCJXIiwiUiIsImRlZmluZWQiLCJmYWlscyIsInNwYWNlcyIsInNwYWNlIiwibm9uIiwibHRyaW0iLCJSZWdFeHAiLCJydHJpbSIsImV4cG9ydGVyIiwiS0VZIiwiQUxJQVMiLCJGT1JDRSIsInRyaW0iLCJzdHJpbmciLCJUWVBFIiwicmVwbGFjZSIsIiR0cmltIiwiY2VpbCIsImZsb29yIiwiaXNOYU4iLCJ0b0ludGVnZXIiLCJtaW4iLCJzbGljZSIsIlNIQVJFRCIsInN0b3JlIiwidWlkIiwiU3ltYm9sIiwiVVNFX1NZTUJPTCIsIiRleHBvcnRzIiwiY29mIiwiTUFUQ0giLCJpc1JlZ0V4cCIsInNlYXJjaFN0cmluZyIsIk5BTUUiLCJyZSIsInRvTGVuZ3RoIiwiY29udGV4dCIsIlNUQVJUU19XSVRIIiwiJHN0YXJ0c1dpdGgiLCJzdGFydHNXaXRoIiwiaW5kZXgiLCJzZWFyY2giLCJFTkRTX1dJVEgiLCIkZW5kc1dpdGgiLCJlbmRzV2l0aCIsImVuZFBvc2l0aW9uIiwibGVuIiwiZW5kIiwiTUVUQSIsInNldERlc2MiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJmYXN0S2V5IiwiY3JlYXRlIiwiaSIsImdldFdlYWsiLCJ3Iiwib25GcmVlemUiLCJtZXRhIiwiTkVFRCIsImRlZiIsIlRBRyIsInRhZyIsInN0YXQiLCJjb25maWd1cmFibGUiLCJMSUJSQVJZIiwid2tzRXh0IiwiJFN5bWJvbCIsImNoYXJBdCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiSU9iamVjdCIsIm1heCIsInRvSU9iamVjdCIsInRvQWJzb2x1dGVJbmRleCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsInNoYXJlZCIsImFycmF5SW5kZXhPZiIsIklFX1BST1RPIiwibmFtZXMiLCJyZXN1bHQiLCJwdXNoIiwiJGtleXMiLCJlbnVtQnVnS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRLZXlzIiwiZ09QUyIsInBJRSIsImdldFN5bWJvbHMiLCJzeW1ib2xzIiwiaXNFbnVtIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJnIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJkUHMiLCJFbXB0eSIsImNyZWF0ZURpY3QiLCJpZnJhbWUiLCJsdCIsImd0IiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwid3JpdGUiLCJjbG9zZSIsImhpZGRlbktleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ09QTiIsIndpbmRvd05hbWVzIiwiZ2V0V2luZG93TmFtZXMiLCJnT1BEIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiREVTQ1JJUFRPUlMiLCIkZmFpbHMiLCJzZXRUb1N0cmluZ1RhZyIsIndrcyIsIndrc0RlZmluZSIsImVudW1LZXlzIiwiX2NyZWF0ZSIsImdPUE5FeHQiLCIkR09QRCIsIiREUCIsIiRKU09OIiwiSlNPTiIsIl9zdHJpbmdpZnkiLCJzdHJpbmdpZnkiLCJISURERU4iLCJUT19QUklNSVRJVkUiLCJTeW1ib2xSZWdpc3RyeSIsIkFsbFN5bWJvbHMiLCJPUFN5bWJvbHMiLCJPYmplY3RQcm90byIsIlVTRV9OQVRJVkUiLCJRT2JqZWN0Iiwic2V0dGVyIiwiZmluZENoaWxkIiwic2V0U3ltYm9sRGVzYyIsIkQiLCJwcm90b0Rlc2MiLCJ3cmFwIiwic3ltIiwiX2siLCJpc1N5bWJvbCIsIml0ZXJhdG9yIiwiJGRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIiRkZWZpbmVQcm9wZXJ0aWVzIiwibCIsIiRjcmVhdGUiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJFIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiJGdldE93blByb3BlcnR5U3ltYm9scyIsIklTX09QIiwiJHNldCIsInNldCIsImVzNlN5bWJvbHMiLCJqIiwid2VsbEtub3duU3ltYm9scyIsImsiLCJrZXlGb3IiLCJhcmdzIiwicmVwbGFjZXIiLCIkcmVwbGFjZXIiLCJBUkciLCJ0cnlHZXQiLCJUIiwiY2FsbGVlIiwiY2xhc3NvZiIsInRlc3QiLCJwb3MiLCJzIiwiY2hhckNvZGVBdCIsImRlc2NyaXB0b3IiLCJJdGVyYXRvclByb3RvdHlwZSIsIkNvbnN0cnVjdG9yIiwibmV4dCIsInRvT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIkl0ZXJhdG9ycyIsIiRpdGVyQ3JlYXRlIiwiSVRFUkFUT1IiLCJCVUdHWSIsIkZGX0lURVJBVE9SIiwiS0VZUyIsIlZBTFVFUyIsInJldHVyblRoaXMiLCJCYXNlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldE1ldGhvZCIsImtpbmQiLCJwcm90byIsInZhbHVlcyIsImVudHJpZXMiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIm1ldGhvZHMiLCIkYXQiLCJpdGVyYXRlZCIsIl90IiwiX2kiLCJwb2ludCIsImRvbmUiLCJyZXQiLCJBcnJheVByb3RvIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJTQUZFX0NMT1NJTkciLCJyaXRlciIsImZyb20iLCJza2lwQ2xvc2luZyIsImFyciIsIml0ZXIiLCJpc0FycmF5SXRlciIsImNyZWF0ZVByb3BlcnR5IiwiZ2V0SXRlckZuIiwiYXJyYXlMaWtlIiwiQyIsImFMZW4iLCJtYXBmbiIsIm1hcHBpbmciLCJpdGVyRm4iLCJzdGVwIiwib2YiLCJTUEVDSUVTIiwib3JpZ2luYWwiLCJzcGVjaWVzQ29uc3RydWN0b3IiLCJhc2MiLCJJU19NQVAiLCJJU19GSUxURVIiLCJJU19TT01FIiwiSVNfRVZFUlkiLCJJU19GSU5EX0lOREVYIiwiTk9fSE9MRVMiLCJjYWxsYmFja2ZuIiwicmVzIiwiVU5TQ09QQUJMRVMiLCIkZmluZCIsImZvcmNlZCIsImZpbmQiLCJmaW5kSW5kZXgiLCIkYXNzaWduIiwiYXNzaWduIiwiQSIsIksiLCJmb3JFYWNoIiwieCIsInkiLCJFbGVtZW50UHJvdG8iLCJtYXRjaGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJzZWxlY3RvciIsImVsZW1lbnQiLCJlbGVtZW50cyIsIm93bmVyRG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiQm9vbGVhbiIsImNsb3Nlc3QiLCJub2RlVHlwZSIsInBhcmVudE5vZGUiLCJFbGVtZW50IiwibWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIml0ZW0iLCJwYXJlbnRFbGVtZW50IiwiU3VydmV5IiwicmVzcG9uc2VzIiwidGV4dCIsImVudHJ5Iiwic3VydmV5Iiwic3VydmV5VXBkYXRlcyIsImluc3RhbmNlcyIsIkNvbmNyZXRlU3VydmV5IiwiYnlOYW1lIiwiRGVmYXVsdCIsInBhcnNlIiwic2Vzc2lvblN0b3JhZ2UiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiYWxsUGFzdENvbnZlcnNhdGlvbiIsImxvY2FsU3RvcmFnZSIsInBhc3RDb252ZXJzYXRpb24iLCJjdXN0b21UYWdzIiwiY3VzdG9tVXBncmFkZXJzIiwidW5pcXVlcyIsIndhaXRpbmdGb3IiLCJmaXJlUmVhZHkiLCJ1cGdyYWRlZEZsYWciLCJVUEdSQURFX0FQSSIsImlkZW50aWZ5IiwiSURfTkFNRSIsImluY3JlbWVudGFsVGVtcGxhdGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkeSIsInVuaXF1ZSIsIldlYWtNYXAiLCJkZWZpbmUiLCJ0ZW1wbGF0ZSIsInVwZ3JhZGVFbGVtZW50IiwiY2FsbGJhY2tOYW1lIiwiY2FsbGJhY2siLCJuIiwiZGVzY3IiLCJpc0Zyb20iLCJ0aGVuIiwibGF0ZVNhdmVJZCIsInNhdmVJZCIsImxvY2FsTmFtZSIsInVwZ3JhZGVkRWxlbWVudCIsInVwZ3JhZGVET00iLCJkb20iLCJub2RlTmFtZSIsImluZGV4T2YiLCJjb250ZW50IiwibGlzdGVyIiwidXBncmFkZXIiLCJlbHMiLCJhdHRyczJwcm9wcyIsImF0dHJzIiwicmVuYW1lIiwiZGVmYXVsdFJlbmFtZSIsImNvZXJjZSIsImRlZmF1bHRDb2VyY2UiLCJwcm9wcyIsImF0dHIiLCJmcmFnbWVudDJqc29ubWwiLCJmcmFnbWVudCIsInRhZ05hbWUiLCJvcHRzIiwiYmFzZVByb3BzIiwiYmFzZSIsImNoaWxkTm9kZXMiLCJza2lwVGV4dCIsIm5vZGUiLCJlbGVtZW50Mmpzb25tbCIsImF0dHJpYnV0ZXMiLCJkZWZhdWx0Q2hpbGRGaWx0ZXIiLCJmaWxsSW5KU09OTUwiLCJwYXJlbnQiLCJmaWx0ZXIiLCJqc29uIiwibm9kZVZhbHVlIiwiQmxvY2tUZW1wbGF0ZSIsInRvcGljIiwiZ2V0QXR0cmlidXRlIiwic3RhdGVtZW50cyIsInN0YXRlIiwianNvbm1sIiwicmVtb3ZlQXR0cmlidXRlIiwiY2xhc3NOYW1lIiwiX2pzb25tbCIsImNsZWFuQmxvY2siLCJlbGVtIiwiY2hpbGQiLCJ0ZXh0Q29udGVudCIsImp1c3RXaGl0ZXNwYWNlIiwiY2hpbGRyZW4iLCJyZW1vdmVDaGlsZCIsIlN0YXRlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImNsYXNzZXNXaGlsZVNob3dpbmciLCJjbGFzc2VzV2hpbGVQZW5kaW5nIiwidGltaW5nIiwiZGVsYXlCZXR3ZWVuIiwicGVuZGluZ1BlcmlvZCIsIlNIQTEiLCJtc2ciLCJyb3RhdGVfbGVmdCIsInQ0IiwibHNiX2hleCIsInN0ciIsInZoIiwidmwiLCJjdnRfaGV4IiwidiIsIlV0ZjhFbmNvZGUiLCJ1dGZ0ZXh0IiwiZnJvbUNoYXJDb2RlIiwiYmxvY2tzdGFydCIsIkgwIiwiSDEiLCJIMiIsIkgzIiwiSDQiLCJ0ZW1wIiwibXNnX2xlbiIsIndvcmRfYXJyYXkiLCJ0b0xvd2VyQ2FzZSIsImZpZWxkTGlzdCIsImFjdGlvbiIsImZpZWxkcyIsIkZJRUxEUyIsImZpZWxkIiwic2V0QXR0cmlidXRlIiwibWFrZVVuaXF1ZU5hbWUiLCJ1bmlxdWVOYW1lIiwiYW5ub3RhdGVNYXJrdXAiLCJlbEpTT04iLCJ0cmltbWVkIiwibWFwIiwidHJpbUVudHJ5IiwiY2hvaWNlUmVxdWlyZWQiLCJyZXNwb25zZVBhcnRzVG9UZW1wbGF0ZSIsInBhcnQiLCJBY3Rpb25UZW1wbGF0ZSIsImhhc0F0dHJpYnV0ZSIsImFjdGlvbnMiLCJmaWVsZE5hbWVzIiwidXBncmFkZUJ5VHlwZSIsInBhcnRzTGlzdCIsInJlc3BvbnNlVGVtcGxhdGUiLCJyZW5kZXIiLCJzdWJzdHJpbmciLCJzZWxlY3QiLCJibGFua09wdGlvbiIsImluc2VydEJlZm9yZSIsImZpcnN0RWxlbWVudENoaWxkIiwic3RhdGljTGVuZ3RoIiwidGVtcGxhdGVJZCIsImlubmVySFRNTCIsInJlc3BvbnNlUHJvcHMiLCJibG9jayIsImlucHV0cyIsImRlc2NyaWJlSW5wdXQiLCJlbmFibGVNZXNzYWdlIiwiYWN0aW9uc0lkIiwiaW5uZXJUZXh0IiwiZXZlbnQiLCJpbmZvIiwiaW5wdXQiLCJOT19PUCIsIkVSUk9SX01TRyIsImlzQnJvd3NlciIsImlzU3RhdGVmdWxDb21wb25lbnQiLCJvIiwiaXNVbmRlZmluZWQiLCJpc1N0cmluZ09yTnVtYmVyIiwiaXNOdWxsT3JVbmRlZiIsImlzTnVsbCIsImlzSW52YWxpZCIsImlzVHJ1ZSIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIkVycm9yIiwid2FybmluZyIsIndhcm4iLCJjb21iaW5lRnJvbSIsImZpcnN0Iiwic2Vjb25kIiwia2V5JDEiLCJMaWZlY3ljbGUiLCJsaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsInRyaWdnZXIiLCJsaXN0ZW5lciIsInNoaWZ0Iiwib3B0aW9ucyIsInhsaW5rTlMiLCJ4bWxOUyIsInN2Z05TIiwic3RyaWN0UHJvcHMiLCJTZXQiLCJib29sZWFuUHJvcHMiLCJuYW1lc3BhY2VzIiwiTWFwIiwiaXNVbml0bGVzc051bWJlciIsInNraXBQcm9wcyIsImRlbGVnYXRlZEV2ZW50cyIsImlzaU9TIiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJkZWxlZ2F0ZWRFdmVudHMkMSIsImhhbmRsZUV2ZW50IiwibGFzdEV2ZW50IiwibmV4dEV2ZW50IiwiZGVsZWdhdGVkUm9vdHMiLCJpdGVtcyIsImRvY0V2ZW50IiwiYXR0YWNoRXZlbnRUb0RvY3VtZW50IiwiZGVsZXRlIiwic2l6ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJub3JtYWxpemVFdmVudE5hbWUiLCJkaXNwYXRjaEV2ZW50cyIsImNvdW50IiwiaXNDbGljayIsImV2ZW50RGF0YSIsImV2ZW50c1RvVHJpZ2dlciIsImRhdGEiLCJjYW5jZWxCdWJibGUiLCJkaXNhYmxlZCIsInN1YnN0ciIsInN0b3BQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbXB0eUZuIiwidHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQiLCJvbmNsaWNrIiwiaXNDaGVja2VkVHlwZSIsIm9uVGV4dElucHV0Q2hhbmdlIiwidk5vZGUiLCJFTVBUWV9PQkoiLCJwcmV2aW91c1ZhbHVlIiwib25JbnB1dCIsIm9uaW5wdXQiLCJuZXdWTm9kZSIsIm5ld1Byb3BzIiwid3JhcHBlZE9uQ2hhbmdlIiwib25DaGFuZ2UiLCJvbkNoZWNrYm94Q2hhbmdlIiwib25DbGljayIsInByb2Nlc3NJbnB1dCIsIm5leHRQcm9wc09yRW1wdHkiLCJtb3VudGluZyIsImlzQ29udHJvbGxlZCIsIndyYXBwZWQiLCJvbmNoYW5nZSIsImFwcGx5VmFsdWUiLCJjaGVja2VkIiwibXVsdGlwbGUiLCJkZWZhdWx0VmFsdWUiLCJoYXNWYWx1ZSIsInVwZGF0ZUNoaWxkT3B0aW9uR3JvdXAiLCJpc1ZOb2RlIiwidXBkYXRlQ2hpbGRPcHRpb24iLCJzZWxlY3RlZCIsIm9uU2VsZWN0Q2hhbmdlIiwicHJvY2Vzc1NlbGVjdCIsImFwcGx5VmFsdWUkMSIsIndyYXBwZWRPbkNoYW5nZSQxIiwib25UZXh0YXJlYUlucHV0Q2hhbmdlIiwicHJvY2Vzc1RleHRhcmVhIiwiYXBwbHlWYWx1ZSQyIiwiZG9tVmFsdWUiLCJwcm9jZXNzRWxlbWVudCIsImZsYWdzIiwiaXNDb250cm9sbGVkRm9ybUVsZW1lbnQiLCJub3JtYWxpemVDaGlsZE5vZGVzIiwicGFyZW50RG9tIiwiZmlyc3RDaGlsZCIsInBsYWNlaG9sZGVyIiwiY3JlYXRlVGV4dE5vZGUiLCJyZXBsYWNlQ2hpbGQiLCJuZXh0U2libGluZyIsImxhc3REb20iLCJwcmV2aW91c1NpYmxpbmciLCJoeWRyYXRlQ29tcG9uZW50IiwibGlmZWN5Y2xlIiwiaXNTVkciLCJpc0NsYXNzIiwicmVmIiwiX2lzU1ZHIiwibmFtZXNwYWNlVVJJIiwiaW5zdGFuY2UiLCJjcmVhdGVDbGFzc0NvbXBvbmVudEluc3RhbmNlIiwiX2xhc3RJbnB1dCIsIl92Tm9kZSIsIl9jaGlsZENvbnRleHQiLCJfdXBkYXRpbmciLCJmaW5kRE9NTm9kZUVuYWJsZWQiLCJpbnB1dCQxIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudElucHV0IiwiaHlkcmF0ZUVsZW1lbnQiLCJuZXdEb20iLCJtb3VudEVsZW1lbnQiLCJpc1NhbWVQcm9wc0lubmVySFRNTCIsImhhc0NvbnRyb2xsZWRWYWx1ZSIsImlzRm9ybUVsZW1lbnQiLCJwcm9wIiwiaHlkcmF0ZUNoaWxkcmVuIiwibmV4dFNpYmxpbmckMSIsImh5ZHJhdGVUZXh0IiwibW91bnRUZXh0IiwiaHlkcmF0ZVZvaWQiLCJoeWRyYXRlIiwiaHlkcmF0ZVJvb3QiLCJjb21wb25lbnRQb29scyIsImVsZW1lbnRQb29scyIsInJlY3ljbGVFbGVtZW50IiwicG9vbHMiLCJwb29sIiwibm9uS2V5ZWQiLCJrZXllZCIsInJlY3ljbGVkVk5vZGUiLCJwb3AiLCJwb29sRWxlbWVudCIsInJlY3ljbGVDb21wb25lbnQiLCJmYWlsZWQiLCJwYXRjaENvbXBvbmVudCIsInBvb2xDb21wb25lbnQiLCJob29rcyIsIm5vblJlY3ljbGVIb29rcyIsIm9uQ29tcG9uZW50V2lsbE1vdW50Iiwib25Db21wb25lbnRXaWxsVW5tb3VudCIsIm9uQ29tcG9uZW50RGlkTW91bnQiLCJvbkNvbXBvbmVudFdpbGxVcGRhdGUiLCJvbkNvbXBvbmVudERpZFVwZGF0ZSIsInVubW91bnQiLCJjYW5SZWN5Y2xlIiwiaXNSZWN5Y2xpbmciLCJpc1N0YXRlZnVsQ29tcG9uZW50JCQxIiwiX3VubW91bnRlZCIsImJlZm9yZVVubW91bnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl9saWZlY3ljbGUiLCJyZWN5Y2xpbmdFbmFibGVkIiwicmVmJDEiLCJwcm9wcyQxIiwiaXNBdHRyQW5FdmVudCIsImNvbXBvbmVudFRvRE9NTm9kZU1hcCIsInJvb3RzIiwiZmluZERPTU5vZGUiLCJnZXRSb290Iiwicm9vdCIsInNldFJvb3QiLCJyZW1vdmVSb290Iiwic3BsaWNlIiwiYm9keSIsImRvY3VtZW50Qm9keSIsImRpcmVjdENsb25lIiwibGlmZWN5Y2xlJDEiLCJyb290SW5wdXQiLCJjcmVhdGVSZW5kZXJlciIsInJlbmRlcmVyIiwibGFzdElucHV0IiwibmV4dElucHV0IiwicGF0Y2giLCJsYXN0Vk5vZGUiLCJuZXh0Vk5vZGUiLCJsYXN0RmxhZ3MiLCJuZXh0RmxhZ3MiLCJtb3VudENvbXBvbmVudCIsIm1vdW50Vm9pZCIsInVubW91bnRDaGlsZHJlbiIsInBhdGNoRWxlbWVudCIsIm5leHRUYWciLCJsYXN0VGFnIiwibGFzdFByb3BzIiwibmV4dFByb3BzIiwibGFzdENoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibmV4dFJlZiIsImxhc3RDbGFzc05hbWUiLCJuZXh0Q2xhc3NOYW1lIiwiY2hpbGRyZW5Jc1NWRyIsImxhc3RQcm9wc09yRW1wdHkiLCJuZXh0VmFsdWUiLCJsYXN0VmFsdWUiLCJwcm9wJDEiLCJwYXRjaENoaWxkcmVuIiwicGF0Y2hBcnJheSIsInBhdGNoS2V5ZWQiLCJpc0tleWVkIiwibGFzdExlbmd0aCIsIm5leHRMZW5ndGgiLCJsYXN0VHlwZSIsIm5leHRUeXBlIiwibGFzdEtleSIsIm5leHRLZXkiLCJoYXNDb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJuZXh0U3RhdGUiLCJsYXN0U3RhdGUiLCJfdXBkYXRlQ29tcG9uZW50IiwiZGlkVXBkYXRlIiwiY2hpbGRDb250ZXh0IiwiZ2V0Q2hpbGRDb250ZXh0IiwiY3JlYXRlVm9pZFZOb2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwicGFyZW50Vk5vZGUiLCJhZnRlclVwZGF0ZSIsInNob3VsZFVwZGF0ZSIsImxhc3RQcm9wcyQxIiwibmV4dEhvb2tzIiwibmV4dEhvb2tzRGVmaW5lZCIsImxhc3RJbnB1dCQxIiwibmV4dElucHV0JDEiLCJvbkNvbXBvbmVudFNob3VsZFVwZGF0ZSIsInBhdGNoVGV4dCIsIm5leHRUZXh0IiwicGF0Y2hWb2lkIiwicGF0Y2hOb25LZXllZENoaWxkcmVuIiwibGFzdENoaWxkcmVuTGVuZ3RoIiwibmV4dENoaWxkcmVuTGVuZ3RoIiwiY29tbW9uTGVuZ3RoIiwibmV4dENoaWxkIiwibmV4dENoaWxkJDEiLCJtb3VudCIsInBhdGNoS2V5ZWRDaGlsZHJlbiIsImFMZW5ndGgiLCJiTGVuZ3RoIiwiYUVuZCIsImJFbmQiLCJhU3RhcnQiLCJiU3RhcnQiLCJhTm9kZSIsImJOb2RlIiwibmV4dE5vZGUiLCJuZXh0UG9zIiwiYVN0YXJ0Tm9kZSIsImJTdGFydE5vZGUiLCJhRW5kTm9kZSIsImJFbmROb2RlIiwib3V0ZXIiLCJhTGVmdCIsImJMZWZ0Iiwic291cmNlcyIsIm1vdmVkIiwicGF0Y2hlZCIsImtleUluZGV4Iiwic2VxIiwibGlzX2FsZ29yaXRobSIsInAiLCJ1IiwiYXJySSIsInBhdGNoUHJvcCIsImxhc3RIdG1sIiwiX19odG1sIiwibmV4dEh0bWwiLCJpc1NhbWVJbm5lckhUTUwiLCJzZXRBdHRyaWJ1dGVOUyIsInBhdGNoRXZlbnQiLCJuYW1lTG93ZXJDYXNlIiwiZG9tRXZlbnQiLCJsaW5rRXZlbnQiLCJwYXRjaFN0eWxlIiwibGFzdEF0dHJWYWx1ZSIsIm5leHRBdHRyVmFsdWUiLCJkb21TdHlsZSIsImNzc1RleHQiLCJyZW1vdmVQcm9wIiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50IiwibW91bnRBcnJheUNoaWxkcmVuIiwibW91bnRDbGFzc0NvbXBvbmVudENhbGxiYWNrcyIsImhhc0RpZE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJhZnRlck1vdW50IiwibW91bnRGdW5jdGlvbmFsQ29tcG9uZW50Q2FsbGJhY2tzIiwibW91bnRSZWYiLCJmcmVlemUiLCJDb21wb25lbnQiLCJfYmxvY2tTZXRTdGF0ZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9ibG9ja1JlbmRlciIsIl9wZW5kaW5nU2V0U3RhdGUiLCJwZW5kaW5nIiwiX3BlbmRpbmdTdGF0ZSIsImJlZm9yZVJlbmRlciIsImFmdGVyUmVuZGVyIiwicmVwbGFjZUxhc3RDaGlsZEFuZFVubW91bnQiLCJyZXBsYWNlVk5vZGUiLCJjb21wb25lbnQiLCJzZXRUZXh0Q29udGVudCIsInVwZGF0ZVRleHRDb250ZW50IiwiaW5zZXJ0T3JBcHBlbmQiLCJuZXdOb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwicmVwbGFjZVdpdGhOZXdOb2RlIiwibGFzdE5vZGUiLCJyZW1vdmVBbGxDaGlsZHJlbiIsInJlbW92ZUNoaWxkcmVuIiwidGVtcGRvbSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiY3JlYXRlVk5vZGUiLCJub05vcm1hbGlzZSIsInZOb2RlVG9DbG9uZSIsInByb3BzVG9DbG9uZSIsIm5ld0NoaWxkcmVuIiwidG1wQXJyYXkiLCJwcm9wc1RvQ2xvbmUkMSIsImNsb25lVk5vZGUiLCJfY2hpbGRyZW4iLCJsZW4kMiIsImNoaWxkcmVuTGVuIiwibGVuJDEiLCJ0bXBBcnJheSQxIiwiaSQxIiwiYXBwbHlLZXkiLCJhcHBseUtleUlmTWlzc2luZyIsImFwcGx5S2V5UHJlZml4IiwiX25vcm1hbGl6ZVZOb2RlcyIsIm5vZGVzIiwiY3VycmVudEtleSIsIm5vcm1hbGl6ZVZOb2RlcyIsIm5ld05vZGVzIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVQcm9wcyIsImdldEZsYWdzRm9yRWxlbWVudFZub2RlIiwibm9ybWFsaXplIiwiZGVmYXVsdFByb3BzIiwidmVyaWZ5S2V5cyIsInZOb2RlcyIsImtleVZhbHVlcyIsInZub2RlIiwic29tZSIsImlkeCIsImhhc0R1cGxpY2F0ZSIsInRlc3RGdW5jIiwidGVzdEZuIiwibm9PcCIsImNvbXBvbmVudENhbGxiYWNrUXVldWUiLCJ1cGRhdGVQYXJlbnRDb21wb25lbnRWTm9kZXMiLCJyZXNvbHZlZFByb21pc2UiLCJhZGRUb1F1ZXVlIiwiZm9yY2UiLCJxdWV1ZSIsInF1ZXVlU3RhdGVDaGFuZ2VzIiwibmV3U3RhdGUiLCJzdGF0ZUtleSIsImJpbmQiLCJhcHBseVN0YXRlIiwicGVuZGluZ1N0YXRlIiwicHJldlN0YXRlIiwicmVuZGVyT3V0cHV0IiwibGlmZUN5Y2xlIiwiZm9yY2VVcGRhdGUiLCJzZXRTdGF0ZSIsInByZXZQcm9wcyIsImZyb21TZXRTdGF0ZSIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwibmV4dENvbnRleHQiLCJfaW50ZXJvcERlZmF1bHQiLCJleCIsImluZmVybm8iLCJBVVRPQklORF9CTEFDS0xJU1QiLCJleHRlbmQiLCJiaW5kQWxsIiwiX19ib3VuZCIsImNvbGxhdGVNaXhpbnMiLCJtaXhpbnMiLCJtaXhpbiIsIm11bHRpaG9vayIsIm1lcmdlRm4iLCJhcmd1bWVudHMkMSIsInRoaXMkMSIsImhvb2siLCJyIiwibWVyZ2VOb0R1cGVzIiwicHJldmlvdXMiLCJjdXJyZW50IiwiYXBwbHlNaXhpbiIsImluc3QiLCJhcHBseU1peGlucyIsIkNsIiwiY3JlYXRlQ2xhc3MiLCJvYmoiLCJDb21wb25lbnQkJDEiLCJnZXRJbml0aWFsU3RhdGUiLCJfX3Byb3RvX18iLCJyZXBsYWNlU3RhdGUiLCJpc01vdW50ZWQiLCJkaXNwbGF5TmFtZSIsInByb3BUeXBlcyIsImdldERlZmF1bHRQcm9wcyIsInN0YXRpY3MiLCJpc051bGxPclVuZGVmJDEiLCJpc1VuZGVmaW5lZCQxIiwiaXNOdWxsJDEiLCJpc09iamVjdCQxIiwiY29tcG9uZW50SG9va3MiLCJjcmVhdGVFbGVtZW50JDEiLCJpc051bGxPclVuZGVmJDIiLCJpc1VuZGVmaW5lZCQyIiwiaXNOdWxsJDIiLCJpc0Z1bmN0aW9uJDEiLCJpc1N0cmluZyQxIiwiaXNPYmplY3QkMiIsImlzVmFsaWRFbGVtZW50IiwiaXNOb3RBTnVsbE9iamVjdCIsInByb3B0eXBlIiwiaXNSZXF1aXJlZCIsImdldFByb3B0eXBlIiwiUHJvcFR5cGVzIiwiU1ZHRE9NUHJvcGVydHlDb25maWciLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiY29udGFpbmVyIiwiQVJSIiwiQ2hpbGRyZW4iLCJ0b0FycmF5Iiwib25seSIsInRvQXJyYXkkJDEiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3VycmVudENvbXBvbmVudCIsImV2ZW50TmFtZSIsIm9uRGJsQ2xpY2siLCJmb3IiLCJtYXBwZWRQcm9wIiwiRXZlbnQiLCJwZXJzaXN0IiwiaXRlcmFibGVUb0FycmF5IiwiaXRlcmFibGUiLCJpdGVyU3RlcCIsInRtcEFyciIsImhhc1N5bWJvbFN1cHBvcnQiLCJpbmplY3RTdHJpbmdSZWZzIiwib3JpZ2luYWxGdW5jdGlvbiIsIl9wcm9wcyIsInJlZnMiLCJjbG9uZUVsZW1lbnQiLCJvbGRDcmVhdGVWTm9kZSIsInNoYWxsb3dEaWZmZXJzIiwiUHVyZUNvbXBvbmVudCIsIldyYXBwZXJDb21wb25lbnQiLCJyZW5kZXIkJDEiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsInBhcmVudENvbXBvbmVudCIsIndyYXBwZXJWTm9kZSIsIkVMRU1FTlRTIiwiY3JlYXRlRmFjdG9yeSIsIkRPTSIsIlJlYWN0IiwiZXhwb3J0cyQxIiwiUmVhY3RET00iLCJkZWZhdWx0IiwiaGFzU3BhY2UiLCJoYXNTZXBhcmF0b3IiLCJoYXNDYW1lbCIsInRvU2x1Z0Nhc2UiLCJ0b1NwYWNlQ2FzZSIsInRvTm9DYXNlIiwidW5zZXBhcmF0ZSIsInVuY2FtZWxpemUiLCJtYXRjaCIsInNlcGFyYXRvclNwbGl0dGVyIiwibSIsImNhbWVsU3BsaXR0ZXIiLCJ1cHBlcnMiLCJ1bmlxdWVDYWxsU3ltYm9sIiwiZVN0YXRlU3ltYm9sIiwiQXNDdXN0b21FbGVtZW50IiwidHJlZVJlbmRlcmVyIiwiZGVmYXVsdFRyZWVSZW5kZXJlciIsImNvbm5lY3RlZENhbGxiYWNrIiwiZGlzY29ubmVjdGVkQ2FsbGJhY2siLCJwcm9wc0V4dHJhY3RvclNlbGVjdG9yIiwicHJvcHNFeHRyYWN0b3IiLCJjb21wdXRlIiwiY29ubmVjdCIsImRlY29yYXRlQ29tcG9uZW50IiwiZGVjb3JhdG9yIiwiQmFzZUNvbXBvbmVudCIsImV4dGVuZGVkUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJkZWZhdWx0cyIsIm9ic2VydmVkQXR0cmlidXRlcyIsImFzQ29tcG9uZW50IiwiY3VzdG9tRWxlbWVudCIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsInVuaXF1ZUNhbGwiLCJzZWVkUHJvcHMiLCJpbnRlcm5hbCIsImdldFByb3BlcnRpZXMiLCJnZXRTdGF0ZSIsImNoYW5nZSIsImRpc3BhdGNoIiwiYWN0aW9uRm9yQ2hhbmdlIiwiZXh0cmFjdFN0YXRlIiwiY29ubmVjdGVkIiwicm9vdFJlbmRlciIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJkZXN0cm95IiwiSFRNTEVsZW1lbnQiLCJwYXN0QXJncyIsInJlZHVjZSIsInByb3BOYW1lIiwic2x1Z05hbWUiLCJhdHRyaWJ1dGUiLCJtYWtlUHJvcCIsImNvZGVOYW1lIiwiVk5vZGVGbGFncyIsIlZOb2RlRmxhZ3MkMSIsImZpbmRWTm9kZUZyb21Eb20iLCJyZXN1bHQkMSIsInJlc3VsdCQyIiwiaW5zdGFuY2VNYXAiLCJnZXRLZXlGb3JWTm9kZSIsImdldEluc3RhbmNlRnJvbVZOb2RlIiwiY3JlYXRlSW5zdGFuY2VGcm9tVk5vZGUiLCJkZWxldGVJbnN0YW5jZUZvclZOb2RlIiwiY3JlYXRlRGV2VG9vbHNCcmlkZ2UiLCJDb21wb25lbnRUcmVlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsImdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlIiwidXBkYXRlUmVhY3RDb21wb25lbnQiLCJNb3VudCIsIl9yZW5kZXJOZXdSb290Q29tcG9uZW50IiwiUmVjb25jaWxlciIsInBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSIsInJlY2VpdmVDb21wb25lbnQiLCJ1bm1vdW50Q29tcG9uZW50IiwicXVldWVkTW91bnRDb21wb25lbnRzIiwicXVldWVkUmVjZWl2ZUNvbXBvbmVudHMiLCJxdWV1ZWRVbm1vdW50Q29tcG9uZW50cyIsInF1ZXVlVXBkYXRlIiwidXBkYXRlciIsInF1ZXVlTW91bnRDb21wb25lbnQiLCJxdWV1ZVJlY2VpdmVDb21wb25lbnQiLCJxdWV1ZVVubW91bnRDb21wb25lbnQiLCJjb21wb25lbnRBZGRlZCIsImlzUm9vdFZOb2RlIiwiX3Jvb3RJRCIsIm5leHRSb290S2V5IiwiY2hpbGRJbnN0IiwiX2luRGV2VG9vbHMiLCJjb21wb25lbnRVcGRhdGVkIiwicHJldlJlbmRlcmVkQ2hpbGRyZW4iLCJjb250YWlucyIsImNvbXBvbmVudFJlbW92ZWQiLCJvbGRJbnN0YW5jZSIsIm5ld0luc3RhbmNlIiwiY3JlYXRlUmVhY3RDb21wb3NpdGVDb21wb25lbnQiLCJjcmVhdGVSZWFjdERPTUNvbXBvbmVudCIsImlzSW52YWxpZENoaWxkIiwiaXNUZXh0Iiwibm9ybWFsaXplS2V5IiwiaXNGaXJzdENyZWF0aW9uIiwiY29tcG9zaXRlQ29tcG9uZW50IiwiZ2V0TmFtZSIsInR5cGVOYW1lIiwiZm9yY2VJbnN0YW5jZVVwZGF0ZSIsIl9jdXJyZW50RWxlbWVudCIsInZpc2l0Tm9uQ29tcG9zaXRlQ2hpbGRyZW4iLCJ2aXNpdG9yIiwiX3JlbmRlcmVkQ29tcG9uZW50IiwiX2NvbXBvbmVudCIsIl9yZW5kZXJlZENoaWxkcmVuIiwiZmluZFJvb3RzIiwiZnVuY3Rpb25hbENvbXBvbmVudFdyYXBwZXJzIiwid3JhcEZ1bmN0aW9uYWxDb21wb25lbnQiLCJvcmlnaW5hbFJlbmRlciIsIndyYXBwZXJzIiwid3JhcHBlciIsImluaXREZXZUb29scyIsImJyaWRnZSIsIm5leHRBZnRlck1vdW50IiwibmV4dEFmdGVyVXBkYXRlIiwibmV4dEJlZm9yZVVubW91bnQiLCJpbmplY3QiLCJpbmZlcm5vVHJlZVJlbmRlcmVyIiwiTWFzdGVyIiwiRXh0ZW5kZWQiLCJyZW5kZXJBc3luYyIsIm1peGluUHJvcHMiLCJJbmZlcm5vIiwiVk5vZGVGcm9tSlNPTk1MIiwiQllfVFlQRSIsInRhZzJmbGFncyIsIlN2Z0VsZW1lbnQiLCJJbnB1dEVsZW1lbnQiLCJUZXh0YXJlYUVsZW1lbnQiLCJTZWxlY3RFbGVtZW50IiwiSHRtbEVsZW1lbnQiLCJjb2VyY2VQcm9wcyIsIk5hbWVkTm9kZU1hcCIsIlZvaWQiLCJoYXNTeW1ib2wiLCJnZXRTeW1ib2wiLCJvYnNlcnZhYmxlIiwiZ2V0U3BlY2llcyIsImN0b3IiLCJPYnNlcnZhYmxlIiwiYWRkTWV0aG9kcyIsImRlc2MiLCJjbGVhbnVwU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiY2xlYW51cCIsIl9jbGVhbnVwIiwic3Vic2NyaXB0aW9uQ2xvc2VkIiwiX29ic2VydmVyIiwiY2xvc2VTdWJzY3JpcHRpb24iLCJjbGVhbnVwRnJvbVN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwiU3Vic2NyaXB0aW9uIiwib2JzZXJ2ZXIiLCJzdWJzY3JpYmVyIiwic3RhcnQiLCJTdWJzY3JpcHRpb25PYnNlcnZlciIsImNsZWFudXAkMCIsImVycm9yIiwiY2xvc2VkIiwiX3N1YnNjcmlwdGlvbiIsIm0kMCIsIm0kMSIsIl9zdWJzY3JpYmVyIiwiX18kMCIsIl9fdGhpcyIsInN1YnNjcmliZSIsImVyciIsImNvbXBsZXRlIiwiaGFzU2VlZCIsInNlZWQiLCJhY2MiLCJjb21wbGV0ZWQiLCJzdWJzY3JpcHRpb25zIiwiY2xvc2VJZkRvbmUiLCJtZXRob2QiLCJvYnNlcnZhYmxlJDAiLCJfXyQxIiwiaXRlbSQwIiwiaSQwIiwiUmVzcG9uc2VFbnRyeSIsImJsb2NrSWQiLCJhY3Rpb25JZCIsImhpZGRlblJlc3BvbnNlIiwicmVzcG9uc2UiLCJDaGFsbGVuZ2VFbnRyeSIsImNvbnZlcnNhdGlvblJlZHVjZXIiLCJzZWVkQ29udmVyc2F0aW9uIiwidGhyZWFkIiwiYmxvY2tJbmRleCIsIm1peEJsb2NrV2l0aFBheWxvYWQiLCJwYXlsb2FkIiwic3RhcnRCbG9jayIsInJlcXVpcmVkRmllbGRzIiwibWlzc2luZ1JlcXVpcmVkIiwiY29udGVudFJlZHVjZXIiLCJzaG93Y2FzZVJlZHVjZXIiLCJzaG93Y2FzZVN0YXRlIiwiY29tYmluZWQiLCJocmVmIiwic2hvd2Nhc2UiLCJjcmVhdGVTZWxlY3RvciIsImNyZWF0ZVNlbGVjdG9yQ3JlYXRvciIsImRlZmF1bHRNZW1vaXplIiwiZGVmYXVsdEVxdWFsaXR5Q2hlY2siLCJzdGF0ZWZ1bFNlbGVjdG9yIiwic291cmNlU2VsZWN0b3IiLCJzdGF0ZVJlZmluZXIiLCJzZXRDb21wb25lbnRTdGF0ZSIsInJ1biIsImZ1bmMiLCJlcXVhbGl0eUNoZWNrIiwibGFzdEFyZ3MiLCJsYXN0UmVzdWx0IiwiaXNFcXVhbFRvTGFzdEFyZyIsImV2ZXJ5IiwiZ2V0RGVwZW5kZW5jaWVzIiwiZnVuY3MiLCJkZXBlbmRlbmNpZXMiLCJkZXAiLCJkZXBlbmRlbmN5VHlwZXMiLCJtZW1vaXplIiwibWVtb2l6ZU9wdGlvbnMiLCJyZWNvbXB1dGF0aW9ucyIsInJlc3VsdEZ1bmMiLCJtZW1vaXplZFJlc3VsdEZ1bmMiLCJwYXJhbXMiLCJkZXBlbmRlbmN5IiwicmVzZXRSZWNvbXB1dGF0aW9ucyIsIkxJRkVfSE9PS1MiLCJtaXhpblN0YXRlTGlmZWN5Y2xlIiwiSE9PS1MiLCJiYXNlRm4iLCJzdGF0ZUZyb21TdG9yZSIsInN0b3JlRm9yIiwic3RvcmVGb3JCeVByb3AiLCJzdGF0ZVNlbGVjdG9yIiwicmV0dXJuUGFyYW0iLCJzdGF0ZUV4dHJhY3RvciIsInN0YXRlRXh0cmFjdG9yU2VsZWN0b3IiLCJwYXJlbnRTdGF0ZSIsImRlZmF1bHRQYXJlbnRTdGF0ZSIsImRpc3BhdGNoTWV0aG9kcyIsImNvbXBvbmVudE1ldGhvZE5hbWVzIiwic3RvcmVGb3JDb250ZXh0Iiwic3RvcmVGb3JDb250ZXh0Q3VycnkiLCJhcGkiLCJjcmVhdGVTdG9yZSIsInNlZWRBY3Rpb24iLCJwYXJhbSIsIm5ld1N0b3JlIiwiY29uZmx1eENvbnRleHQiLCJBY3Rpb25UeXBlcyIsImRlZmF1bHRDb250ZXh0IiwiY2hhaW5lZCIsImNoYWluUmVkdWNlcnMiLCJkZWZhdWx0U3RvcmUiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwicmVkdWNlciIsImVuaGFuY2VyIiwibWl4aW5Db250ZXh0IiwicHJlbG9hZGVkU3RhdGUiLCJjdXJyZW50UmVkdWNlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnRMaXN0ZW5lcnMiLCJuZXh0TGlzdGVuZXJzIiwiaXNEaXNwYXRjaGluZyIsIl9jcmVhdGVTdG9yZSIsIklOSVQiLCJkaXNwYXRjaFF1ZXVlZCIsImVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMiLCJpc1N1YnNjcmliZWQiLCJxdWV1ZURpc3BhdGNoIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsImNoYWluIiwic3RhcnRTdGF0ZSIsIkFzU3ViQ29tcG9uZW50IiwiQ29udmVyc2F0aW9uQmxvY2siLCJibG9ja1RlbXBsYXRlIiwianNvbk1MIiwicmVuZGVySlNPTk1MIiwiYmxvY2tWTm9kZSIsIk51bWJlciIsInJlbmRlcmluZyIsImJsb2NrU3RhdHMiLCJjbGFzc2VzIiwibGVmdFRocmVhZCIsInJlbmRlckh0bWxQcm9wcyIsImJ1YmJsZVJpZ2h0IiwiZWRpdGluZyIsIm5leHRCbG9ja0lkIiwiYWN0aW9uUmVuZGVyZXIiLCJTbGlkZXNBY3Rpb24iLCJNZXNzYWdlQWN0aW9uIiwiTm9BY3Rpb24iLCJTZW50ZW5jZUFjdGlvbiIsImlucHV0VHlwZSIsIm9uQmx1ciIsInN0YXRpY1BhcnQiLCJuZXh0UGFydCIsImxvZ0V2ZW50IiwiY2hhbmdlRXZlbnQiLCJBY3Rpb25QYXJ0Iiwic3RhZ2VzIiwib3B0aW9uIiwiY2hvaWNlIiwia2lja29mZiIsIlNob3J0VGhyZWFkQWN0aW9uIiwiaHRtbFByb3BzIiwic3RhcnRBY3Rpb24iLCJhY3Rpb25UZW1wbGF0ZSIsImJldGEiLCJzaG9ydGVuVGV4dCIsInBhcnRzIiwic3RvcmVTdGF0ZSIsIm90aGVyQWN0aW9ucyIsImdldFJlbmRlclByb3BzIiwibWVzc2FnZUFjdGlvbiIsImFjdGl2ZUFjdGlvblR5cGUiLCJzZWxlY3RlZEFjdGlvblR5cGUiLCJDb252ZXJzYXRpb25SZXNwb25zZSIsIm90aGVyIiwib3RoZXJQcm9wcyIsIm1lc3NhZ2VQcm9wcyIsInN0YXJ0TWVzc2FnZUVudHJ5Iiwib25TdWJtaXQiLCJwcmV2ZW50RGVmYXVsdCIsIk90aGVyQWN0aW9ucyIsIk1lc3NhZ2VUb29sYmFyIiwiVGhyZWFkQWN0aW9uIiwic2tpcHMiLCJmb3JtYXR0ZXJzIiwicHJldkNvbG9yIiwiY29sb3JzIiwicHJldlRpbWUiLCJzZWxlY3RDb2xvciIsImRlYnVnIiwibmFtZXNwYWNlIiwiZGlzYWJsZWRSZXR1cm5lZCIsImVuYWJsZWQiLCJlbmFibGVkUmV0dXJuZWQiLCJjdXJyIiwiRGF0ZSIsIm1zIiwiZGlmZiIsInByZXYiLCJ1c2VDb2xvcnMiLCJjb2xvciIsImZvcm1hdCIsImZvcm1hdHRlciIsImxvZ0ZuIiwibG9nIiwiY29uc29sZSIsInN0YWNrIiwiZGVidWdGbiIsImV4dHJhY3RTb3VyY2UiLCJzcmNzZXQiLCJleHRyYWN0TGVhZCIsImFsdCIsIndpZHRoIiwiaGVpZ2h0IiwiQ29udmVyc2F0aW9uVGhyZWFkIiwibGVhZHMiLCJzdGFydFRvcGljIiwiYmxvY2tzIiwiSW5mZXJub0NvbXBhdCIsIkxlYWRzIiwiQ29udmVyc2F0aW9uTGVhZHMiLCJBdXRob3JMaW5lIiwiYXV0aG9yIiwiU2luZ2xlTGVhZCIsImxlYWQiLCJUaHJlYWRQcmVzZW50YXRpb24iLCJ3ZWJzaXRlIiwiaW1nX3NyYyIsImZ1bGxfbmFtZSIsInR3aXR0ZXIiLCJsaW5rZWRpbiIsInRpdGxlIiwiYXV0aG9ycyIsInJlbmRlckhlYWRzIiwicmVuZGVyQXV0aG9yRGV0YWlsIiwicG9zdGVyIiwibXA0IiwiYXV0aG9yS2V5VG9EYXRhIiwicXVlcnlTZWxlY3RvciIsImV4dHJhY3RQcm9wcyIsInRpbWVFbnRyeUZyb21TZWVkIiwiS2lja29mZk1hcmt1cCIsImZvcm0iLCJraWNrb2ZmR29vZ2xlRm9ybSIsInNlbmREYXRhIiwidXJsIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInJlc3BvbnNlVXJsIiwiYWxlcnRQaWNrT25UaW1lbGluZSIsInN1Ym1pdEdvb2dsZUZvcm0iLCJzdWJtaXRJZGVudGl0eSIsInJlbmRlckVudGVyTWVzc2FnZSIsInJlbmRlckluaXRpYWwiLCJyZW5kZXJDb250ZW50IiwicmVnaXN0ZXJDb250ZW50RWxlbWVudHMiLCJzY2FuVGVtcGxhdGVzIiwic3RhcnRDb252ZXJzYXRpb25zIiwidXBncmFkZWQiLCJfc3RhcnRDb252ZXJzYXRpb25zIiwicHJpbWFyeUNvbnZlcnNhdGlvbiIsInNjcm9sbFRvcCIsImRlY29kZUhhc2giLCJuYXYiLCJoYXNoIiwiaGFzaEF0IiwiYXBwbHlCbG9ja0Zyb21IYXNoIiwiYWN0aXZhdGUiLCJjb252ZXJzYXRpb24iLCJhY3RpdmVCbG9jayIsImdldEFjdGlvbiIsIm5hdmlnYXRlIiwiYXBwbHlIaXN0b3J5U3RhdGUiLCJwYXN0IiwiU2hvd2Nhc2VDYXJkIiwiYWN0aW9uVGV4dCIsInNob3djYXNlRnJvbVNlZWQiLCJpbWciLCJhdHRyMSIsImJhY2tncm91bmRJbWFnZSIsImNvZXJjZURhdGUiLCJjb2VyY2VOdW1iZXIiLCJkYXRlTGlrZSIsIm51bWJlckxpa2UiLCJzb3J0U2hvd2Nhc2UiLCJwcmlvcml0eSIsImRhdGUiLCJleHRyYWN0QWN0aW9uIiwic2hvd2Nhc2VzIiwic29ydCIsImhpZGRlbiIsInJlYWwiLCJjbG9uZU5vZGUiLCJkZWxheSIsIm5leHRFbGVtZW50U2libGluZyIsInRvIiwiZWFzZSIsIkxpbmVhciIsImVhc2VOb25lIiwidGltZXJTeW1ib2wiLCJUaW1lQ291bnRkb3duIiwiY2xlYXJUaW1lb3V0IiwiZGF5cyIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJ1cGRhdGVUaW1lIiwic2Vjb25kc19sZWZ0IiwidGltZSIsImdldFRpbWUiLCJub3ciLCJwYXJzZUludCIsIm1zX2xlZnQiLCJzaG93U2Vjb25kcyIsInNldFRpbWVvdXQiLCJob29rQ2FsbGJhY2siLCJzZXRIb29rQ2FsbGJhY2siLCJpc09iamVjdEVtcHR5IiwiaXNEYXRlIiwiaGFzT3duUHJvcCIsImNyZWF0ZVVUQyIsImxvY2FsZSIsInN0cmljdCIsImNyZWF0ZUxvY2FsT3JVVEMiLCJ1dGMiLCJkZWZhdWx0UGFyc2luZ0ZsYWdzIiwiZ2V0UGFyc2luZ0ZsYWdzIiwiX3BmIiwiZnVuIiwidCIsImlzVmFsaWQiLCJfaXNWYWxpZCIsInBhcnNlZFBhcnRzIiwicGFyc2VkRGF0ZVBhcnRzIiwiaXNOb3dWYWxpZCIsIl9kIiwib3ZlcmZsb3ciLCJlbXB0eSIsImludmFsaWRNb250aCIsImludmFsaWRXZWVrZGF5IiwibnVsbElucHV0IiwiaW52YWxpZEZvcm1hdCIsInVzZXJJbnZhbGlkYXRlZCIsIm1lcmlkaWVtIiwiX3N0cmljdCIsImNoYXJzTGVmdE92ZXIiLCJ1bnVzZWRUb2tlbnMiLCJiaWdIb3VyIiwiaXNGcm96ZW4iLCJjcmVhdGVJbnZhbGlkIiwiTmFOIiwibW9tZW50UHJvcGVydGllcyIsImNvcHlDb25maWciLCJfaXNBTW9tZW50T2JqZWN0IiwiX2YiLCJfbCIsIl90em0iLCJfaXNVVEMiLCJfb2Zmc2V0IiwiX2xvY2FsZSIsInVwZGF0ZUluUHJvZ3Jlc3MiLCJNb21lbnQiLCJjb25maWciLCJ1cGRhdGVPZmZzZXQiLCJpc01vbWVudCIsImFic0Zsb29yIiwibnVtYmVyIiwidG9JbnQiLCJhcmd1bWVudEZvckNvZXJjaW9uIiwiY29lcmNlZE51bWJlciIsImlzRmluaXRlIiwiY29tcGFyZUFycmF5cyIsImFycmF5MSIsImFycmF5MiIsImRvbnRDb252ZXJ0IiwibGVuZ3RoRGlmZiIsImFicyIsImRpZmZzIiwic3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzIiwiZGVwcmVjYXRlIiwiZmlyc3RUaW1lIiwiZGVwcmVjYXRpb25IYW5kbGVyIiwiZGVwcmVjYXRpb25zIiwiZGVwcmVjYXRlU2ltcGxlIiwiX2NvbmZpZyIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwiX29yZGluYWxQYXJzZSIsIm1lcmdlQ29uZmlncyIsInBhcmVudENvbmZpZyIsImNoaWxkQ29uZmlnIiwiTG9jYWxlIiwiZGVmYXVsdENhbGVuZGFyIiwiY2FsZW5kYXIiLCJtb20iLCJvdXRwdXQiLCJfY2FsZW5kYXIiLCJkZWZhdWx0TG9uZ0RhdGVGb3JtYXQiLCJsb25nRGF0ZUZvcm1hdCIsIl9sb25nRGF0ZUZvcm1hdCIsImZvcm1hdFVwcGVyIiwidG9VcHBlckNhc2UiLCJkZWZhdWx0SW52YWxpZERhdGUiLCJpbnZhbGlkRGF0ZSIsIl9pbnZhbGlkRGF0ZSIsImRlZmF1bHRPcmRpbmFsIiwiZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJvcmRpbmFsIiwiX29yZGluYWwiLCJkZWZhdWx0UmVsYXRpdmVUaW1lIiwicmVsYXRpdmVUaW1lIiwid2l0aG91dFN1ZmZpeCIsImlzRnV0dXJlIiwiX3JlbGF0aXZlVGltZSIsInBhc3RGdXR1cmUiLCJhbGlhc2VzIiwiYWRkVW5pdEFsaWFzIiwidW5pdCIsInNob3J0aGFuZCIsImxvd2VyQ2FzZSIsIm5vcm1hbGl6ZVVuaXRzIiwidW5pdHMiLCJub3JtYWxpemVPYmplY3RVbml0cyIsImlucHV0T2JqZWN0Iiwibm9ybWFsaXplZElucHV0Iiwibm9ybWFsaXplZFByb3AiLCJwcmlvcml0aWVzIiwiYWRkVW5pdFByaW9yaXR5IiwiZ2V0UHJpb3JpdGl6ZWRVbml0cyIsInVuaXRzT2JqIiwibWFrZUdldFNldCIsImtlZXBUaW1lIiwic3RyaW5nR2V0Iiwic3RyaW5nU2V0IiwicHJpb3JpdGl6ZWQiLCJ6ZXJvRmlsbCIsInRhcmdldExlbmd0aCIsImZvcmNlU2lnbiIsImFic051bWJlciIsInplcm9zVG9GaWxsIiwic2lnbiIsInBvdyIsImZvcm1hdHRpbmdUb2tlbnMiLCJsb2NhbEZvcm1hdHRpbmdUb2tlbnMiLCJmb3JtYXRGdW5jdGlvbnMiLCJmb3JtYXRUb2tlbkZ1bmN0aW9ucyIsImFkZEZvcm1hdFRva2VuIiwidG9rZW4iLCJwYWRkZWQiLCJsb2NhbGVEYXRhIiwicmVtb3ZlRm9ybWF0dGluZ1Rva2VucyIsIm1ha2VGb3JtYXRGdW5jdGlvbiIsImFycmF5IiwiZm9ybWF0TW9tZW50IiwiZXhwYW5kRm9ybWF0IiwicmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zIiwibGFzdEluZGV4IiwibWF0Y2gxIiwibWF0Y2gyIiwibWF0Y2gzIiwibWF0Y2g0IiwibWF0Y2g2IiwibWF0Y2gxdG8yIiwibWF0Y2gzdG80IiwibWF0Y2g1dG82IiwibWF0Y2gxdG8zIiwibWF0Y2gxdG80IiwibWF0Y2gxdG82IiwibWF0Y2hVbnNpZ25lZCIsIm1hdGNoU2lnbmVkIiwibWF0Y2hPZmZzZXQiLCJtYXRjaFNob3J0T2Zmc2V0IiwibWF0Y2hUaW1lc3RhbXAiLCJtYXRjaFdvcmQiLCJyZWdleGVzIiwiYWRkUmVnZXhUb2tlbiIsInJlZ2V4Iiwic3RyaWN0UmVnZXgiLCJpc1N0cmljdCIsImdldFBhcnNlUmVnZXhGb3JUb2tlbiIsInVuZXNjYXBlRm9ybWF0IiwicmVnZXhFc2NhcGUiLCJtYXRjaGVkIiwicDEiLCJwMiIsInAzIiwicDQiLCJ0b2tlbnMiLCJhZGRQYXJzZVRva2VuIiwiYWRkV2Vla1BhcnNlVG9rZW4iLCJfdyIsImFkZFRpbWVUb0FycmF5RnJvbVRva2VuIiwiX2EiLCJZRUFSIiwiTU9OVEgiLCJEQVRFIiwiSE9VUiIsIk1JTlVURSIsIlNFQ09ORCIsIk1JTExJU0VDT05EIiwiV0VFSyIsIldFRUtEQVkiLCJkYXlzSW5Nb250aCIsInllYXIiLCJtb250aCIsIlVUQyIsImdldFVUQ0RhdGUiLCJtb250aHNTaG9ydCIsIm1vbnRocyIsIm1vbnRoc1Nob3J0UmVnZXgiLCJtb250aHNSZWdleCIsIm1vbnRoc1BhcnNlIiwiTU9OVEhTX0lOX0ZPUk1BVCIsImRlZmF1bHRMb2NhbGVNb250aHMiLCJsb2NhbGVNb250aHMiLCJfbW9udGhzIiwiaXNGb3JtYXQiLCJkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQiLCJsb2NhbGVNb250aHNTaG9ydCIsIl9tb250aHNTaG9ydCIsImhhbmRsZVN0cmljdFBhcnNlIiwibW9udGhOYW1lIiwiaWkiLCJsbGMiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsIl9tb250aHNQYXJzZSIsIl9sb25nTW9udGhzUGFyc2UiLCJfc2hvcnRNb250aHNQYXJzZSIsImxvY2FsZU1vbnRoc1BhcnNlIiwiX21vbnRoc1BhcnNlRXhhY3QiLCJzZXRNb250aCIsImRheU9mTW9udGgiLCJnZXRTZXRNb250aCIsImdldERheXNJbk1vbnRoIiwiZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXgiLCJfbW9udGhzU2hvcnRTdHJpY3RSZWdleCIsIl9tb250aHNTaG9ydFJlZ2V4IiwiZGVmYXVsdE1vbnRoc1JlZ2V4IiwiX21vbnRoc1N0cmljdFJlZ2V4IiwiX21vbnRoc1JlZ2V4IiwiY29tcHV0ZU1vbnRoc1BhcnNlIiwiY21wTGVuUmV2Iiwic2hvcnRQaWVjZXMiLCJsb25nUGllY2VzIiwibWl4ZWRQaWVjZXMiLCJwYXJzZVR3b0RpZ2l0WWVhciIsImRheXNJblllYXIiLCJpc0xlYXBZZWFyIiwiZ2V0U2V0WWVhciIsImdldElzTGVhcFllYXIiLCJjcmVhdGVEYXRlIiwiZCIsImgiLCJNIiwiZ2V0RnVsbFllYXIiLCJzZXRGdWxsWWVhciIsImNyZWF0ZVVUQ0RhdGUiLCJnZXRVVENGdWxsWWVhciIsInNldFVUQ0Z1bGxZZWFyIiwiZmlyc3RXZWVrT2Zmc2V0IiwiZG93IiwiZG95IiwiZndkIiwiZ2V0VVRDRGF5IiwiZndkbHciLCJkYXlPZlllYXJGcm9tV2Vla3MiLCJ3ZWVrIiwid2Vla2RheSIsImxvY2FsV2Vla2RheSIsIndlZWtPZmZzZXQiLCJkYXlPZlllYXIiLCJyZXNZZWFyIiwicmVzRGF5T2ZZZWFyIiwid2Vla09mWWVhciIsInJlc1dlZWsiLCJ3ZWVrc0luWWVhciIsIndlZWtPZmZzZXROZXh0IiwibG9jYWxlV2VlayIsIl93ZWVrIiwiZGVmYXVsdExvY2FsZVdlZWsiLCJsb2NhbGVGaXJzdERheU9mV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZZZWFyIiwiZ2V0U2V0V2VlayIsImdldFNldElTT1dlZWsiLCJ3ZWVrZGF5c01pbiIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5cyIsIndlZWtkYXlzTWluUmVnZXgiLCJ3ZWVrZGF5c1Nob3J0UmVnZXgiLCJ3ZWVrZGF5c1JlZ2V4Iiwid2Vla2RheXNQYXJzZSIsInBhcnNlV2Vla2RheSIsInBhcnNlSXNvV2Vla2RheSIsImRlZmF1bHRMb2NhbGVXZWVrZGF5cyIsImxvY2FsZVdlZWtkYXlzIiwiX3dlZWtkYXlzIiwiZGF5IiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQiLCJsb2NhbGVXZWVrZGF5c1Nob3J0IiwiX3dlZWtkYXlzU2hvcnQiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4iLCJsb2NhbGVXZWVrZGF5c01pbiIsIl93ZWVrZGF5c01pbiIsIndlZWtkYXlOYW1lIiwiX3dlZWtkYXlzUGFyc2UiLCJfc2hvcnRXZWVrZGF5c1BhcnNlIiwiX21pbldlZWtkYXlzUGFyc2UiLCJsb2NhbGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzUGFyc2VFeGFjdCIsIl9mdWxsV2Vla2RheXNQYXJzZSIsImdldFNldERheU9mV2VlayIsImdldERheSIsImdldFNldExvY2FsZURheU9mV2VlayIsImdldFNldElTT0RheU9mV2VlayIsImRlZmF1bHRXZWVrZGF5c1JlZ2V4IiwiX3dlZWtkYXlzU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNSZWdleCIsImRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzU2hvcnRSZWdleCIsImRlZmF1bHRXZWVrZGF5c01pblJlZ2V4IiwiX3dlZWtkYXlzTWluU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNNaW5SZWdleCIsImNvbXB1dGVXZWVrZGF5c1BhcnNlIiwibWluUGllY2VzIiwibWlucCIsInNob3J0cCIsImxvbmdwIiwiaEZvcm1hdCIsImtGb3JtYXQiLCJsb3dlcmNhc2UiLCJtYXRjaE1lcmlkaWVtIiwiX21lcmlkaWVtUGFyc2UiLCJrSW5wdXQiLCJfaXNQbSIsImlzUE0iLCJfbWVyaWRpZW0iLCJwb3MxIiwicG9zMiIsImxvY2FsZUlzUE0iLCJkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSIsImxvY2FsZU1lcmlkaWVtIiwiaXNMb3dlciIsImdldFNldEhvdXIiLCJiYXNlQ29uZmlnIiwibG9jYWxlcyIsImxvY2FsZUZhbWlsaWVzIiwiZ2xvYmFsTG9jYWxlIiwibm9ybWFsaXplTG9jYWxlIiwiY2hvb3NlTG9jYWxlIiwibG9hZExvY2FsZSIsIm9sZExvY2FsZSIsIl9hYmJyIiwiZ2V0U2V0R2xvYmFsTG9jYWxlIiwiZ2V0TG9jYWxlIiwiZGVmaW5lTG9jYWxlIiwiYWJiciIsInBhcmVudExvY2FsZSIsInVwZGF0ZUxvY2FsZSIsImxpc3RMb2NhbGVzIiwiY2hlY2tPdmVyZmxvdyIsIl9vdmVyZmxvd0RheU9mWWVhciIsIl9vdmVyZmxvd1dlZWtzIiwiX292ZXJmbG93V2Vla2RheSIsImV4dGVuZGVkSXNvUmVnZXgiLCJiYXNpY0lzb1JlZ2V4IiwidHpSZWdleCIsImlzb0RhdGVzIiwiaXNvVGltZXMiLCJhc3BOZXRKc29uUmVnZXgiLCJjb25maWdGcm9tSVNPIiwiYWxsb3dUaW1lIiwiZGF0ZUZvcm1hdCIsInRpbWVGb3JtYXQiLCJ0ekZvcm1hdCIsImlzbyIsImJhc2ljUmZjUmVnZXgiLCJjb25maWdGcm9tUkZDMjgyMiIsImRheUZvcm1hdCIsInRpbWV6b25lcyIsIm1pbGl0YXJ5IiwidGltZXpvbmUiLCJ0aW1lem9uZUluZGV4IiwibW9tZW50RGF0ZSIsIm1vbWVudERheSIsIndlZWtkYXlNaXNtYXRjaCIsInJmYzI4MjIiLCJjb25maWdGcm9tU3RyaW5nIiwiY3JlYXRlRnJvbUlucHV0RmFsbGJhY2siLCJfdXNlVVRDIiwiY3VycmVudERhdGVBcnJheSIsIm5vd1ZhbHVlIiwiZ2V0VVRDTW9udGgiLCJnZXRNb250aCIsImdldERhdGUiLCJjb25maWdGcm9tQXJyYXkiLCJjdXJyZW50RGF0ZSIsInllYXJUb1VzZSIsIl9kYXlPZlllYXIiLCJfbmV4dERheSIsInNldFVUQ01pbnV0ZXMiLCJnZXRVVENNaW51dGVzIiwiZGF5T2ZZZWFyRnJvbVdlZWtJbmZvIiwid2Vla1llYXIiLCJ3ZWVrZGF5T3ZlcmZsb3ciLCJHRyIsImNyZWF0ZUxvY2FsIiwiY3VyV2VlayIsImdnIiwiSVNPXzg2MDEiLCJSRkNfMjgyMiIsImNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQiLCJwYXJzZWRJbnB1dCIsInNraXBwZWQiLCJzdHJpbmdMZW5ndGgiLCJ0b3RhbFBhcnNlZElucHV0TGVuZ3RoIiwidW51c2VkSW5wdXQiLCJtZXJpZGllbUZpeFdyYXAiLCJob3VyIiwiaXNQbSIsIm1lcmlkaWVtSG91ciIsImNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheSIsInRlbXBDb25maWciLCJiZXN0TW9tZW50Iiwic2NvcmVUb0JlYXQiLCJjdXJyZW50U2NvcmUiLCJzY29yZSIsImNvbmZpZ0Zyb21PYmplY3QiLCJtaW51dGUiLCJtaWxsaXNlY29uZCIsImNyZWF0ZUZyb21Db25maWciLCJwcmVwYXJlQ29uZmlnIiwicHJlcGFyc2UiLCJjb25maWdGcm9tSW5wdXQiLCJpc1VUQyIsInByb3RvdHlwZU1pbiIsInByb3RvdHlwZU1heCIsInBpY2tCeSIsIm1vbWVudHMiLCJvcmRlcmluZyIsImlzRHVyYXRpb25WYWxpZCIsInVuaXRIYXNEZWNpbWFsIiwicGFyc2VGbG9hdCIsImNyZWF0ZUR1cmF0aW9uIiwiRHVyYXRpb24iLCJkdXJhdGlvbiIsInllYXJzIiwicXVhcnRlcnMiLCJxdWFydGVyIiwid2Vla3MiLCJtaWxsaXNlY29uZHMiLCJfbWlsbGlzZWNvbmRzIiwiX2RheXMiLCJfZGF0YSIsIl9idWJibGUiLCJpc0R1cmF0aW9uIiwiYWJzUm91bmQiLCJyb3VuZCIsIm9mZnNldCIsInNlcGFyYXRvciIsInV0Y09mZnNldCIsIm9mZnNldEZyb21TdHJpbmciLCJjaHVua09mZnNldCIsIm1hdGNoZXIiLCJjaHVuayIsImNsb25lV2l0aE9mZnNldCIsIm1vZGVsIiwiY2xvbmUiLCJzZXRUaW1lIiwibG9jYWwiLCJnZXREYXRlT2Zmc2V0IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJnZXRTZXRPZmZzZXQiLCJrZWVwTG9jYWxUaW1lIiwia2VlcE1pbnV0ZXMiLCJsb2NhbEFkanVzdCIsIl9jaGFuZ2VJblByb2dyZXNzIiwiZ2V0U2V0Wm9uZSIsInNldE9mZnNldFRvVVRDIiwic2V0T2Zmc2V0VG9Mb2NhbCIsInN1YnRyYWN0Iiwic2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQiLCJ0Wm9uZSIsImhhc0FsaWduZWRIb3VyT2Zmc2V0IiwiaXNEYXlsaWdodFNhdmluZ1RpbWUiLCJpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQiLCJfaXNEU1RTaGlmdGVkIiwiaXNMb2NhbCIsImlzVXRjT2Zmc2V0IiwiaXNVdGMiLCJhc3BOZXRSZWdleCIsImlzb1JlZ2V4IiwiZGlmZlJlcyIsInBhcnNlSXNvIiwibW9tZW50c0RpZmZlcmVuY2UiLCJpbnZhbGlkIiwiaW5wIiwicG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZSIsImlzQWZ0ZXIiLCJpc0JlZm9yZSIsImNyZWF0ZUFkZGVyIiwiZGlyZWN0aW9uIiwicGVyaW9kIiwiZHVyIiwidG1wIiwiYWRkU3VidHJhY3QiLCJpc0FkZGluZyIsImdldENhbGVuZGFyRm9ybWF0IiwibXlNb21lbnQiLCJmb3JtYXRzIiwic29kIiwic3RhcnRPZiIsImNhbGVuZGFyRm9ybWF0IiwibG9jYWxJbnB1dCIsImVuZE9mIiwiaXNCZXR3ZWVuIiwiaW5jbHVzaXZpdHkiLCJpc1NhbWUiLCJpbnB1dE1zIiwiaXNTYW1lT3JBZnRlciIsImlzU2FtZU9yQmVmb3JlIiwiYXNGbG9hdCIsInpvbmVEZWx0YSIsImRlbHRhIiwibW9udGhEaWZmIiwid2hvbGVNb250aERpZmYiLCJhbmNob3IyIiwiYWRqdXN0IiwiYW5jaG9yIiwiZGVmYXVsdEZvcm1hdCIsImRlZmF1bHRGb3JtYXRVdGMiLCJ0b0lTT1N0cmluZyIsInRvRGF0ZSIsImluc3BlY3QiLCJ6b25lIiwicHJlZml4IiwiZGF0ZXRpbWUiLCJzdWZmaXgiLCJpbnB1dFN0cmluZyIsInBvc3Rmb3JtYXQiLCJodW1hbml6ZSIsImZyb21Ob3ciLCJ0b05vdyIsIm5ld0xvY2FsZURhdGEiLCJsYW5nIiwiaXNvV2Vla2RheSIsInVuaXgiLCJ0b0pTT04iLCJwYXJzaW5nRmxhZ3MiLCJpbnZhbGlkQXQiLCJjcmVhdGlvbkRhdGEiLCJpc29XZWVrWWVhciIsImFkZFdlZWtZZWFyRm9ybWF0VG9rZW4iLCJnZXR0ZXIiLCJnZXRTZXRXZWVrWWVhciIsImdldFNldFdlZWtZZWFySGVscGVyIiwiZ2V0U2V0SVNPV2Vla1llYXIiLCJpc29XZWVrIiwiZ2V0SVNPV2Vla3NJblllYXIiLCJnZXRXZWVrc0luWWVhciIsIndlZWtJbmZvIiwid2Vla3NUYXJnZXQiLCJzZXRXZWVrQWxsIiwiZGF5T2ZZZWFyRGF0YSIsImdldFNldFF1YXJ0ZXIiLCJnZXRTZXREYXlPZk1vbnRoIiwiZ2V0U2V0RGF5T2ZZZWFyIiwiZ2V0U2V0TWludXRlIiwiZ2V0U2V0U2Vjb25kIiwicGFyc2VNcyIsImdldFNldE1pbGxpc2Vjb25kIiwiZ2V0Wm9uZUFiYnIiLCJnZXRab25lTmFtZSIsImlzb1dlZWtzIiwiaXNvV2Vla3NJblllYXIiLCJwYXJzZVpvbmUiLCJpc0RTVCIsInpvbmVBYmJyIiwiem9uZU5hbWUiLCJkYXRlcyIsImlzRFNUU2hpZnRlZCIsImNyZWF0ZVVuaXgiLCJjcmVhdGVJblpvbmUiLCJwcmVQYXJzZVBvc3RGb3JtYXQiLCJmaXJzdERheU9mWWVhciIsImZpcnN0RGF5T2ZXZWVrIiwibGlzdE1vbnRoc0ltcGwiLCJsaXN0V2Vla2RheXNJbXBsIiwibG9jYWxlU29ydGVkIiwibGlzdE1vbnRocyIsImxpc3RNb250aHNTaG9ydCIsImxpc3RXZWVrZGF5cyIsImxpc3RXZWVrZGF5c1Nob3J0IiwibGlzdFdlZWtkYXlzTWluIiwibGFuZ0RhdGEiLCJtYXRoQWJzIiwiYWJzQ2VpbCIsImJ1YmJsZSIsIm1vbnRoc0Zyb21EYXlzIiwibW9udGhzVG9EYXlzIiwiZGF5c1RvTW9udGhzIiwiYXMiLCJtYWtlQXMiLCJhbGlhcyIsImFzTWlsbGlzZWNvbmRzIiwiYXNTZWNvbmRzIiwiYXNNaW51dGVzIiwiYXNIb3VycyIsImFzRGF5cyIsImFzV2Vla3MiLCJhc01vbnRocyIsImFzWWVhcnMiLCJtYWtlR2V0dGVyIiwidGhyZXNob2xkcyIsInN1YnN0aXR1dGVUaW1lQWdvIiwicG9zTmVnRHVyYXRpb24iLCJzcyIsImdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIiwicm91bmRpbmdGdW5jdGlvbiIsImdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCIsInRocmVzaG9sZCIsImxpbWl0Iiwid2l0aFN1ZmZpeCIsIlkiLCJ0b3RhbCIsInRvSXNvU3RyaW5nIiwibW9tZW50IiwicmVsYXRpdmVUaW1lUm91bmRpbmciLCJyZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJUcmFja1BsYW4iLCJsYXN0VHJhY2tOYW1lIiwidHJhY2tzIiwidHJhY2tOYW1lIiwiZnJvbUNvZGVQb2ludCIsImNvZGVQb2ludEF0IiwidHJhY2siLCJGbG93U2xpZGVzIiwic2VlZGVycyIsInBsYW4iLCJzZWVkZXIiLCJzbGlkZUNvbnRlbnQiLCJmb3JFYWNoQ29sdW1uIiwiY29sdW1uIiwib3JkZXIiLCJzbGlkZSIsImFuaW1hdGluZyIsInJ1bnMiLCJhbmltYXRlTmV4dENvbHVtbiIsInJlbW92ZSIsIkZsb3dUaW1lIiwib3JpZ2luYWxDaGlsZHJlbiIsInNob3dVdGMiLCJkZXNjcmlwdGlvbiIsImludGVydmFsb21ldGVyIiwiY2IiLCJyZXF1ZXN0IiwiY2FuY2VsIiwicmVxdWVzdFBhcmFtZXRlciIsInJlcXVlc3RJZCIsInByZXZpb3VzTG9vcFRpbWUiLCJsb29wIiwic3RvcCIsImZyYW1lSW50ZXJ2YWxvbWV0ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInByZXZlbnRFdmVudCIsInRvZ2dsZVByb3BlcnR5IiwicHJldmVudFdpdGhQcm9wZXJ0eSIsImhhbmRsZXIiLCJwcm94eVByb3BlcnR5IiwicHJvcGVydHlOYW1lIiwic291cmNlT2JqZWN0IiwiY29weUZpcnN0IiwicHJveHlFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJkaXNwYXRjaEV2ZW50QXN5bmMiLCJpc1doaXRlbGlzdGVkIiwiaGVhZCIsInVzZXJBZ2VudCIsIm1hdGNoTWVkaWEiLCLgsqAiLCLgsqBldmVudCIsIuCyoHBsYXkiLCLgsqBwYXVzZSIsImdldEF1ZGlvRnJvbVZpZGVvIiwidmlkZW8iLCJhdWRpbyIsIkF1ZGlvIiwiY3Jvc3NPcmlnaW4iLCJjdXJyZW50U3JjIiwibGFzdFJlcXVlc3RzIiwicmVxdWVzdEluZGV4IiwibGFzdFRpbWV1cGRhdGVFdmVudCIsInJlbWVtYmVyT25seSIsImN1cnJlbnRUaW1lIiwiaXNQbGF5ZXJFbmRlZCIsInBsYXllciIsImRyaXZlciIsInVwZGF0ZSIsInRpbWVEaWZmIiwicmVhZHlTdGF0ZSIsIkhBVkVfRlVUVVJFX0RBVEEiLCJoYXNBdWRpbyIsInBsYXliYWNrUmF0ZSIsIm5ldHdvcmtTdGF0ZSIsIk5FVFdPUktfSURMRSIsImJ1ZmZlcmVkIiwibG9hZCIsImVuZGVkIiwicGF1c2UiLCJwbGF5Iiwid2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4iLCJwYXVzZWQiLCJIQVZFX0VOT1VHSF9EQVRBIiwiZm9yY2VFdmVudHMiLCJhZGRQbGF5ZXIiLCJ3YXNFbXB0eSIsIm92ZXJsb2FkQVBJIiwiZW5hYmxlSW5saW5lVmlkZW8iLCJvbmx5V2hpdGVsaXN0ZWQiLCJhdXRvcGxheSIsInZpZGVvcyIsImlzSW5WaWV3IiwicGxheWluZyIsImhpZGRlbkRvYyIsInZpc2liaWxpdHlDaGFuZ2UiLCJtc0hpZGRlbiIsIndlYmtpdEhpZGRlbiIsImV2IiwiRmxvd1ZpZGVvIiwiaW50ZXJhY3RpdmUiLCJhdXRvcGxheWluZyIsInVubXV0ZSIsIm11dGVkIiwidXNlck11dGVkIiwibWFya2VkTXV0ZSIsInZvbHVtZSIsImZsb3dCdXR0b25zIiwidGFwQnV0dG9uIiwiYnV0dG9uIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsImxlZnQiLCJib3R0b20iLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsInJpZ2h0IiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwiX2F1dG9wbGF5aW5nIiwiVHlwZWZvcm1TaGFyZUJ1dHRvbiIsImNvZGUiLCJNRExDYXJkIiwidGVzdFRlc3QiLCJjdXN0b21FbGVtZW50cyIsIm92ZXJsYXllZFRvcGljcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsU0FBU0MsY0FBQSxHQUFpQixPQUFPQyxNQUFQLElBQWlCLFdBQWpCLElBQWdDQSxPQUFPQyxJQUFQLElBQWVBLElBQS9DLEdBQzFCRCxNQUQwQixHQUNqQixPQUFPRSxJQUFQLElBQWUsV0FBZixJQUE4QkEsS0FBS0QsSUFBTCxJQUFhQSxJQUEzQyxHQUFrREM7O0VBRTNEQyxTQUFTLGFBQVQsR0FISjtBQUlBLElBQUksT0FBT0MsR0FBUCxJQUFjLFFBQWxCLEVBQTRCQSxNQUFNTixNQUFOOzs7O0FDTDVCLElBQUlPLE9BQU9OLGNBQUEsR0FBaUIsRUFBRU8sU0FBUyxPQUFYLEVBQTVCO0FBQ0EsSUFBSSxPQUFPQyxHQUFQLElBQWMsUUFBbEIsRUFBNEJBLE1BQU1GLElBQU47OztBQ0Q1Qk4sYUFBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7U0FDdEIsUUFBT0EsRUFBUCxxREFBT0EsRUFBUCxPQUFjLFFBQWQsR0FBeUJBLE9BQU8sSUFBaEMsR0FBdUMsT0FBT0EsRUFBUCxLQUFjLFVBQTVEO0NBREY7O0FDQUEsSUFBSUMsV0FBV0MsU0FBZjtBQUNBWCxhQUFBLEdBQWlCLFVBQVVTLEVBQVYsRUFBYztNQUN6QixDQUFDQyxTQUFTRCxFQUFULENBQUwsRUFBbUIsTUFBTUcsVUFBVUgsS0FBSyxvQkFBZixDQUFOO1NBQ1pBLEVBQVA7Q0FGRjs7QUNEQVQsVUFBQSxHQUFpQixVQUFVYSxJQUFWLEVBQWdCO01BQzNCO1dBQ0ssQ0FBQyxDQUFDQSxNQUFUO0dBREYsQ0FFRSxPQUFPQyxDQUFQLEVBQVU7V0FDSCxJQUFQOztDQUpKOztBQ0FBO0FBQ0FkLGdCQUFBLEdBQWlCLENBQUNXLE9BQW9CLFlBQVk7U0FDekNJLE9BQU9DLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsR0FBMUIsRUFBK0IsRUFBRUMsS0FBSyxlQUFZO2FBQVMsQ0FBUDtLQUFyQixFQUEvQixFQUFtRUMsQ0FBbkUsSUFBd0UsQ0FBL0U7Q0FEZ0IsQ0FBbEI7O0FDREEsSUFBSVIsYUFBV0MsU0FBZjtBQUNBLElBQUlRLGFBQVdSLFFBQXFCUSxRQUFwQzs7QUFFQSxJQUFJQyxPQUFLVixXQUFTUyxVQUFULEtBQXNCVCxXQUFTUyxXQUFTRSxhQUFsQixDQUEvQjtBQUNBckIsY0FBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7U0FDdEJXLE9BQUtELFdBQVNFLGFBQVQsQ0FBdUJaLEVBQXZCLENBQUwsR0FBa0MsRUFBekM7Q0FERjs7QUNKQVQsaUJBQUEsR0FBaUIsQ0FBQ1csWUFBRCxJQUE4QixDQUFDQSxPQUFvQixZQUFZO1NBQ3ZFSSxPQUFPQyxjQUFQLENBQXNCTCxXQUF5QixLQUF6QixDQUF0QixFQUF1RCxHQUF2RCxFQUE0RCxFQUFFTSxLQUFLLGVBQVk7YUFBUyxDQUFQO0tBQXJCLEVBQTVELEVBQWdHQyxDQUFoRyxJQUFxRyxDQUE1RztDQUQ4QyxDQUFoRDs7QUNBQTtBQUNBLElBQUlSLGFBQVdDLFNBQWY7OztBQUdBWCxnQkFBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWNhLENBQWQsRUFBaUI7TUFDNUIsQ0FBQ1osV0FBU0QsRUFBVCxDQUFMLEVBQW1CLE9BQU9BLEVBQVA7TUFDZmMsRUFBSixFQUFRQyxHQUFSO01BQ0lGLEtBQUssUUFBUUMsS0FBS2QsR0FBR2dCLFFBQWhCLEtBQTZCLFVBQWxDLElBQWdELENBQUNmLFdBQVNjLE1BQU1ELEdBQUdHLElBQUgsQ0FBUWpCLEVBQVIsQ0FBZixDQUFyRCxFQUFrRixPQUFPZSxHQUFQO01BQzlFLFFBQVFELEtBQUtkLEdBQUdrQixPQUFoQixLQUE0QixVQUE1QixJQUEwQyxDQUFDakIsV0FBU2MsTUFBTUQsR0FBR0csSUFBSCxDQUFRakIsRUFBUixDQUFmLENBQS9DLEVBQTRFLE9BQU9lLEdBQVA7TUFDeEUsQ0FBQ0YsQ0FBRCxJQUFNLFFBQVFDLEtBQUtkLEdBQUdnQixRQUFoQixLQUE2QixVQUFuQyxJQUFpRCxDQUFDZixXQUFTYyxNQUFNRCxHQUFHRyxJQUFILENBQVFqQixFQUFSLENBQWYsQ0FBdEQsRUFBbUYsT0FBT2UsR0FBUDtRQUM3RVosVUFBVSx5Q0FBVixDQUFOO0NBTkY7O0FDSkEsSUFBSWdCLFdBQVdqQixTQUFmO0FBQ0EsSUFBSWtCLGlCQUFpQmxCLGFBQXJCO0FBQ0EsSUFBSW1CLGNBQWNuQixZQUFsQjtBQUNBLElBQUlvQixPQUFLaEIsT0FBT0MsY0FBaEI7O0FBRUFnQixVQUFZckIsZUFBNEJJLE9BQU9DLGNBQW5DLEdBQW9ELFNBQVNBLGNBQVQsQ0FBd0JpQixDQUF4QixFQUEyQkMsQ0FBM0IsRUFBOEJDLFVBQTlCLEVBQTBDO1dBQy9GRixDQUFUO01BQ0lILFlBQVlJLENBQVosRUFBZSxJQUFmLENBQUo7V0FDU0MsVUFBVDtNQUNJTixjQUFKLEVBQW9CLElBQUk7V0FDZkUsS0FBR0UsQ0FBSCxFQUFNQyxDQUFOLEVBQVNDLFVBQVQsQ0FBUDtHQURrQixDQUVsQixPQUFPckIsQ0FBUCxFQUFVO01BQ1IsU0FBU3FCLFVBQVQsSUFBdUIsU0FBU0EsVUFBcEMsRUFBZ0QsTUFBTXZCLFVBQVUsMEJBQVYsQ0FBTjtNQUM1QyxXQUFXdUIsVUFBZixFQUEyQkYsRUFBRUMsQ0FBRixJQUFPQyxXQUFXQyxLQUFsQjtTQUNwQkgsQ0FBUDtDQVRGOzs7Ozs7QUNMQWpDLGlCQUFBLEdBQWlCLFVBQVVxQyxNQUFWLEVBQWtCRCxLQUFsQixFQUF5QjtTQUNqQztnQkFDTyxFQUFFQyxTQUFTLENBQVgsQ0FEUDtrQkFFUyxFQUFFQSxTQUFTLENBQVgsQ0FGVDtjQUdLLEVBQUVBLFNBQVMsQ0FBWCxDQUhMO1dBSUVEO0dBSlQ7Q0FERjs7QUNBQSxJQUFJTCxLQUFLcEIsU0FBVDtBQUNBLElBQUkyQixhQUFhM0IsYUFBakI7QUFDQVgsU0FBQSxHQUFpQlcsZUFBNEIsVUFBVTRCLE1BQVYsRUFBa0JDLEdBQWxCLEVBQXVCSixLQUF2QixFQUE4QjtTQUNsRUwsR0FBR1UsQ0FBSCxDQUFLRixNQUFMLEVBQWFDLEdBQWIsRUFBa0JGLFdBQVcsQ0FBWCxFQUFjRixLQUFkLENBQWxCLENBQVA7Q0FEZSxHQUViLFVBQVVHLE1BQVYsRUFBa0JDLEdBQWxCLEVBQXVCSixLQUF2QixFQUE4QjtTQUN6QkksR0FBUCxJQUFjSixLQUFkO1NBQ09HLE1BQVA7Q0FKRjs7QUNGQSxJQUFJRyxpQkFBaUIsR0FBR0EsY0FBeEI7QUFDQTFDLFFBQUEsR0FBaUIsVUFBVVMsRUFBVixFQUFjK0IsR0FBZCxFQUFtQjtTQUMzQkUsZUFBZWhCLElBQWYsQ0FBb0JqQixFQUFwQixFQUF3QitCLEdBQXhCLENBQVA7Q0FERjs7QUNEQSxJQUFJRyxLQUFLLENBQVQ7QUFDQSxJQUFJQyxLQUFLMUMsS0FBSzJDLE1BQUwsRUFBVDtBQUNBN0MsUUFBQSxHQUFpQixVQUFVd0MsR0FBVixFQUFlO1NBQ3ZCLFVBQVVNLE1BQVYsQ0FBaUJOLFFBQVFPLFNBQVIsR0FBb0IsRUFBcEIsR0FBeUJQLEdBQTFDLEVBQStDLElBQS9DLEVBQXFELENBQUMsRUFBRUcsRUFBRixHQUFPQyxFQUFSLEVBQVluQixRQUFaLENBQXFCLEVBQXJCLENBQXJELENBQVA7Q0FERjs7O0FDRkEsSUFBSTFCLFNBQVNZLE9BQWI7QUFDQSxJQUFJcUMsT0FBT3JDLEtBQVg7QUFDQSxJQUFJc0MsTUFBTXRDLElBQVY7QUFDQSxJQUFJdUMsTUFBTXZDLEtBQWtCLEtBQWxCLENBQVY7QUFDQSxJQUFJd0MsWUFBWSxVQUFoQjtBQUNBLElBQUlDLFlBQVloRCxTQUFTK0MsU0FBVCxDQUFoQjtBQUNBLElBQUlFLE1BQU0sQ0FBQyxLQUFLRCxTQUFOLEVBQWlCRSxLQUFqQixDQUF1QkgsU0FBdkIsQ0FBVjs7QUFFQXhDLE1BQW1CNEMsYUFBbkIsR0FBbUMsVUFBVTlDLEVBQVYsRUFBYztTQUN4QzJDLFVBQVUxQixJQUFWLENBQWVqQixFQUFmLENBQVA7Q0FERjs7QUFJQSxDQUFDVCxjQUFBLEdBQWlCLFVBQVVpQyxDQUFWLEVBQWFPLEdBQWIsRUFBa0JoQixHQUFsQixFQUF1QmdDLElBQXZCLEVBQTZCO01BQ3pDQyxhQUFhLE9BQU9qQyxHQUFQLElBQWMsVUFBL0I7TUFDSWlDLFVBQUosRUFBZ0JSLElBQUl6QixHQUFKLEVBQVMsTUFBVCxLQUFvQndCLEtBQUt4QixHQUFMLEVBQVUsTUFBVixFQUFrQmdCLEdBQWxCLENBQXBCO01BQ1pQLEVBQUVPLEdBQUYsTUFBV2hCLEdBQWYsRUFBb0I7TUFDaEJpQyxVQUFKLEVBQWdCUixJQUFJekIsR0FBSixFQUFTMEIsR0FBVCxLQUFpQkYsS0FBS3hCLEdBQUwsRUFBVTBCLEdBQVYsRUFBZWpCLEVBQUVPLEdBQUYsSUFBUyxLQUFLUCxFQUFFTyxHQUFGLENBQWQsR0FBdUJhLElBQUlLLElBQUosQ0FBU0MsT0FBT25CLEdBQVAsQ0FBVCxDQUF0QyxDQUFqQjtNQUNaUCxNQUFNbEMsTUFBVixFQUFrQjtNQUNkeUMsR0FBRixJQUFTaEIsR0FBVDtHQURGLE1BRU8sSUFBSSxDQUFDZ0MsSUFBTCxFQUFXO1dBQ1R2QixFQUFFTyxHQUFGLENBQVA7U0FDS1AsQ0FBTCxFQUFRTyxHQUFSLEVBQWFoQixHQUFiO0dBRkssTUFHQSxJQUFJUyxFQUFFTyxHQUFGLENBQUosRUFBWTtNQUNmQSxHQUFGLElBQVNoQixHQUFUO0dBREssTUFFQTtTQUNBUyxDQUFMLEVBQVFPLEdBQVIsRUFBYWhCLEdBQWI7OztDQWJKLEVBZ0JHcEIsU0FBU3dELFNBaEJaLEVBZ0J1QlQsU0FoQnZCLEVBZ0JrQyxTQUFTMUIsUUFBVCxHQUFvQjtTQUM3QyxPQUFPLElBQVAsSUFBZSxVQUFmLElBQTZCLEtBQUt5QixHQUFMLENBQTdCLElBQTBDRSxVQUFVMUIsSUFBVixDQUFlLElBQWYsQ0FBakQ7Q0FqQkY7OztBQ1pBMUIsY0FBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7TUFDekIsT0FBT0EsRUFBUCxJQUFhLFVBQWpCLEVBQTZCLE1BQU1HLFVBQVVILEtBQUsscUJBQWYsQ0FBTjtTQUN0QkEsRUFBUDtDQUZGOztBQ0FBO0FBQ0EsSUFBSW9ELFlBQVlsRCxVQUFoQjtBQUNBWCxRQUFBLEdBQWlCLFVBQVV1QixFQUFWLEVBQWN1QyxJQUFkLEVBQW9CQyxNQUFwQixFQUE0QjtZQUNqQ3hDLEVBQVY7TUFDSXVDLFNBQVNmLFNBQWIsRUFBd0IsT0FBT3hCLEVBQVA7VUFDaEJ3QyxNQUFSO1NBQ08sQ0FBTDthQUFlLFVBQVU3QyxDQUFWLEVBQWE7ZUFDbkJLLEdBQUdHLElBQUgsQ0FBUW9DLElBQVIsRUFBYzVDLENBQWQsQ0FBUDtPQURNO1NBR0gsQ0FBTDthQUFlLFVBQVVBLENBQVYsRUFBYThDLENBQWIsRUFBZ0I7ZUFDdEJ6QyxHQUFHRyxJQUFILENBQVFvQyxJQUFSLEVBQWM1QyxDQUFkLEVBQWlCOEMsQ0FBakIsQ0FBUDtPQURNO1NBR0gsQ0FBTDthQUFlLFVBQVU5QyxDQUFWLEVBQWE4QyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQjtlQUN6QjFDLEdBQUdHLElBQUgsQ0FBUW9DLElBQVIsRUFBYzVDLENBQWQsRUFBaUI4QyxDQUFqQixFQUFvQkMsQ0FBcEIsQ0FBUDtPQURNOztTQUlILHlCQUF5QjtXQUN2QjFDLEdBQUcyQyxLQUFILENBQVNKLElBQVQsRUFBZUssU0FBZixDQUFQO0dBREY7Q0FkRjs7QUNGQSxJQUFJcEUsV0FBU1ksT0FBYjtBQUNBLElBQUlMLE9BQU9LLEtBQVg7QUFDQSxJQUFJcUMsT0FBT3JDLEtBQVg7QUFDQSxJQUFJeUQsV0FBV3pELFNBQWY7QUFDQSxJQUFJMEQsTUFBTTFELElBQVY7QUFDQSxJQUFJMkQsWUFBWSxXQUFoQjs7QUFFQSxJQUFJQyxZQUFVLFNBQVZBLFNBQVUsQ0FBVUMsSUFBVixFQUFnQkMsSUFBaEIsRUFBc0JDLE1BQXRCLEVBQThCO01BQ3RDQyxZQUFZSCxPQUFPRCxVQUFRSyxDQUEvQjtNQUNJQyxZQUFZTCxPQUFPRCxVQUFRTyxDQUEvQjtNQUNJQyxZQUFZUCxPQUFPRCxVQUFRakQsQ0FBL0I7TUFDSTBELFdBQVdSLE9BQU9ELFVBQVFyQyxDQUE5QjtNQUNJK0MsVUFBVVQsT0FBT0QsVUFBUVcsQ0FBN0I7TUFDSUMsU0FBU04sWUFBWTlFLFFBQVosR0FBcUJnRixZQUFZaEYsU0FBTzBFLElBQVAsTUFBaUIxRSxTQUFPMEUsSUFBUCxJQUFlLEVBQWhDLENBQVosR0FBa0QsQ0FBQzFFLFNBQU8wRSxJQUFQLEtBQWdCLEVBQWpCLEVBQXFCSCxTQUFyQixDQUFwRjtNQUNJdEMsVUFBVTZDLFlBQVl2RSxJQUFaLEdBQW1CQSxLQUFLbUUsSUFBTCxNQUFlbkUsS0FBS21FLElBQUwsSUFBYSxFQUE1QixDQUFqQztNQUNJVyxXQUFXcEQsUUFBUXNDLFNBQVIsTUFBdUJ0QyxRQUFRc0MsU0FBUixJQUFxQixFQUE1QyxDQUFmO01BQ0k5QixHQUFKLEVBQVM2QyxHQUFULEVBQWNDLEdBQWQsRUFBbUJDLEdBQW5CO01BQ0lWLFNBQUosRUFBZUgsU0FBU0QsSUFBVDtPQUNWakMsR0FBTCxJQUFZa0MsTUFBWixFQUFvQjs7VUFFWixDQUFDQyxTQUFELElBQWNRLE1BQWQsSUFBd0JBLE9BQU8zQyxHQUFQLE1BQWdCTyxTQUE5Qzs7VUFFTSxDQUFDc0MsTUFBTUYsTUFBTixHQUFlVCxNQUFoQixFQUF3QmxDLEdBQXhCLENBQU47O1VBRU15QyxXQUFXSSxHQUFYLEdBQWlCaEIsSUFBSWlCLEdBQUosRUFBU3ZGLFFBQVQsQ0FBakIsR0FBb0NpRixZQUFZLE9BQU9NLEdBQVAsSUFBYyxVQUExQixHQUF1Q2pCLElBQUlqRSxTQUFTc0IsSUFBYixFQUFtQjRELEdBQW5CLENBQXZDLEdBQWlFQSxHQUEzRzs7UUFFSUgsTUFBSixFQUFZZixTQUFTZSxNQUFULEVBQWlCM0MsR0FBakIsRUFBc0I4QyxHQUF0QixFQUEyQmQsT0FBT0QsVUFBUWlCLENBQTFDOztRQUVSeEQsUUFBUVEsR0FBUixLQUFnQjhDLEdBQXBCLEVBQXlCdEMsS0FBS2hCLE9BQUwsRUFBY1EsR0FBZCxFQUFtQitDLEdBQW5CO1FBQ3JCUCxZQUFZSSxTQUFTNUMsR0FBVCxLQUFpQjhDLEdBQWpDLEVBQXNDRixTQUFTNUMsR0FBVCxJQUFnQjhDLEdBQWhCOztDQXRCMUM7QUF5QkF2RixTQUFPTyxJQUFQLEdBQWNBLElBQWQ7O0FBRUFpRSxVQUFRSyxDQUFSLEdBQVksQ0FBWjtBQUNBTCxVQUFRTyxDQUFSLEdBQVksQ0FBWjtBQUNBUCxVQUFRakQsQ0FBUixHQUFZLENBQVo7QUFDQWlELFVBQVFyQyxDQUFSLEdBQVksQ0FBWjtBQUNBcUMsVUFBUVcsQ0FBUixHQUFZLEVBQVo7QUFDQVgsVUFBUWtCLENBQVIsR0FBWSxFQUFaO0FBQ0FsQixVQUFRaUIsQ0FBUixHQUFZLEVBQVo7QUFDQWpCLFVBQVFtQixDQUFSLEdBQVksR0FBWjtBQUNBMUYsV0FBQSxHQUFpQnVFLFNBQWpCOztBQzFDQTtBQUNBdkUsWUFBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7TUFDekJBLE1BQU1zQyxTQUFWLEVBQXFCLE1BQU1uQyxVQUFVLDJCQUEyQkgsRUFBckMsQ0FBTjtTQUNkQSxFQUFQO0NBRkY7O0FDREFULGFBQUEsR0FBaUIsMERBQ2YsZ0ZBREY7O0FDQUEsSUFBSXVFLFVBQVU1RCxPQUFkO0FBQ0EsSUFBSWdGLFVBQVVoRixRQUFkO0FBQ0EsSUFBSWlGLFFBQVFqRixNQUFaO0FBQ0EsSUFBSWtGLFNBQVNsRixTQUFiO0FBQ0EsSUFBSW1GLFFBQVEsTUFBTUQsTUFBTixHQUFlLEdBQTNCO0FBQ0EsSUFBSUUsTUFBTSxZQUFWO0FBQ0EsSUFBSUMsUUFBUUMsT0FBTyxNQUFNSCxLQUFOLEdBQWNBLEtBQWQsR0FBc0IsR0FBN0IsQ0FBWjtBQUNBLElBQUlJLFFBQVFELE9BQU9ILFFBQVFBLEtBQVIsR0FBZ0IsSUFBdkIsQ0FBWjs7QUFFQSxJQUFJSyxXQUFXLFNBQVhBLFFBQVcsQ0FBVUMsR0FBVixFQUFldkYsSUFBZixFQUFxQndGLEtBQXJCLEVBQTRCO01BQ3JDZCxNQUFNLEVBQVY7TUFDSWUsUUFBUVYsTUFBTSxZQUFZO1dBQ3JCLENBQUMsQ0FBQ0MsT0FBT08sR0FBUCxHQUFGLElBQW1CTCxJQUFJSyxHQUFKLE9BQWNMLEdBQXhDO0dBRFUsQ0FBWjtNQUdJeEUsS0FBS2dFLElBQUlhLEdBQUosSUFBV0UsUUFBUXpGLEtBQUswRixNQUFMLENBQVIsR0FBcUJWLE9BQU9PLEdBQVAsQ0FBekM7TUFDSUMsS0FBSixFQUFXZCxJQUFJYyxLQUFKLElBQWE5RSxFQUFiO1VBQ0hnRCxRQUFRckMsQ0FBUixHQUFZcUMsUUFBUUssQ0FBUixHQUFZMEIsS0FBaEMsRUFBdUMsUUFBdkMsRUFBaURmLEdBQWpEO0NBUEY7Ozs7O0FBYUEsSUFBSWdCLFNBQU9KLFNBQVNJLElBQVQsR0FBZ0IsVUFBVUMsTUFBVixFQUFrQkMsSUFBbEIsRUFBd0I7V0FDeEM5QyxPQUFPZ0MsUUFBUWEsTUFBUixDQUFQLENBQVQ7TUFDSUMsT0FBTyxDQUFYLEVBQWNELFNBQVNBLE9BQU9FLE9BQVAsQ0FBZVYsS0FBZixFQUFzQixFQUF0QixDQUFUO01BQ1ZTLE9BQU8sQ0FBWCxFQUFjRCxTQUFTQSxPQUFPRSxPQUFQLENBQWVSLEtBQWYsRUFBc0IsRUFBdEIsQ0FBVDtTQUNQTSxNQUFQO0NBSkY7O0FBT0F4RyxlQUFBLEdBQWlCbUcsUUFBakI7Ozs7QUMzQkF4RixZQUEwQixNQUExQixFQUFrQyxVQUFVZ0csS0FBVixFQUFpQjtTQUMxQyxTQUFTSixJQUFULEdBQWdCO1dBQ2RJLE1BQU0sSUFBTixFQUFZLENBQVosQ0FBUDtHQURGO0NBREY7O0FDRkE7QUFDQSxJQUFJQyxPQUFPMUcsS0FBSzBHLElBQWhCO0FBQ0EsSUFBSUMsUUFBUTNHLEtBQUsyRyxLQUFqQjtBQUNBN0csY0FBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7U0FDdEJxRyxNQUFNckcsS0FBSyxDQUFDQSxFQUFaLElBQWtCLENBQWxCLEdBQXNCLENBQUNBLEtBQUssQ0FBTCxHQUFTb0csS0FBVCxHQUFpQkQsSUFBbEIsRUFBd0JuRyxFQUF4QixDQUE3QjtDQURGOztBQ0hBO0FBQ0EsSUFBSXNHLFlBQVlwRyxVQUFoQjtBQUNBLElBQUlxRyxNQUFNOUcsS0FBSzhHLEdBQWY7QUFDQWhILGFBQUEsR0FBaUIsVUFBVVMsRUFBVixFQUFjO1NBQ3RCQSxLQUFLLENBQUwsR0FBU3VHLElBQUlELFVBQVV0RyxFQUFWLENBQUosRUFBbUIsZ0JBQW5CLENBQVQsR0FBZ0QsQ0FBdkQsQ0FENkI7Q0FBL0I7O0FDSEEsSUFBSWdCLGFBQVcsR0FBR0EsUUFBbEI7O0FBRUF6QixRQUFBLEdBQWlCLFVBQVVTLEVBQVYsRUFBYztTQUN0QmdCLFdBQVNDLElBQVQsQ0FBY2pCLEVBQWQsRUFBa0J3RyxLQUFsQixDQUF3QixDQUF4QixFQUEyQixDQUFDLENBQTVCLENBQVA7Q0FERjs7QUNGQSxJQUFJbEgsV0FBU1ksT0FBYjtBQUNBLElBQUl1RyxTQUFTLG9CQUFiO0FBQ0EsSUFBSUMsUUFBUXBILFNBQU9tSCxNQUFQLE1BQW1CbkgsU0FBT21ILE1BQVAsSUFBaUIsRUFBcEMsQ0FBWjtBQUNBbEgsV0FBQSxHQUFpQixVQUFVd0MsR0FBVixFQUFlO1NBQ3ZCMkUsTUFBTTNFLEdBQU4sTUFBZTJFLE1BQU0zRSxHQUFOLElBQWEsRUFBNUIsQ0FBUDtDQURGOzs7QUNIQSxJQUFJMkUsUUFBUXhHLFFBQXFCLEtBQXJCLENBQVo7QUFDQSxJQUFJeUcsTUFBTXpHLElBQVY7QUFDQSxJQUFJMEcsVUFBUzFHLFFBQXFCMEcsTUFBbEM7QUFDQSxJQUFJQyxhQUFhLE9BQU9ELE9BQVAsSUFBaUIsVUFBbEM7O0FBRUEsSUFBSUUsV0FBV3ZILGNBQUEsR0FBaUIsVUFBVXlFLElBQVYsRUFBZ0I7U0FDdkMwQyxNQUFNMUMsSUFBTixNQUFnQjBDLE1BQU0xQyxJQUFOLElBQ3JCNkMsY0FBY0QsUUFBTzVDLElBQVAsQ0FBZCxJQUE4QixDQUFDNkMsYUFBYUQsT0FBYixHQUFzQkQsR0FBdkIsRUFBNEIsWUFBWTNDLElBQXhDLENBRHpCLENBQVA7Q0FERjs7QUFLQThDLFNBQVNKLEtBQVQsR0FBaUJBLEtBQWpCOzs7QUNWQTtBQUNBLElBQUl6RyxhQUFXQyxTQUFmO0FBQ0EsSUFBSTZHLE1BQU03RyxJQUFWO0FBQ0EsSUFBSThHLFFBQVE5RyxLQUFrQixPQUFsQixDQUFaO0FBQ0FYLGFBQUEsR0FBaUIsVUFBVVMsRUFBVixFQUFjO01BQ3pCaUgsUUFBSjtTQUNPaEgsV0FBU0QsRUFBVCxNQUFpQixDQUFDaUgsV0FBV2pILEdBQUdnSCxLQUFILENBQVosTUFBMkIxRSxTQUEzQixHQUF1QyxDQUFDLENBQUMyRSxRQUF6QyxHQUFvREYsSUFBSS9HLEVBQUosS0FBVyxRQUFoRixDQUFQO0NBRkY7O0FDSkE7QUFDQSxJQUFJaUgsV0FBVy9HLFNBQWY7QUFDQSxJQUFJZ0YsWUFBVWhGLFFBQWQ7O0FBRUFYLGtCQUFBLEdBQWlCLFVBQVU4RCxJQUFWLEVBQWdCNkQsWUFBaEIsRUFBOEJDLElBQTlCLEVBQW9DO01BQy9DRixTQUFTQyxZQUFULENBQUosRUFBNEIsTUFBTS9HLFVBQVUsWUFBWWdILElBQVosR0FBbUIsd0JBQTdCLENBQU47U0FDckJqRSxPQUFPZ0MsVUFBUTdCLElBQVIsQ0FBUCxDQUFQO0NBRkY7O0FDSkEsSUFBSTJELFVBQVE5RyxLQUFrQixPQUFsQixDQUFaO0FBQ0FYLGtCQUFBLEdBQWlCLFVBQVVvRyxHQUFWLEVBQWU7TUFDMUJ5QixLQUFLLEdBQVQ7TUFDSTtVQUNJekIsR0FBTixFQUFXeUIsRUFBWDtHQURGLENBRUUsT0FBTy9HLENBQVAsRUFBVTtRQUNOO1NBQ0MyRyxPQUFILElBQVksS0FBWjthQUNPLENBQUMsTUFBTXJCLEdBQU4sRUFBV3lCLEVBQVgsQ0FBUjtLQUZGLENBR0UsT0FBT3BGLENBQVAsRUFBVTtHQUNaLE9BQU8sSUFBUDtDQVRKOztBQ0NBLElBQUk4QixZQUFVNUQsT0FBZDtBQUNBLElBQUltSCxXQUFXbkgsU0FBZjtBQUNBLElBQUlvSCxVQUFVcEgsY0FBZDtBQUNBLElBQUlxSCxjQUFjLFlBQWxCO0FBQ0EsSUFBSUMsY0FBYyxHQUFHRCxXQUFILENBQWxCOztBQUVBekQsVUFBUUEsVUFBUXJDLENBQVIsR0FBWXFDLFVBQVFLLENBQVIsR0FBWWpFLGVBQThCcUgsV0FBOUIsQ0FBaEMsRUFBNEUsUUFBNUUsRUFBc0Y7Y0FDeEUsU0FBU0UsVUFBVCxDQUFvQlAsWUFBcEIsdUJBQXVEO1FBQzdEN0QsT0FBT2lFLFFBQVEsSUFBUixFQUFjSixZQUFkLEVBQTRCSyxXQUE1QixDQUFYO1FBQ0lHLFFBQVFMLFNBQVM1SCxLQUFLOEcsR0FBTCxDQUFTN0MsVUFBVUosTUFBVixHQUFtQixDQUFuQixHQUF1QkksVUFBVSxDQUFWLENBQXZCLEdBQXNDcEIsU0FBL0MsRUFBMERlLEtBQUtDLE1BQS9ELENBQVQsQ0FBWjtRQUNJcUUsU0FBU3pFLE9BQU9nRSxZQUFQLENBQWI7V0FDT00sY0FDSEEsWUFBWXZHLElBQVosQ0FBaUJvQyxJQUFqQixFQUF1QnNFLE1BQXZCLEVBQStCRCxLQUEvQixDQURHLEdBRUhyRSxLQUFLbUQsS0FBTCxDQUFXa0IsS0FBWCxFQUFrQkEsUUFBUUMsT0FBT3JFLE1BQWpDLE1BQTZDcUUsTUFGakQ7O0NBTEo7O0FDTkEsSUFBSTdELFlBQVU1RCxPQUFkO0FBQ0EsSUFBSW1ILGFBQVduSCxTQUFmO0FBQ0EsSUFBSW9ILFlBQVVwSCxjQUFkO0FBQ0EsSUFBSTBILFlBQVksVUFBaEI7QUFDQSxJQUFJQyxZQUFZLEdBQUdELFNBQUgsQ0FBaEI7O0FBRUE5RCxVQUFRQSxVQUFRckMsQ0FBUixHQUFZcUMsVUFBUUssQ0FBUixHQUFZakUsZUFBOEIwSCxTQUE5QixDQUFoQyxFQUEwRSxRQUExRSxFQUFvRjtZQUN4RSxTQUFTRSxRQUFULENBQWtCWixZQUFsQixnQ0FBOEQ7UUFDbEU3RCxPQUFPaUUsVUFBUSxJQUFSLEVBQWNKLFlBQWQsRUFBNEJVLFNBQTVCLENBQVg7UUFDSUcsY0FBY3JFLFVBQVVKLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJJLFVBQVUsQ0FBVixDQUF2QixHQUFzQ3BCLFNBQXhEO1FBQ0kwRixNQUFNWCxXQUFTaEUsS0FBS0MsTUFBZCxDQUFWO1FBQ0kyRSxNQUFNRixnQkFBZ0J6RixTQUFoQixHQUE0QjBGLEdBQTVCLEdBQWtDdkksS0FBSzhHLEdBQUwsQ0FBU2MsV0FBU1UsV0FBVCxDQUFULEVBQWdDQyxHQUFoQyxDQUE1QztRQUNJTCxTQUFTekUsT0FBT2dFLFlBQVAsQ0FBYjtXQUNPVyxZQUNIQSxVQUFVNUcsSUFBVixDQUFlb0MsSUFBZixFQUFxQnNFLE1BQXJCLEVBQTZCTSxHQUE3QixDQURHLEdBRUg1RSxLQUFLbUQsS0FBTCxDQUFXeUIsTUFBTU4sT0FBT3JFLE1BQXhCLEVBQWdDMkUsR0FBaEMsTUFBeUNOLE1BRjdDOztDQVBKOzs7QUNSQSxJQUFJTyxPQUFPaEksS0FBa0IsTUFBbEIsQ0FBWDtBQUNBLElBQUlELFdBQVdDLFNBQWY7QUFDQSxJQUFJc0MsTUFBTXRDLElBQVY7QUFDQSxJQUFJaUksVUFBVWpJLFVBQXdCOEIsQ0FBdEM7QUFDQSxJQUFJRSxLQUFLLENBQVQ7QUFDQSxJQUFJa0csZUFBZTlILE9BQU84SCxZQUFQLElBQXVCLFlBQVk7U0FDN0MsSUFBUDtDQURGO0FBR0EsSUFBSUMsU0FBUyxDQUFDbkksT0FBb0IsWUFBWTtTQUNyQ2tJLGFBQWE5SCxPQUFPZ0ksaUJBQVAsQ0FBeUIsRUFBekIsQ0FBYixDQUFQO0NBRFksQ0FBZDtBQUdBLElBQUlDLFVBQVUsU0FBVkEsT0FBVSxDQUFVdkksRUFBVixFQUFjO1VBQ2xCQSxFQUFSLEVBQVlrSSxJQUFaLEVBQWtCLEVBQUV2RyxPQUFPO1NBQ3RCLE1BQU0sRUFBRU8sRUFEYztTQUV0QixFQUZzQjtLQUFULEVBQWxCO0NBREY7QUFNQSxJQUFJc0csVUFBVSxTQUFWQSxPQUFVLENBQVV4SSxFQUFWLEVBQWN5SSxNQUFkLEVBQXNCOztNQUU5QixDQUFDeEksU0FBU0QsRUFBVCxDQUFMLEVBQW1CLE9BQU8sUUFBT0EsRUFBUCxxREFBT0EsRUFBUCxNQUFhLFFBQWIsR0FBd0JBLEVBQXhCLEdBQTZCLENBQUMsT0FBT0EsRUFBUCxJQUFhLFFBQWIsR0FBd0IsR0FBeEIsR0FBOEIsR0FBL0IsSUFBc0NBLEVBQTFFO01BQ2YsQ0FBQ3dDLElBQUl4QyxFQUFKLEVBQVFrSSxJQUFSLENBQUwsRUFBb0I7O1FBRWQsQ0FBQ0UsYUFBYXBJLEVBQWIsQ0FBTCxFQUF1QixPQUFPLEdBQVA7O1FBRW5CLENBQUN5SSxNQUFMLEVBQWEsT0FBTyxHQUFQOztZQUVMekksRUFBUjs7R0FFQSxPQUFPQSxHQUFHa0ksSUFBSCxFQUFTUSxDQUFoQjtDQVhKO0FBYUEsSUFBSUMsVUFBVSxTQUFWQSxPQUFVLENBQVUzSSxFQUFWLEVBQWN5SSxNQUFkLEVBQXNCO01BQzlCLENBQUNqRyxJQUFJeEMsRUFBSixFQUFRa0ksSUFBUixDQUFMLEVBQW9COztRQUVkLENBQUNFLGFBQWFwSSxFQUFiLENBQUwsRUFBdUIsT0FBTyxJQUFQOztRQUVuQixDQUFDeUksTUFBTCxFQUFhLE9BQU8sS0FBUDs7WUFFTHpJLEVBQVI7O0dBRUEsT0FBT0EsR0FBR2tJLElBQUgsRUFBU1UsQ0FBaEI7Q0FUSjs7QUFZQSxJQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVTdJLEVBQVYsRUFBYztNQUN2QnFJLFVBQVVTLEtBQUtDLElBQWYsSUFBdUJYLGFBQWFwSSxFQUFiLENBQXZCLElBQTJDLENBQUN3QyxJQUFJeEMsRUFBSixFQUFRa0ksSUFBUixDQUFoRCxFQUErREssUUFBUXZJLEVBQVI7U0FDeERBLEVBQVA7Q0FGRjtBQUlBLElBQUk4SSxPQUFPdkosY0FBQSxHQUFpQjtPQUNyQjJJLElBRHFCO1FBRXBCLEtBRm9CO1dBR2pCTSxPQUhpQjtXQUlqQkcsT0FKaUI7WUFLaEJFO0NBTFo7OztBQzlDQSxJQUFJRyxNQUFNOUksVUFBd0I4QixDQUFsQztBQUNBLElBQUlRLFFBQU10QyxJQUFWO0FBQ0EsSUFBSStJLE1BQU0vSSxLQUFrQixhQUFsQixDQUFWOztBQUVBWCxtQkFBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWNrSixHQUFkLEVBQW1CQyxJQUFuQixFQUF5QjtNQUNwQ25KLE1BQU0sQ0FBQ3dDLE1BQUl4QyxLQUFLbUosT0FBT25KLEVBQVAsR0FBWUEsR0FBR21ELFNBQXhCLEVBQW1DOEYsR0FBbkMsQ0FBWCxFQUFvREQsSUFBSWhKLEVBQUosRUFBUWlKLEdBQVIsRUFBYSxFQUFFRyxjQUFjLElBQWhCLEVBQXNCekgsT0FBT3VILEdBQTdCLEVBQWI7Q0FEdEQ7O0FDSkEzSCxVQUFZckIsSUFBWjs7Ozs7O0FDQUFYLFlBQUEsR0FBaUIsS0FBakI7O0FDQUEsSUFBSUQsV0FBU1ksT0FBYjtBQUNBLElBQUlMLFNBQU9LLEtBQVg7QUFDQSxJQUFJbUosVUFBVW5KLFFBQWQ7QUFDQSxJQUFJb0osV0FBU3BKLE9BQWI7QUFDQSxJQUFJSyxtQkFBaUJMLFVBQXdCOEIsQ0FBN0M7QUFDQXpDLGNBQUEsR0FBaUIsVUFBVXlFLElBQVYsRUFBZ0I7TUFDM0J1RixVQUFVMUosT0FBSytHLE1BQUwsS0FBZ0IvRyxPQUFLK0csTUFBTCxHQUFjeUMsVUFBVSxFQUFWLEdBQWUvSixTQUFPc0gsTUFBUCxJQUFpQixFQUE5RCxDQUFkO01BQ0k1QyxLQUFLd0YsTUFBTCxDQUFZLENBQVosS0FBa0IsR0FBbEIsSUFBeUIsRUFBRXhGLFFBQVF1RixPQUFWLENBQTdCLEVBQWlEaEosaUJBQWVnSixPQUFmLEVBQXdCdkYsSUFBeEIsRUFBOEIsRUFBRXJDLE9BQU8ySCxTQUFPdEgsQ0FBUCxDQUFTZ0MsSUFBVCxDQUFULEVBQTlCO0NBRm5EOztBQ0xBO0FBQ0EsSUFBSStDLFFBQU03RyxJQUFWOztBQUVBWCxZQUFBLEdBQWlCZSxPQUFPLEdBQVAsRUFBWW1KLG9CQUFaLENBQWlDLENBQWpDLElBQXNDbkosTUFBdEMsR0FBK0MsVUFBVU4sRUFBVixFQUFjO1NBQ3JFK0csTUFBSS9HLEVBQUosS0FBVyxRQUFYLEdBQXNCQSxHQUFHNkMsS0FBSCxDQUFTLEVBQVQsQ0FBdEIsR0FBcUN2QyxPQUFPTixFQUFQLENBQTVDO0NBREY7O0FDSEE7QUFDQSxJQUFJMEosVUFBVXhKLFFBQWQ7QUFDQSxJQUFJZ0YsWUFBVWhGLFFBQWQ7QUFDQVgsY0FBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7U0FDdEIwSixRQUFReEUsVUFBUWxGLEVBQVIsQ0FBUixDQUFQO0NBREY7O0FDSEEsSUFBSXNHLGNBQVlwRyxVQUFoQjtBQUNBLElBQUl5SixNQUFNbEssS0FBS2tLLEdBQWY7QUFDQSxJQUFJcEQsUUFBTTlHLEtBQUs4RyxHQUFmO0FBQ0FoSCxvQkFBQSxHQUFpQixVQUFVbUksS0FBVixFQUFpQnBFLE1BQWpCLEVBQXlCO1VBQ2hDZ0QsWUFBVW9CLEtBQVYsQ0FBUjtTQUNPQSxRQUFRLENBQVIsR0FBWWlDLElBQUlqQyxRQUFRcEUsTUFBWixFQUFvQixDQUFwQixDQUFaLEdBQXFDaUQsTUFBSW1CLEtBQUosRUFBV3BFLE1BQVgsQ0FBNUM7Q0FGRjs7QUNIQTs7QUFFQSxJQUFJc0csY0FBWTFKLFVBQWhCO0FBQ0EsSUFBSW1ILGFBQVduSCxTQUFmO0FBQ0EsSUFBSTJKLGtCQUFrQjNKLGdCQUF0QjtBQUNBWCxrQkFBQSxHQUFpQixVQUFVdUssV0FBVixFQUF1QjtTQUMvQixVQUFVQyxLQUFWLEVBQWlCQyxFQUFqQixFQUFxQkMsU0FBckIsRUFBZ0M7UUFDakN6SSxJQUFJb0ksWUFBVUcsS0FBVixDQUFSO1FBQ0l6RyxTQUFTK0QsV0FBUzdGLEVBQUU4QixNQUFYLENBQWI7UUFDSW9FLFFBQVFtQyxnQkFBZ0JJLFNBQWhCLEVBQTJCM0csTUFBM0IsQ0FBWjtRQUNJM0IsS0FBSjs7O1FBR0ltSSxlQUFlRSxNQUFNQSxFQUF6QixFQUE2QixPQUFPMUcsU0FBU29FLEtBQWhCLEVBQXVCO2NBQzFDbEcsRUFBRWtHLE9BQUYsQ0FBUjs7VUFFSS9GLFNBQVNBLEtBQWIsRUFBb0IsT0FBTyxJQUFQOztLQUh0QixNQUtPLE9BQU0yQixTQUFTb0UsS0FBZixFQUFzQkEsT0FBdEI7VUFBbUNvQyxlQUFlcEMsU0FBU2xHLENBQTVCLEVBQStCO1lBQy9EQSxFQUFFa0csS0FBRixNQUFhc0MsRUFBakIsRUFBcUIsT0FBT0YsZUFBZXBDLEtBQWYsSUFBd0IsQ0FBL0I7O0tBQ3JCLE9BQU8sQ0FBQ29DLFdBQUQsSUFBZ0IsQ0FBQyxDQUF4QjtHQWRKO0NBREY7O0FDTEEsSUFBSUksV0FBU2hLLFFBQXFCLE1BQXJCLENBQWI7QUFDQSxJQUFJeUcsUUFBTXpHLElBQVY7QUFDQVgsY0FBQSxHQUFpQixVQUFVd0MsR0FBVixFQUFlO1NBQ3ZCbUksU0FBT25JLEdBQVAsTUFBZ0JtSSxTQUFPbkksR0FBUCxJQUFjNEUsTUFBSTVFLEdBQUosQ0FBOUIsQ0FBUDtDQURGOztBQ0ZBLElBQUlTLFFBQU10QyxJQUFWO0FBQ0EsSUFBSTBKLGNBQVkxSixVQUFoQjtBQUNBLElBQUlpSyxlQUFlakssZUFBNkIsS0FBN0IsQ0FBbkI7QUFDQSxJQUFJa0ssV0FBV2xLLFdBQXlCLFVBQXpCLENBQWY7O0FBRUFYLHVCQUFBLEdBQWlCLFVBQVV1QyxNQUFWLEVBQWtCdUksS0FBbEIsRUFBeUI7TUFDcEM3SSxJQUFJb0ksWUFBVTlILE1BQVYsQ0FBUjtNQUNJNEcsSUFBSSxDQUFSO01BQ0k0QixTQUFTLEVBQWI7TUFDSXZJLEdBQUo7T0FDS0EsR0FBTCxJQUFZUCxDQUFaO1FBQW1CTyxPQUFPcUksUUFBWCxFQUFxQjVILE1BQUloQixDQUFKLEVBQU9PLEdBQVAsS0FBZXVJLE9BQU9DLElBQVAsQ0FBWXhJLEdBQVosQ0FBZjtHQUxJO1NBT2pDc0ksTUFBTS9HLE1BQU4sR0FBZW9GLENBQXRCO1FBQTZCbEcsTUFBSWhCLENBQUosRUFBT08sTUFBTXNJLE1BQU0zQixHQUFOLENBQWIsQ0FBSixFQUE4QjtPQUNwRHlCLGFBQWFHLE1BQWIsRUFBcUJ2SSxHQUFyQixDQUFELElBQThCdUksT0FBT0MsSUFBUCxDQUFZeEksR0FBWixDQUE5Qjs7R0FFRixPQUFPdUksTUFBUDtDQVZGOztBQ0xBO0FBQ0EvSyxnQkFBQSxHQUNFLCtGQURlLENBRWZzRCxLQUZlLENBRVQsR0FGUyxDQUFqQjs7QUNEQTtBQUNBLElBQUkySCxVQUFRdEssbUJBQVo7QUFDQSxJQUFJdUssY0FBY3ZLLFlBQWxCOztBQUVBWCxlQUFBLEdBQWlCZSxPQUFPb0ssSUFBUCxJQUFlLFNBQVNBLElBQVQsQ0FBY2xKLENBQWQsRUFBaUI7U0FDeENnSixRQUFNaEosQ0FBTixFQUFTaUosV0FBVCxDQUFQO0NBREY7O0FDSkFsSixVQUFZakIsT0FBT3FLLHFCQUFuQjs7Ozs7O0FDQUFwSixVQUFZLEdBQUdrSSxvQkFBZjs7Ozs7O0FDQUE7QUFDQSxJQUFJbUIsVUFBVTFLLFdBQWQ7QUFDQSxJQUFJMkssT0FBTzNLLFdBQVg7QUFDQSxJQUFJNEssTUFBTTVLLFVBQVY7QUFDQVgsYUFBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7TUFDekJzSyxTQUFTTSxRQUFRNUssRUFBUixDQUFiO01BQ0krSyxhQUFhRixLQUFLN0ksQ0FBdEI7TUFDSStJLFVBQUosRUFBZ0I7UUFDVkMsVUFBVUQsV0FBVy9LLEVBQVgsQ0FBZDtRQUNJaUwsU0FBU0gsSUFBSTlJLENBQWpCO1FBQ0kwRyxJQUFJLENBQVI7UUFDSTNHLEdBQUo7V0FDT2lKLFFBQVExSCxNQUFSLEdBQWlCb0YsQ0FBeEI7VUFBK0J1QyxPQUFPaEssSUFBUCxDQUFZakIsRUFBWixFQUFnQitCLE1BQU1pSixRQUFRdEMsR0FBUixDQUF0QixDQUFKLEVBQXlDNEIsT0FBT0MsSUFBUCxDQUFZeEksR0FBWjs7R0FDcEUsT0FBT3VJLE1BQVA7Q0FUSjs7QUNKQTtBQUNBLElBQUl2RCxRQUFNN0csSUFBVjtBQUNBWCxZQUFBLEdBQWlCMkwsTUFBTUMsT0FBTixJQUFpQixTQUFTQSxPQUFULENBQWlCQyxHQUFqQixFQUFzQjtTQUMvQ3JFLE1BQUlxRSxHQUFKLEtBQVksT0FBbkI7Q0FERjs7QUNGQSxJQUFJOUosT0FBS3BCLFNBQVQ7QUFDQSxJQUFJaUIsYUFBV2pCLFNBQWY7QUFDQSxJQUFJMEssWUFBVTFLLFdBQWQ7O0FBRUFYLGNBQUEsR0FBaUJXLGVBQTRCSSxPQUFPK0ssZ0JBQW5DLEdBQXNELFNBQVNBLGdCQUFULENBQTBCN0osQ0FBMUIsRUFBNkI4SixVQUE3QixFQUF5QzthQUNyRzlKLENBQVQ7TUFDSWtKLE9BQU9FLFVBQVFVLFVBQVIsQ0FBWDtNQUNJaEksU0FBU29ILEtBQUtwSCxNQUFsQjtNQUNJb0YsSUFBSSxDQUFSO01BQ0lqSCxDQUFKO1NBQ082QixTQUFTb0YsQ0FBaEI7U0FBc0IxRyxDQUFILENBQUtSLENBQUwsRUFBUUMsSUFBSWlKLEtBQUtoQyxHQUFMLENBQVosRUFBdUI0QyxXQUFXN0osQ0FBWCxDQUF2QjtHQUNuQixPQUFPRCxDQUFQO0NBUEY7O0FDSkEsSUFBSWQsYUFBV1IsUUFBcUJRLFFBQXBDO0FBQ0FuQixTQUFBLEdBQWlCbUIsY0FBWUEsV0FBUzZLLGVBQXRDOztBQ0RBO0FBQ0EsSUFBSXBLLGFBQVdqQixTQUFmO0FBQ0EsSUFBSXNMLE1BQU10TCxVQUFWO0FBQ0EsSUFBSXVLLGdCQUFjdkssWUFBbEI7QUFDQSxJQUFJa0ssYUFBV2xLLFdBQXlCLFVBQXpCLENBQWY7QUFDQSxJQUFJdUwsUUFBUSxTQUFSQSxLQUFRLEdBQVksYUFBeEI7QUFDQSxJQUFJNUgsY0FBWSxXQUFoQjs7O0FBR0EsSUFBSTZILGNBQWEsc0JBQVk7O01BRXZCQyxTQUFTekwsV0FBeUIsUUFBekIsQ0FBYjtNQUNJd0ksSUFBSStCLGNBQVluSCxNQUFwQjtNQUNJc0ksS0FBSyxHQUFUO01BQ0lDLEtBQUssR0FBVDtNQUNJQyxjQUFKO1NBQ09DLEtBQVAsQ0FBYUMsT0FBYixHQUF1QixNQUF2QjtRQUNtQkMsV0FBbkIsQ0FBK0JOLE1BQS9CO1NBQ09PLEdBQVAsR0FBYSxhQUFiLENBVDJCOzs7bUJBWVZQLE9BQU9RLGFBQVAsQ0FBcUJ6TCxRQUF0QztpQkFDZTBMLElBQWY7aUJBQ2VDLEtBQWYsQ0FBcUJULEtBQUssUUFBTCxHQUFnQkMsRUFBaEIsR0FBcUIsbUJBQXJCLEdBQTJDRCxFQUEzQyxHQUFnRCxTQUFoRCxHQUE0REMsRUFBakY7aUJBQ2VTLEtBQWY7Z0JBQ2FSLGVBQWUzSCxDQUE1QjtTQUNPdUUsR0FBUDtXQUFtQmdELFlBQVc3SCxXQUFYLEVBQXNCNEcsY0FBWS9CLENBQVosQ0FBdEIsQ0FBUDtHQUNaLE9BQU9nRCxhQUFQO0NBbEJGOztBQXFCQW5NLGlCQUFBLEdBQWlCZSxPQUFPbUksTUFBUCxJQUFpQixTQUFTQSxNQUFULENBQWdCakgsQ0FBaEIsRUFBbUI4SixVQUFuQixFQUErQjtNQUMzRGhCLE1BQUo7TUFDSTlJLE1BQU0sSUFBVixFQUFnQjtVQUNScUMsV0FBTixJQUFtQjFDLFdBQVNLLENBQVQsQ0FBbkI7YUFDUyxJQUFJaUssS0FBSixFQUFUO1VBQ001SCxXQUFOLElBQW1CLElBQW5COztXQUVPdUcsVUFBUCxJQUFtQjVJLENBQW5CO0dBTEYsTUFNTzhJLFNBQVNvQixhQUFUO1NBQ0FKLGVBQWVoSixTQUFmLEdBQTJCZ0ksTUFBM0IsR0FBb0NrQixJQUFJbEIsTUFBSixFQUFZZ0IsVUFBWixDQUEzQztDQVRGOztBQzlCQTtBQUNBLElBQUlkLFVBQVF0SyxtQkFBWjtBQUNBLElBQUlxTSxhQUFhck0sYUFBNEJtQyxNQUE1QixDQUFtQyxRQUFuQyxFQUE2QyxXQUE3QyxDQUFqQjs7QUFFQWQsVUFBWWpCLE9BQU9rTSxtQkFBUCxJQUE4QixTQUFTQSxtQkFBVCxDQUE2QmhMLENBQTdCLEVBQWdDO1NBQ2pFZ0osUUFBTWhKLENBQU4sRUFBUytLLFVBQVQsQ0FBUDtDQURGOzs7Ozs7QUNKQTtBQUNBLElBQUkzQyxjQUFZMUosVUFBaEI7QUFDQSxJQUFJdU0sU0FBT3ZNLFlBQTBCOEIsQ0FBckM7QUFDQSxJQUFJaEIsYUFBVyxHQUFHQSxRQUFsQjs7QUFFQSxJQUFJMEwsY0FBYyxRQUFPbE4sTUFBUCxxREFBT0EsTUFBUCxNQUFpQixRQUFqQixJQUE2QkEsTUFBN0IsSUFBdUNjLE9BQU9rTSxtQkFBOUMsR0FDZGxNLE9BQU9rTSxtQkFBUCxDQUEyQmhOLE1BQTNCLENBRGMsR0FDdUIsRUFEekM7O0FBR0EsSUFBSW1OLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBVTNNLEVBQVYsRUFBYztNQUM3QjtXQUNLeU0sT0FBS3pNLEVBQUwsQ0FBUDtHQURGLENBRUUsT0FBT0ssQ0FBUCxFQUFVO1dBQ0hxTSxZQUFZbEcsS0FBWixFQUFQOztDQUpKOztBQVFBakgsVUFBbUIsU0FBU2lOLG1CQUFULENBQTZCeE0sRUFBN0IsRUFBaUM7U0FDM0MwTSxlQUFlMUwsV0FBU0MsSUFBVCxDQUFjakIsRUFBZCxLQUFxQixpQkFBcEMsR0FBd0QyTSxlQUFlM00sRUFBZixDQUF4RCxHQUE2RXlNLE9BQUs3QyxZQUFVNUosRUFBVixDQUFMLENBQXBGO0NBREY7Ozs7OztBQ2hCQSxJQUFJOEssUUFBTTVLLFVBQVY7QUFDQSxJQUFJMkIsZUFBYTNCLGFBQWpCO0FBQ0EsSUFBSTBKLGNBQVkxSixVQUFoQjtBQUNBLElBQUltQixnQkFBY25CLFlBQWxCO0FBQ0EsSUFBSXNDLFFBQU10QyxJQUFWO0FBQ0EsSUFBSWtCLG1CQUFpQmxCLGFBQXJCO0FBQ0EsSUFBSTBNLFNBQU90TSxPQUFPdU0sd0JBQWxCOztBQUVBdEwsVUFBWXJCLGVBQTRCME0sTUFBNUIsR0FBbUMsU0FBU0Msd0JBQVQsQ0FBa0NyTCxDQUFsQyxFQUFxQ0MsQ0FBckMsRUFBd0M7TUFDakZtSSxZQUFVcEksQ0FBVixDQUFKO01BQ0lILGNBQVlJLENBQVosRUFBZSxJQUFmLENBQUo7TUFDSUwsZ0JBQUosRUFBb0IsSUFBSTtXQUNmd0wsT0FBS3BMLENBQUwsRUFBUUMsQ0FBUixDQUFQO0dBRGtCLENBRWxCLE9BQU9wQixDQUFQLEVBQVU7TUFDUm1DLE1BQUloQixDQUFKLEVBQU9DLENBQVAsQ0FBSixFQUFlLE9BQU9JLGFBQVcsQ0FBQ2lKLE1BQUk5SSxDQUFKLENBQU1mLElBQU4sQ0FBV08sQ0FBWCxFQUFjQyxDQUFkLENBQVosRUFBOEJELEVBQUVDLENBQUYsQ0FBOUIsQ0FBUDtDQU5qQjs7Ozs7Ozs7QUNOQSxJQUFJbkMsV0FBU1ksT0FBYjtBQUNBLElBQUlzQyxNQUFNdEMsSUFBVjtBQUNBLElBQUk0TSxjQUFjNU0sWUFBbEI7QUFDQSxJQUFJNEQsWUFBVTVELE9BQWQ7QUFDQSxJQUFJeUQsYUFBV3pELFNBQWY7QUFDQSxJQUFJZ0ksT0FBT2hJLE1BQW1CeUYsR0FBOUI7QUFDQSxJQUFJb0gsU0FBUzdNLE1BQWI7QUFDQSxJQUFJZ0ssU0FBU2hLLE9BQWI7QUFDQSxJQUFJOE0saUJBQWlCOU0sZUFBckI7QUFDQSxJQUFJeUcsTUFBTXpHLElBQVY7QUFDQSxJQUFJK00sTUFBTS9NLElBQVY7QUFDQSxJQUFJb0osU0FBU3BKLE9BQWI7QUFDQSxJQUFJZ04sWUFBWWhOLFVBQWhCO0FBQ0EsSUFBSWlOLFdBQVdqTixTQUFmO0FBQ0EsSUFBSWlMLFlBQVVqTCxRQUFkO0FBQ0EsSUFBSWlCLGFBQVdqQixTQUFmO0FBQ0EsSUFBSTBKLFlBQVkxSixVQUFoQjtBQUNBLElBQUltQixnQkFBY25CLFlBQWxCO0FBQ0EsSUFBSTJCLGVBQWEzQixhQUFqQjtBQUNBLElBQUlrTixVQUFVbE4sYUFBZDtBQUNBLElBQUltTixVQUFVbk4sY0FBZDtBQUNBLElBQUlvTixRQUFRcE4sV0FBWjtBQUNBLElBQUlxTixNQUFNck4sU0FBVjtBQUNBLElBQUlzSyxRQUFRdEssV0FBWjtBQUNBLElBQUkwTSxPQUFPVSxNQUFNdEwsQ0FBakI7QUFDQSxJQUFJVixPQUFLaU0sSUFBSXZMLENBQWI7QUFDQSxJQUFJeUssT0FBT1ksUUFBUXJMLENBQW5CO0FBQ0EsSUFBSXVILFVBQVVqSyxTQUFPc0gsTUFBckI7QUFDQSxJQUFJNEcsUUFBUWxPLFNBQU9tTyxJQUFuQjtBQUNBLElBQUlDLGFBQWFGLFNBQVNBLE1BQU1HLFNBQWhDO0FBQ0EsSUFBSTlKLGNBQVksV0FBaEI7QUFDQSxJQUFJK0osU0FBU1gsSUFBSSxTQUFKLENBQWI7QUFDQSxJQUFJWSxlQUFlWixJQUFJLGFBQUosQ0FBbkI7QUFDQSxJQUFJaEMsU0FBUyxHQUFHeEIsb0JBQWhCO0FBQ0EsSUFBSXFFLGlCQUFpQjVELE9BQU8saUJBQVAsQ0FBckI7QUFDQSxJQUFJNkQsYUFBYTdELE9BQU8sU0FBUCxDQUFqQjtBQUNBLElBQUk4RCxZQUFZOUQsT0FBTyxZQUFQLENBQWhCO0FBQ0EsSUFBSStELGNBQWMzTixPQUFPdUQsV0FBUCxDQUFsQjtBQUNBLElBQUlxSyxhQUFhLE9BQU8zRSxPQUFQLElBQWtCLFVBQW5DO0FBQ0EsSUFBSTRFLFVBQVU3TyxTQUFPNk8sT0FBckI7O0FBRUEsSUFBSUMsU0FBUyxDQUFDRCxPQUFELElBQVksQ0FBQ0EsUUFBUXRLLFdBQVIsQ0FBYixJQUFtQyxDQUFDc0ssUUFBUXRLLFdBQVIsRUFBbUJ3SyxTQUFwRTs7O0FBR0EsSUFBSUMsZ0JBQWdCeEIsZUFBZUMsT0FBTyxZQUFZO1NBQzdDSyxRQUFROUwsS0FBRyxFQUFILEVBQU8sR0FBUCxFQUFZO1NBQ3BCLGVBQVk7YUFBU0EsS0FBRyxJQUFILEVBQVMsR0FBVCxFQUFjLEVBQUVLLE9BQU8sQ0FBVCxFQUFkLEVBQTRCbEIsQ0FBbkM7O0dBRE4sQ0FBUixFQUVIQSxDQUZHLElBRUUsQ0FGVDtDQURpQyxDQUFmLEdBSWYsVUFBVVQsRUFBVixFQUFjK0IsR0FBZCxFQUFtQndNLENBQW5CLEVBQXNCO01BQ3JCQyxZQUFZNUIsS0FBS3FCLFdBQUwsRUFBa0JsTSxHQUFsQixDQUFoQjtNQUNJeU0sU0FBSixFQUFlLE9BQU9QLFlBQVlsTSxHQUFaLENBQVA7T0FDWi9CLEVBQUgsRUFBTytCLEdBQVAsRUFBWXdNLENBQVo7TUFDSUMsYUFBYXhPLE9BQU9pTyxXQUF4QixFQUFxQzNNLEtBQUcyTSxXQUFILEVBQWdCbE0sR0FBaEIsRUFBcUJ5TSxTQUFyQjtDQVJuQixHQVNoQmxOLElBVEo7O0FBV0EsSUFBSW1OLE9BQU8sU0FBUEEsSUFBTyxDQUFVdkYsR0FBVixFQUFlO01BQ3BCd0YsTUFBTVgsV0FBVzdFLEdBQVgsSUFBa0JrRSxRQUFRN0QsUUFBUTFGLFdBQVIsQ0FBUixDQUE1QjtNQUNJOEssRUFBSixHQUFTekYsR0FBVDtTQUNPd0YsR0FBUDtDQUhGOztBQU1BLElBQUlFLFdBQVdWLGNBQWMsb0JBQU8zRSxRQUFRc0YsUUFBZixLQUEyQixRQUF6QyxHQUFvRCxVQUFVN08sRUFBVixFQUFjO1NBQ3hFLFFBQU9BLEVBQVAscURBQU9BLEVBQVAsTUFBYSxRQUFwQjtDQURhLEdBRVgsVUFBVUEsRUFBVixFQUFjO1NBQ1RBLGNBQWN1SixPQUFyQjtDQUhGOztBQU1BLElBQUl1RixrQkFBa0IsU0FBU3ZPLGNBQVQsQ0FBd0JQLEVBQXhCLEVBQTRCK0IsR0FBNUIsRUFBaUN3TSxDQUFqQyxFQUFvQztNQUNwRHZPLE9BQU9pTyxXQUFYLEVBQXdCYSxnQkFBZ0JkLFNBQWhCLEVBQTJCak0sR0FBM0IsRUFBZ0N3TSxDQUFoQzthQUNmdk8sRUFBVDtRQUNNcUIsY0FBWVUsR0FBWixFQUFpQixJQUFqQixDQUFOO2FBQ1N3TSxDQUFUO01BQ0kvTCxJQUFJdUwsVUFBSixFQUFnQmhNLEdBQWhCLENBQUosRUFBMEI7UUFDcEIsQ0FBQ3dNLEVBQUVRLFVBQVAsRUFBbUI7VUFDYixDQUFDdk0sSUFBSXhDLEVBQUosRUFBUTROLE1BQVIsQ0FBTCxFQUFzQnRNLEtBQUd0QixFQUFILEVBQU80TixNQUFQLEVBQWUvTCxhQUFXLENBQVgsRUFBYyxFQUFkLENBQWY7U0FDbkIrTCxNQUFILEVBQVc3TCxHQUFYLElBQWtCLElBQWxCO0tBRkYsTUFHTztVQUNEUyxJQUFJeEMsRUFBSixFQUFRNE4sTUFBUixLQUFtQjVOLEdBQUc0TixNQUFILEVBQVc3TCxHQUFYLENBQXZCLEVBQXdDL0IsR0FBRzROLE1BQUgsRUFBVzdMLEdBQVgsSUFBa0IsS0FBbEI7VUFDcENxTCxRQUFRbUIsQ0FBUixFQUFXLEVBQUVRLFlBQVlsTixhQUFXLENBQVgsRUFBYyxLQUFkLENBQWQsRUFBWCxDQUFKO0tBQ0EsT0FBT3lNLGNBQWN0TyxFQUFkLEVBQWtCK0IsR0FBbEIsRUFBdUJ3TSxDQUF2QixDQUFQO0dBQ0YsT0FBT2pOLEtBQUd0QixFQUFILEVBQU8rQixHQUFQLEVBQVl3TSxDQUFaLENBQVA7Q0FiSjtBQWVBLElBQUlTLG9CQUFvQixTQUFTM0QsZ0JBQVQsQ0FBMEJyTCxFQUExQixFQUE4QnlCLENBQTlCLEVBQWlDO2FBQzlDekIsRUFBVDtNQUNJMEssT0FBT3lDLFNBQVMxTCxJQUFJbUksVUFBVW5JLENBQVYsQ0FBYixDQUFYO01BQ0lpSCxJQUFJLENBQVI7TUFDSXVHLElBQUl2RSxLQUFLcEgsTUFBYjtNQUNJdkIsR0FBSjtTQUNPa04sSUFBSXZHLENBQVg7b0JBQThCMUksRUFBaEIsRUFBb0IrQixNQUFNMkksS0FBS2hDLEdBQUwsQ0FBMUIsRUFBcUNqSCxFQUFFTSxHQUFGLENBQXJDO0dBQ2QsT0FBTy9CLEVBQVA7Q0FQRjtBQVNBLElBQUlrUCxVQUFVLFNBQVN6RyxNQUFULENBQWdCekksRUFBaEIsRUFBb0J5QixDQUFwQixFQUF1QjtTQUM1QkEsTUFBTWEsU0FBTixHQUFrQjhLLFFBQVFwTixFQUFSLENBQWxCLEdBQWdDZ1Asa0JBQWtCNUIsUUFBUXBOLEVBQVIsQ0FBbEIsRUFBK0J5QixDQUEvQixDQUF2QztDQURGO0FBR0EsSUFBSTBOLHdCQUF3QixTQUFTMUYsb0JBQVQsQ0FBOEIxSCxHQUE5QixFQUFtQztNQUN6RHFOLElBQUluRSxPQUFPaEssSUFBUCxDQUFZLElBQVosRUFBa0JjLE1BQU1WLGNBQVlVLEdBQVosRUFBaUIsSUFBakIsQ0FBeEIsQ0FBUjtNQUNJLFNBQVNrTSxXQUFULElBQXdCekwsSUFBSXVMLFVBQUosRUFBZ0JoTSxHQUFoQixDQUF4QixJQUFnRCxDQUFDUyxJQUFJd0wsU0FBSixFQUFlak0sR0FBZixDQUFyRCxFQUEwRSxPQUFPLEtBQVA7U0FDbkVxTixLQUFLLENBQUM1TSxJQUFJLElBQUosRUFBVVQsR0FBVixDQUFOLElBQXdCLENBQUNTLElBQUl1TCxVQUFKLEVBQWdCaE0sR0FBaEIsQ0FBekIsSUFBaURTLElBQUksSUFBSixFQUFVb0wsTUFBVixLQUFxQixLQUFLQSxNQUFMLEVBQWE3TCxHQUFiLENBQXRFLEdBQTBGcU4sQ0FBMUYsR0FBOEYsSUFBckc7Q0FIRjtBQUtBLElBQUlDLDRCQUE0QixTQUFTeEMsd0JBQVQsQ0FBa0M3TSxFQUFsQyxFQUFzQytCLEdBQXRDLEVBQTJDO09BQ3BFNkgsVUFBVTVKLEVBQVYsQ0FBTDtRQUNNcUIsY0FBWVUsR0FBWixFQUFpQixJQUFqQixDQUFOO01BQ0kvQixPQUFPaU8sV0FBUCxJQUFzQnpMLElBQUl1TCxVQUFKLEVBQWdCaE0sR0FBaEIsQ0FBdEIsSUFBOEMsQ0FBQ1MsSUFBSXdMLFNBQUosRUFBZWpNLEdBQWYsQ0FBbkQsRUFBd0U7TUFDcEV3TSxJQUFJM0IsS0FBSzVNLEVBQUwsRUFBUytCLEdBQVQsQ0FBUjtNQUNJd00sS0FBSy9MLElBQUl1TCxVQUFKLEVBQWdCaE0sR0FBaEIsQ0FBTCxJQUE2QixFQUFFUyxJQUFJeEMsRUFBSixFQUFRNE4sTUFBUixLQUFtQjVOLEdBQUc0TixNQUFILEVBQVc3TCxHQUFYLENBQXJCLENBQWpDLEVBQXdFd00sRUFBRVEsVUFBRixHQUFlLElBQWY7U0FDakVSLENBQVA7Q0FORjtBQVFBLElBQUllLHVCQUF1QixTQUFTOUMsbUJBQVQsQ0FBNkJ4TSxFQUE3QixFQUFpQztNQUN0RHFLLFFBQVFvQyxLQUFLN0MsVUFBVTVKLEVBQVYsQ0FBTCxDQUFaO01BQ0lzSyxTQUFTLEVBQWI7TUFDSTVCLElBQUksQ0FBUjtNQUNJM0csR0FBSjtTQUNPc0ksTUFBTS9HLE1BQU4sR0FBZW9GLENBQXRCLEVBQXlCO1FBQ25CLENBQUNsRyxJQUFJdUwsVUFBSixFQUFnQmhNLE1BQU1zSSxNQUFNM0IsR0FBTixDQUF0QixDQUFELElBQXNDM0csT0FBTzZMLE1BQTdDLElBQXVEN0wsT0FBT21HLElBQWxFLEVBQXdFb0MsT0FBT0MsSUFBUCxDQUFZeEksR0FBWjtHQUN4RSxPQUFPdUksTUFBUDtDQVBKO0FBU0EsSUFBSWlGLHlCQUF5QixTQUFTNUUscUJBQVQsQ0FBK0IzSyxFQUEvQixFQUFtQztNQUMxRHdQLFFBQVF4UCxPQUFPaU8sV0FBbkI7TUFDSTVELFFBQVFvQyxLQUFLK0MsUUFBUXhCLFNBQVIsR0FBb0JwRSxVQUFVNUosRUFBVixDQUF6QixDQUFaO01BQ0lzSyxTQUFTLEVBQWI7TUFDSTVCLElBQUksQ0FBUjtNQUNJM0csR0FBSjtTQUNPc0ksTUFBTS9HLE1BQU4sR0FBZW9GLENBQXRCLEVBQXlCO1FBQ25CbEcsSUFBSXVMLFVBQUosRUFBZ0JoTSxNQUFNc0ksTUFBTTNCLEdBQU4sQ0FBdEIsTUFBc0M4RyxRQUFRaE4sSUFBSXlMLFdBQUosRUFBaUJsTSxHQUFqQixDQUFSLEdBQWdDLElBQXRFLENBQUosRUFBaUZ1SSxPQUFPQyxJQUFQLENBQVl3RCxXQUFXaE0sR0FBWCxDQUFaO0dBQ2pGLE9BQU91SSxNQUFQO0NBUko7OztBQVlBLElBQUksQ0FBQzRELFVBQUwsRUFBaUI7WUFDTCxTQUFTdEgsT0FBVCxHQUFrQjtRQUN0QixnQkFBZ0IyQyxPQUFwQixFQUE2QixNQUFNcEosVUFBVSw4QkFBVixDQUFOO1FBQ3pCK0ksTUFBTXZDLElBQUlqRCxVQUFVSixNQUFWLEdBQW1CLENBQW5CLEdBQXVCSSxVQUFVLENBQVYsQ0FBdkIsR0FBc0NwQixTQUExQyxDQUFWO1FBQ0ltTixPQUFPLFNBQVBBLElBQU8sQ0FBVTlOLEtBQVYsRUFBaUI7VUFDdEIsU0FBU3NNLFdBQWIsRUFBMEJ3QixLQUFLeE8sSUFBTCxDQUFVK00sU0FBVixFQUFxQnJNLEtBQXJCO1VBQ3RCYSxJQUFJLElBQUosRUFBVW9MLE1BQVYsS0FBcUJwTCxJQUFJLEtBQUtvTCxNQUFMLENBQUosRUFBa0IxRSxHQUFsQixDQUF6QixFQUFpRCxLQUFLMEUsTUFBTCxFQUFhMUUsR0FBYixJQUFvQixLQUFwQjtvQkFDbkMsSUFBZCxFQUFvQkEsR0FBcEIsRUFBeUJySCxhQUFXLENBQVgsRUFBY0YsS0FBZCxDQUF6QjtLQUhGO1FBS0ltTCxlQUFlc0IsTUFBbkIsRUFBMkJFLGNBQWNMLFdBQWQsRUFBMkIvRSxHQUEzQixFQUFnQyxFQUFFRSxjQUFjLElBQWhCLEVBQXNCc0csS0FBS0QsSUFBM0IsRUFBaEM7V0FDcEJoQixLQUFLdkYsR0FBTCxDQUFQO0dBVEY7YUFXU0ssUUFBUTFGLFdBQVIsQ0FBVCxFQUE2QixVQUE3QixFQUF5QyxTQUFTN0MsUUFBVCxHQUFvQjtXQUNwRCxLQUFLMk4sRUFBWjtHQURGOztRQUlNM00sQ0FBTixHQUFVcU4seUJBQVY7TUFDSXJOLENBQUosR0FBUThNLGVBQVI7Y0FDMEI5TSxDQUExQixHQUE4QnFMLFFBQVFyTCxDQUFSLEdBQVlzTixvQkFBMUM7YUFDeUJ0TixDQUF6QixHQUE2Qm1OLHFCQUE3QjtjQUMwQm5OLENBQTFCLEdBQThCdU4sc0JBQTlCOztNQUVJekMsZUFBZSxDQUFDNU0sUUFBcEIsRUFBMkM7ZUFDaEMrTixXQUFULEVBQXNCLHNCQUF0QixFQUE4Q2tCLHFCQUE5QyxFQUFxRSxJQUFyRTs7O1NBR0tuTixDQUFQLEdBQVcsVUFBVWdDLElBQVYsRUFBZ0I7V0FDbEJ5SyxLQUFLeEIsSUFBSWpKLElBQUosQ0FBTCxDQUFQO0dBREY7OztBQUtGRixVQUFRQSxVQUFRTyxDQUFSLEdBQVlQLFVBQVFrQixDQUFwQixHQUF3QmxCLFVBQVFLLENBQVIsR0FBWSxDQUFDK0osVUFBN0MsRUFBeUQsRUFBRXRILFFBQVEyQyxPQUFWLEVBQXpEOztBQUVBLEtBQUssSUFBSW9HOztBQUVQLGdIQUZvQixDQUdwQjlNLEtBSG9CLENBR2QsR0FIYyxDQUFqQixFQUdTK00sSUFBSSxDQUhsQixFQUdxQkQsV0FBV3JNLE1BQVgsR0FBb0JzTSxDQUh6QztNQUdnREQsV0FBV0MsR0FBWCxDQUFKO0NBRTVDLEtBQUssSUFBSUMsbUJBQW1CckYsTUFBTXlDLElBQUl2RyxLQUFWLENBQXZCLEVBQXlDb0osSUFBSSxDQUFsRCxFQUFxREQsaUJBQWlCdk0sTUFBakIsR0FBMEJ3TSxDQUEvRTtZQUE2RkQsaUJBQWlCQyxHQUFqQixDQUFWO0NBRW5GaE0sVUFBUUEsVUFBUWpELENBQVIsR0FBWWlELFVBQVFLLENBQVIsR0FBWSxDQUFDK0osVUFBakMsRUFBNkMsUUFBN0MsRUFBdUQ7O1NBRTlDLGNBQVVuTSxHQUFWLEVBQWU7V0FDYlMsSUFBSXNMLGNBQUosRUFBb0IvTCxPQUFPLEVBQTNCLElBQ0grTCxlQUFlL0wsR0FBZixDQURHLEdBRUgrTCxlQUFlL0wsR0FBZixJQUFzQndILFFBQVF4SCxHQUFSLENBRjFCO0dBSG1EOztVQVE3QyxTQUFTZ08sTUFBVCxDQUFnQnJCLEdBQWhCLEVBQXFCO1FBQ3ZCLENBQUNFLFNBQVNGLEdBQVQsQ0FBTCxFQUFvQixNQUFNdk8sVUFBVXVPLE1BQU0sbUJBQWhCLENBQU47U0FDZixJQUFJM00sR0FBVCxJQUFnQitMLGNBQWhCO1VBQW9DQSxlQUFlL0wsR0FBZixNQUF3QjJNLEdBQTVCLEVBQWlDLE9BQU8zTSxHQUFQOztHQVZkO2FBWTFDLHFCQUFZO2FBQVcsSUFBVDtHQVo0QjthQWExQyxxQkFBWTthQUFXLEtBQVQ7O0NBYjNCOztBQWdCQStCLFVBQVFBLFVBQVFqRCxDQUFSLEdBQVlpRCxVQUFRSyxDQUFSLEdBQVksQ0FBQytKLFVBQWpDLEVBQTZDLFFBQTdDLEVBQXVEOztVQUU3Q2dCLE9BRjZDOztrQkFJckNKLGVBSnFDOztvQkFNbkNFLGlCQU5tQzs7NEJBUTNCSyx5QkFSMkI7O3VCQVVoQ0Msb0JBVmdDOzt5QkFZOUJDO0NBWnpCOzs7QUFnQkEvQixTQUFTMUosVUFBUUEsVUFBUWpELENBQVIsR0FBWWlELFVBQVFLLENBQVIsSUFBYSxDQUFDK0osVUFBRCxJQUFlbkIsT0FBTyxZQUFZO01BQ3RFbE0sSUFBSTBJLFNBQVI7Ozs7U0FJT21FLFdBQVcsQ0FBQzdNLENBQUQsQ0FBWCxLQUFtQixRQUFuQixJQUErQjZNLFdBQVcsRUFBRWpOLEdBQUdJLENBQUwsRUFBWCxLQUF3QixJQUF2RCxJQUErRDZNLFdBQVdwTixPQUFPTyxDQUFQLENBQVgsS0FBeUIsSUFBL0Y7Q0FMdUQsQ0FBNUIsQ0FBcEIsRUFNSixNQU5JLEVBTUk7YUFDQSxTQUFTOE0sU0FBVCxDQUFtQjNOLEVBQW5CLEVBQXVCO1FBQzVCQSxPQUFPc0MsU0FBUCxJQUFvQnNNLFNBQVM1TyxFQUFULENBQXhCLEVBQXNDLE9BRE47UUFFNUJnUSxPQUFPLENBQUNoUSxFQUFELENBQVg7UUFDSTBJLElBQUksQ0FBUjtRQUNJdUgsUUFBSixFQUFjQyxTQUFkO1dBQ094TSxVQUFVSixNQUFWLEdBQW1Cb0YsQ0FBMUI7V0FBa0M2QixJQUFMLENBQVU3RyxVQUFVZ0YsR0FBVixDQUFWO0tBQzdCdUgsV0FBV0QsS0FBSyxDQUFMLENBQVg7UUFDSSxPQUFPQyxRQUFQLElBQW1CLFVBQXZCLEVBQW1DQyxZQUFZRCxRQUFaO1FBQy9CQyxhQUFhLENBQUMvRSxVQUFROEUsUUFBUixDQUFsQixFQUFxQ0EsV0FBVyxrQkFBVWxPLEdBQVYsRUFBZUosS0FBZixFQUFzQjtVQUNoRXVPLFNBQUosRUFBZXZPLFFBQVF1TyxVQUFValAsSUFBVixDQUFlLElBQWYsRUFBcUJjLEdBQXJCLEVBQTBCSixLQUExQixDQUFSO1VBQ1gsQ0FBQ2lOLFNBQVNqTixLQUFULENBQUwsRUFBc0IsT0FBT0EsS0FBUDtLQUZhO1NBSWhDLENBQUwsSUFBVXNPLFFBQVY7V0FDT3ZDLFdBQVdqSyxLQUFYLENBQWlCK0osS0FBakIsRUFBd0J3QyxJQUF4QixDQUFQOztDQXBCSyxDQUFUOzs7QUF5QkF6RyxRQUFRMUYsV0FBUixFQUFtQmdLLFlBQW5CLEtBQW9DM04sTUFBbUJxSixRQUFRMUYsV0FBUixDQUFuQixFQUF1Q2dLLFlBQXZDLEVBQXFEdEUsUUFBUTFGLFdBQVIsRUFBbUIzQyxPQUF4RSxDQUFwQzs7QUFFQThMLGVBQWV6RCxPQUFmLEVBQXdCLFFBQXhCOztBQUVBeUQsZUFBZXZOLElBQWYsRUFBcUIsTUFBckIsRUFBNkIsSUFBN0I7O0FBRUF1TixlQUFlMU4sU0FBT21PLElBQXRCLEVBQTRCLE1BQTVCLEVBQW9DLElBQXBDOztBQ3pPQTtBQUNBLElBQUkxRyxRQUFNN0csSUFBVjtBQUNBLElBQUkrSSxRQUFNL0ksS0FBa0IsYUFBbEIsQ0FBVjs7QUFFQSxJQUFJaVEsTUFBTXBKLE1BQUksWUFBWTtTQUFTckQsU0FBUDtDQUFkLEVBQUosS0FBNEMsV0FBdEQ7OztBQUdBLElBQUkwTSxTQUFTLFNBQVRBLE1BQVMsQ0FBVXBRLEVBQVYsRUFBYytCLEdBQWQsRUFBbUI7TUFDMUI7V0FDSy9CLEdBQUcrQixHQUFILENBQVA7R0FERixDQUVFLE9BQU8xQixDQUFQLEVBQVU7Q0FIZDs7QUFNQWQsWUFBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7TUFDekJ3QixDQUFKLEVBQU82TyxDQUFQLEVBQVU1TCxDQUFWO1NBQ096RSxPQUFPc0MsU0FBUCxHQUFtQixXQUFuQixHQUFpQ3RDLE9BQU8sSUFBUCxHQUFjOztJQUVsRCxRQUFRcVEsSUFBSUQsT0FBTzVPLElBQUlsQixPQUFPTixFQUFQLENBQVgsRUFBdUJpSixLQUF2QixDQUFaLEtBQTRDLFFBQTVDLEdBQXVEb0g7O0lBRXZERixNQUFNcEosTUFBSXZGLENBQUo7O0lBRU4sQ0FBQ2lELElBQUlzQyxNQUFJdkYsQ0FBSixDQUFMLEtBQWdCLFFBQWhCLElBQTRCLE9BQU9BLEVBQUU4TyxNQUFULElBQW1CLFVBQS9DLEdBQTRELFdBQTVELEdBQTBFN0wsQ0FOOUU7Q0FGRjs7OztBQ1hBLElBQUk4TCxVQUFVclEsUUFBZDtBQUNBLElBQUlzUSxPQUFPLEVBQVg7QUFDQUEsS0FBS3RRLEtBQWtCLGFBQWxCLENBQUwsSUFBeUMsR0FBekM7QUFDQSxJQUFJc1EsT0FBTyxFQUFQLElBQWEsWUFBakIsRUFBK0I7WUFDTmxRLE9BQU82QyxTQUE5QixFQUF5QyxVQUF6QyxFQUFxRCxTQUFTbkMsUUFBVCxHQUFvQjtXQUNoRSxhQUFhdVAsUUFBUSxJQUFSLENBQWIsR0FBNkIsR0FBcEM7R0FERixFQUVHLElBRkg7OztBQ05GLElBQUlqSyxjQUFZcEcsVUFBaEI7QUFDQSxJQUFJZ0YsWUFBVWhGLFFBQWQ7OztBQUdBWCxhQUFBLEdBQWlCLFVBQVVtRCxTQUFWLEVBQXFCO1NBQzdCLFVBQVVXLElBQVYsRUFBZ0JvTixHQUFoQixFQUFxQjtRQUN0QkMsSUFBSXhOLE9BQU9nQyxVQUFRN0IsSUFBUixDQUFQLENBQVI7UUFDSXFGLElBQUlwQyxZQUFVbUssR0FBVixDQUFSO1FBQ0l4QixJQUFJeUIsRUFBRXBOLE1BQVY7UUFDSTdDLENBQUosRUFBTzhDLENBQVA7UUFDSW1GLElBQUksQ0FBSixJQUFTQSxLQUFLdUcsQ0FBbEIsRUFBcUIsT0FBT3ZNLFlBQVksRUFBWixHQUFpQkosU0FBeEI7UUFDakJvTyxFQUFFQyxVQUFGLENBQWFqSSxDQUFiLENBQUo7V0FDT2pJLElBQUksTUFBSixJQUFjQSxJQUFJLE1BQWxCLElBQTRCaUksSUFBSSxDQUFKLEtBQVV1RyxDQUF0QyxJQUEyQyxDQUFDMUwsSUFBSW1OLEVBQUVDLFVBQUYsQ0FBYWpJLElBQUksQ0FBakIsQ0FBTCxJQUE0QixNQUF2RSxJQUFpRm5GLElBQUksTUFBckYsR0FDSGIsWUFBWWdPLEVBQUVsSCxNQUFGLENBQVNkLENBQVQsQ0FBWixHQUEwQmpJLENBRHZCLEdBRUhpQyxZQUFZZ08sRUFBRWxLLEtBQUYsQ0FBUWtDLENBQVIsRUFBV0EsSUFBSSxDQUFmLENBQVosR0FBZ0MsQ0FBQ2pJLElBQUksTUFBSixJQUFjLEVBQWYsS0FBc0I4QyxJQUFJLE1BQTFCLElBQW9DLE9BRnhFO0dBUEY7Q0FERjs7QUNKQWhFLGNBQUEsR0FBaUIsRUFBakI7O0FDQ0EsSUFBSWtKLFdBQVN2SSxhQUFiO0FBQ0EsSUFBSTBRLGFBQWExUSxhQUFqQjtBQUNBLElBQUk4TSxtQkFBaUI5TSxlQUFyQjtBQUNBLElBQUkyUSxvQkFBb0IsRUFBeEI7OztBQUdBM1EsTUFBbUIyUSxpQkFBbkIsRUFBc0MzUSxLQUFrQixVQUFsQixDQUF0QyxFQUFxRSxZQUFZO1NBQVMsSUFBUDtDQUFuRjs7QUFFQVgsZUFBQSxHQUFpQixVQUFVdVIsV0FBVixFQUF1QjNKLElBQXZCLEVBQTZCNEosSUFBN0IsRUFBbUM7Y0FDdEM1TixTQUFaLEdBQXdCc0YsU0FBT29JLGlCQUFQLEVBQTBCLEVBQUVFLE1BQU1ILFdBQVcsQ0FBWCxFQUFjRyxJQUFkLENBQVIsRUFBMUIsQ0FBeEI7bUJBQ2VELFdBQWYsRUFBNEIzSixPQUFPLFdBQW5DO0NBRkY7O0FDVEE7QUFDQSxJQUFJakMsWUFBVWhGLFFBQWQ7QUFDQVgsYUFBQSxHQUFpQixVQUFVUyxFQUFWLEVBQWM7U0FDdEJNLE9BQU80RSxVQUFRbEYsRUFBUixDQUFQLENBQVA7Q0FERjs7QUNGQTtBQUNBLElBQUl3QyxRQUFNdEMsSUFBVjtBQUNBLElBQUk4USxXQUFXOVEsU0FBZjtBQUNBLElBQUlrSyxhQUFXbEssV0FBeUIsVUFBekIsQ0FBZjtBQUNBLElBQUkrTixnQkFBYzNOLE9BQU82QyxTQUF6Qjs7QUFFQTVELGNBQUEsR0FBaUJlLE9BQU8yUSxjQUFQLElBQXlCLFVBQVV6UCxDQUFWLEVBQWE7TUFDakR3UCxTQUFTeFAsQ0FBVCxDQUFKO01BQ0lnQixNQUFJaEIsQ0FBSixFQUFPNEksVUFBUCxDQUFKLEVBQXNCLE9BQU81SSxFQUFFNEksVUFBRixDQUFQO01BQ2xCLE9BQU81SSxFQUFFMFAsV0FBVCxJQUF3QixVQUF4QixJQUFzQzFQLGFBQWFBLEVBQUUwUCxXQUF6RCxFQUFzRTtXQUM3RDFQLEVBQUUwUCxXQUFGLENBQWMvTixTQUFyQjtHQUNBLE9BQU8zQixhQUFhbEIsTUFBYixHQUFzQjJOLGFBQXRCLEdBQW9DLElBQTNDO0NBTEo7O0FDTEEsSUFBSTVFLFlBQVVuSixRQUFkO0FBQ0EsSUFBSTRELFlBQVU1RCxPQUFkO0FBQ0EsSUFBSXlELGFBQVd6RCxTQUFmO0FBQ0EsSUFBSXFDLFNBQU9yQyxLQUFYO0FBQ0EsSUFBSXNDLFFBQU10QyxJQUFWO0FBQ0EsSUFBSWlSLFlBQVlqUixVQUFoQjtBQUNBLElBQUlrUixjQUFjbFIsV0FBbEI7QUFDQSxJQUFJOE0sbUJBQWlCOU0sZUFBckI7QUFDQSxJQUFJK1EsaUJBQWlCL1EsVUFBckI7QUFDQSxJQUFJbVIsV0FBV25SLEtBQWtCLFVBQWxCLENBQWY7QUFDQSxJQUFJb1IsUUFBUSxFQUFFLEdBQUc1RyxJQUFILElBQVcsVUFBVSxHQUFHQSxJQUFILEVBQXZCLENBQVo7QUFDQSxJQUFJNkcsY0FBYyxZQUFsQjtBQUNBLElBQUlDLE9BQU8sTUFBWDtBQUNBLElBQUlDLFNBQVMsUUFBYjs7QUFFQSxJQUFJQyxhQUFhLFNBQWJBLFVBQWEsR0FBWTtTQUFTLElBQVA7Q0FBL0I7O0FBRUFuUyxlQUFBLEdBQWlCLFVBQVVvUyxJQUFWLEVBQWdCeEssSUFBaEIsRUFBc0IySixXQUF0QixFQUFtQ0MsSUFBbkMsRUFBeUNhLE9BQXpDLEVBQWtEQyxNQUFsRCxFQUEwREMsTUFBMUQsRUFBa0U7Y0FDckVoQixXQUFaLEVBQXlCM0osSUFBekIsRUFBK0I0SixJQUEvQjtNQUNJZ0IsWUFBWSxTQUFaQSxTQUFZLENBQVVDLElBQVYsRUFBZ0I7UUFDMUIsQ0FBQ1YsS0FBRCxJQUFVVSxRQUFRQyxLQUF0QixFQUE2QixPQUFPQSxNQUFNRCxJQUFOLENBQVA7WUFDckJBLElBQVI7V0FDT1IsSUFBTDtlQUFrQixTQUFTOUcsSUFBVCxHQUFnQjtpQkFBUyxJQUFJb0csV0FBSixDQUFnQixJQUFoQixFQUFzQmtCLElBQXRCLENBQVA7U0FBekI7V0FDTlAsTUFBTDtlQUFvQixTQUFTUyxNQUFULEdBQWtCO2lCQUFTLElBQUlwQixXQUFKLENBQWdCLElBQWhCLEVBQXNCa0IsSUFBdEIsQ0FBUDtTQUEzQjtLQUNiLE9BQU8sU0FBU0csT0FBVCxHQUFtQjthQUFTLElBQUlyQixXQUFKLENBQWdCLElBQWhCLEVBQXNCa0IsSUFBdEIsQ0FBUDtLQUE1QjtHQUxKO01BT0kvSSxNQUFNOUIsT0FBTyxXQUFqQjtNQUNJaUwsYUFBYVIsV0FBV0gsTUFBNUI7TUFDSVksYUFBYSxLQUFqQjtNQUNJSixRQUFRTixLQUFLeE8sU0FBakI7TUFDSW1QLFVBQVVMLE1BQU1aLFFBQU4sS0FBbUJZLE1BQU1WLFdBQU4sQ0FBbkIsSUFBeUNLLFdBQVdLLE1BQU1MLE9BQU4sQ0FBbEU7TUFDSVcsV0FBV0QsV0FBV1AsVUFBVUgsT0FBVixDQUExQjtNQUNJWSxXQUFXWixVQUFVLENBQUNRLFVBQUQsR0FBY0csUUFBZCxHQUF5QlIsVUFBVSxTQUFWLENBQW5DLEdBQTBEelAsU0FBekU7TUFDSW1RLGFBQWF0TCxRQUFRLE9BQVIsR0FBa0I4SyxNQUFNRSxPQUFOLElBQWlCRyxPQUFuQyxHQUE2Q0EsT0FBOUQ7TUFDSUksT0FBSixFQUFhM1EsR0FBYixFQUFrQjhPLGlCQUFsQjs7TUFFSTRCLFVBQUosRUFBZ0I7d0JBQ014QixlQUFld0IsV0FBV3hSLElBQVgsQ0FBZ0IsSUFBSTBRLElBQUosRUFBaEIsQ0FBZixDQUFwQjtRQUNJZCxzQkFBc0J2USxPQUFPNkMsU0FBN0IsSUFBMEMwTixrQkFBa0JFLElBQWhFLEVBQXNFOzt1QkFFckRGLGlCQUFmLEVBQWtDNUgsR0FBbEMsRUFBdUMsSUFBdkM7O1VBRUksQ0FBQ0ksU0FBRCxJQUFZLENBQUM3RyxNQUFJcU8saUJBQUosRUFBdUJRLFFBQXZCLENBQWpCLEVBQW1EOU8sT0FBS3NPLGlCQUFMLEVBQXdCUSxRQUF4QixFQUFrQ0ssVUFBbEM7Ozs7TUFJbkRVLGNBQWNFLE9BQWQsSUFBeUJBLFFBQVF0TyxJQUFSLEtBQWlCeU4sTUFBOUMsRUFBc0Q7aUJBQ3ZDLElBQWI7ZUFDVyxTQUFTUyxNQUFULEdBQWtCO2FBQVNJLFFBQVFyUixJQUFSLENBQWEsSUFBYixDQUFQO0tBQS9COzs7TUFHRSxDQUFDLENBQUNvSSxTQUFELElBQVl5SSxNQUFiLE1BQXlCUixTQUFTZSxVQUFULElBQXVCLENBQUNKLE1BQU1aLFFBQU4sQ0FBakQsQ0FBSixFQUF1RTtXQUNoRVksS0FBTCxFQUFZWixRQUFaLEVBQXNCa0IsUUFBdEI7OztZQUdRcEwsSUFBVixJQUFrQm9MLFFBQWxCO1lBQ1V0SixHQUFWLElBQWlCeUksVUFBakI7TUFDSUUsT0FBSixFQUFhO2NBQ0Q7Y0FDQVEsYUFBYUcsUUFBYixHQUF3QlIsVUFBVU4sTUFBVixDQUR4QjtZQUVGSSxTQUFTVSxRQUFULEdBQW9CUixVQUFVUCxJQUFWLENBRmxCO2VBR0NnQjtLQUhYO1FBS0lWLE1BQUosRUFBWSxLQUFLL1AsR0FBTCxJQUFZMlEsT0FBWixFQUFxQjtVQUMzQixFQUFFM1EsT0FBT2tRLEtBQVQsQ0FBSixFQUFxQnRPLFdBQVNzTyxLQUFULEVBQWdCbFEsR0FBaEIsRUFBcUIyUSxRQUFRM1EsR0FBUixDQUFyQjtLQUR2QixNQUVPK0IsVUFBUUEsVUFBUXJDLENBQVIsR0FBWXFDLFVBQVFLLENBQVIsSUFBYW1OLFNBQVNlLFVBQXRCLENBQXBCLEVBQXVEbEwsSUFBdkQsRUFBNkR1TCxPQUE3RDs7U0FFRkEsT0FBUDtDQWxERjs7QUNqQkEsSUFBSUMsTUFBTXpTLFVBQXdCLElBQXhCLENBQVY7OztBQUdBQSxZQUEwQmdELE1BQTFCLEVBQWtDLFFBQWxDLEVBQTRDLFVBQVUwUCxRQUFWLEVBQW9CO09BQ3pEQyxFQUFMLEdBQVUzUCxPQUFPMFAsUUFBUCxDQUFWLENBRDhEO09BRXpERSxFQUFMLEdBQVUsQ0FBVixDQUY4RDs7Q0FBaEUsRUFJRyxZQUFZO01BQ1R0UixJQUFJLEtBQUtxUixFQUFiO01BQ0luTCxRQUFRLEtBQUtvTCxFQUFqQjtNQUNJQyxLQUFKO01BQ0lyTCxTQUFTbEcsRUFBRThCLE1BQWYsRUFBdUIsT0FBTyxFQUFFM0IsT0FBT1csU0FBVCxFQUFvQjBRLE1BQU0sSUFBMUIsRUFBUDtVQUNmTCxJQUFJblIsQ0FBSixFQUFPa0csS0FBUCxDQUFSO09BQ0tvTCxFQUFMLElBQVdDLE1BQU16UCxNQUFqQjtTQUNPLEVBQUUzQixPQUFPb1IsS0FBVCxFQUFnQkMsTUFBTSxLQUF0QixFQUFQO0NBWEY7O0FDSkE7QUFDQSxJQUFJN1IsYUFBV2pCLFNBQWY7QUFDQVgsYUFBQSxHQUFpQixVQUFVc1AsUUFBVixFQUFvQi9OLEVBQXBCLEVBQXdCYSxLQUF4QixFQUErQndRLE9BQS9CLEVBQXdDO01BQ25EO1dBQ0tBLFVBQVVyUixHQUFHSyxXQUFTUSxLQUFULEVBQWdCLENBQWhCLENBQUgsRUFBdUJBLE1BQU0sQ0FBTixDQUF2QixDQUFWLEdBQTZDYixHQUFHYSxLQUFILENBQXBEOztHQURGLENBR0UsT0FBT3RCLENBQVAsRUFBVTtRQUNONFMsTUFBTXBFLFNBQVMsUUFBVCxDQUFWO1FBQ0lvRSxRQUFRM1EsU0FBWixFQUF1Qm5CLFdBQVM4UixJQUFJaFMsSUFBSixDQUFTNE4sUUFBVCxDQUFUO1VBQ2pCeE8sQ0FBTjs7Q0FQSjs7QUNGQTtBQUNBLElBQUk4USxjQUFZalIsVUFBaEI7QUFDQSxJQUFJbVIsYUFBV25SLEtBQWtCLFVBQWxCLENBQWY7QUFDQSxJQUFJZ1QsYUFBYWhJLE1BQU0vSCxTQUF2Qjs7QUFFQTVELGdCQUFBLEdBQWlCLFVBQVVTLEVBQVYsRUFBYztTQUN0QkEsT0FBT3NDLFNBQVAsS0FBcUI2TyxZQUFVakcsS0FBVixLQUFvQmxMLEVBQXBCLElBQTBCa1QsV0FBVzdCLFVBQVgsTUFBeUJyUixFQUF4RSxDQUFQO0NBREY7O0FDSkEsSUFBSThPLG9CQUFrQjVPLFNBQXRCO0FBQ0EsSUFBSTJCLGVBQWEzQixhQUFqQjs7QUFFQVgsbUJBQUEsR0FBaUIsVUFBVXVDLE1BQVYsRUFBa0I0RixLQUFsQixFQUF5Qi9GLEtBQXpCLEVBQWdDO01BQzNDK0YsU0FBUzVGLE1BQWIsRUFBcUJnTixrQkFBZ0I5TSxDQUFoQixDQUFrQkYsTUFBbEIsRUFBMEI0RixLQUExQixFQUFpQzdGLGFBQVcsQ0FBWCxFQUFjRixLQUFkLENBQWpDLEVBQXJCLEtBQ0tHLE9BQU80RixLQUFQLElBQWdCL0YsS0FBaEI7Q0FGUDs7QUNKQSxJQUFJNE8sWUFBVXJRLFFBQWQ7QUFDQSxJQUFJbVIsYUFBV25SLEtBQWtCLFVBQWxCLENBQWY7QUFDQSxJQUFJaVIsY0FBWWpSLFVBQWhCO0FBQ0FYLDBCQUFBLEdBQWlCVyxNQUFtQmlULGlCQUFuQixHQUF1QyxVQUFVblQsRUFBVixFQUFjO01BQ2hFQSxNQUFNc0MsU0FBVixFQUFxQixPQUFPdEMsR0FBR3FSLFVBQUgsS0FDdkJyUixHQUFHLFlBQUgsQ0FEdUIsSUFFdkJtUixZQUFVWixVQUFRdlEsRUFBUixDQUFWLENBRmdCO0NBRHZCOztBQ0hBLElBQUlxUixhQUFXblIsS0FBa0IsVUFBbEIsQ0FBZjtBQUNBLElBQUlrVCxlQUFlLEtBQW5COztBQUVBLElBQUk7TUFDRUMsUUFBUSxDQUFDLENBQUQsRUFBSWhDLFVBQUosR0FBWjtRQUNNLFFBQU4sSUFBa0IsWUFBWTttQkFBaUIsSUFBZjtHQUFoQzs7UUFFTWlDLElBQU4sQ0FBV0QsS0FBWCxFQUFrQixZQUFZO1VBQVEsQ0FBTjtHQUFoQztDQUpGLENBS0UsT0FBT2hULENBQVAsRUFBVTs7QUFFWmQsZUFBQSxHQUFpQixVQUFVYSxJQUFWLEVBQWdCbVQsV0FBaEIsRUFBNkI7TUFDeEMsQ0FBQ0EsV0FBRCxJQUFnQixDQUFDSCxZQUFyQixFQUFtQyxPQUFPLEtBQVA7TUFDL0JyUSxPQUFPLEtBQVg7TUFDSTtRQUNFeVEsTUFBTSxDQUFDLENBQUQsQ0FBVjtRQUNJQyxPQUFPRCxJQUFJbkMsVUFBSixHQUFYO1NBQ0tOLElBQUwsR0FBWSxZQUFZO2FBQVMsRUFBRWlDLE1BQU1qUSxPQUFPLElBQWYsRUFBUDtLQUExQjtRQUNJc08sVUFBSixJQUFnQixZQUFZO2FBQVNvQyxJQUFQO0tBQTlCO1NBQ0tELEdBQUw7R0FMRixDQU1FLE9BQU9uVCxDQUFQLEVBQVU7U0FDTDBDLElBQVA7Q0FWRjs7QUNUQSxJQUFJYSxRQUFNMUQsSUFBVjtBQUNBLElBQUk0RCxZQUFVNUQsT0FBZDtBQUNBLElBQUk4USxhQUFXOVEsU0FBZjtBQUNBLElBQUllLE9BQU9mLFNBQVg7QUFDQSxJQUFJd1QsY0FBY3hULFlBQWxCO0FBQ0EsSUFBSW1ILGFBQVduSCxTQUFmO0FBQ0EsSUFBSXlULGlCQUFpQnpULGVBQXJCO0FBQ0EsSUFBSTBULFlBQVkxVCxzQkFBaEI7O0FBRUE0RCxVQUFRQSxVQUFRakQsQ0FBUixHQUFZaUQsVUFBUUssQ0FBUixHQUFZLENBQUNqRSxZQUEwQixVQUFVdVQsSUFBVixFQUFnQjtRQUFRSCxJQUFOLENBQVdHLElBQVg7Q0FBNUMsQ0FBakMsRUFBbUcsT0FBbkcsRUFBNEc7O1FBRXBHLFNBQVNILElBQVQsQ0FBY08sU0FBZCxpREFBd0U7UUFDeEVyUyxJQUFJd1AsV0FBUzZDLFNBQVQsQ0FBUjtRQUNJQyxJQUFJLE9BQU8sSUFBUCxJQUFlLFVBQWYsR0FBNEIsSUFBNUIsR0FBbUM1SSxLQUEzQztRQUNJNkksT0FBT3JRLFVBQVVKLE1BQXJCO1FBQ0kwUSxRQUFRRCxPQUFPLENBQVAsR0FBV3JRLFVBQVUsQ0FBVixDQUFYLEdBQTBCcEIsU0FBdEM7UUFDSTJSLFVBQVVELFVBQVUxUixTQUF4QjtRQUNJb0YsUUFBUSxDQUFaO1FBQ0l3TSxTQUFTTixVQUFVcFMsQ0FBVixDQUFiO1FBQ0k4QixNQUFKLEVBQVlnSCxNQUFaLEVBQW9CNkosSUFBcEIsRUFBMEJ0RixRQUExQjtRQUNJb0YsT0FBSixFQUFhRCxRQUFRcFEsTUFBSW9RLEtBQUosRUFBV0QsT0FBTyxDQUFQLEdBQVdyUSxVQUFVLENBQVYsQ0FBWCxHQUEwQnBCLFNBQXJDLEVBQWdELENBQWhELENBQVI7O1FBRVQ0UixVQUFVNVIsU0FBVixJQUF1QixFQUFFd1IsS0FBSzVJLEtBQUwsSUFBY3dJLFlBQVlRLE1BQVosQ0FBaEIsQ0FBM0IsRUFBaUU7V0FDMURyRixXQUFXcUYsT0FBT2pULElBQVAsQ0FBWU8sQ0FBWixDQUFYLEVBQTJCOEksU0FBUyxJQUFJd0osQ0FBSixFQUF6QyxFQUFrRCxDQUFDLENBQUNLLE9BQU90RixTQUFTa0MsSUFBVCxFQUFSLEVBQXlCaUMsSUFBNUUsRUFBa0Z0TCxPQUFsRixFQUEyRjt1QkFDMUU0QyxNQUFmLEVBQXVCNUMsS0FBdkIsRUFBOEJ1TSxVQUFVaFQsS0FBSzROLFFBQUwsRUFBZW1GLEtBQWYsRUFBc0IsQ0FBQ0csS0FBS3hTLEtBQU4sRUFBYStGLEtBQWIsQ0FBdEIsRUFBMkMsSUFBM0MsQ0FBVixHQUE2RHlNLEtBQUt4UyxLQUFoRzs7S0FGSixNQUlPO2VBQ0kwRixXQUFTN0YsRUFBRThCLE1BQVgsQ0FBVDtXQUNLZ0gsU0FBUyxJQUFJd0osQ0FBSixDQUFNeFEsTUFBTixDQUFkLEVBQTZCQSxTQUFTb0UsS0FBdEMsRUFBNkNBLE9BQTdDLEVBQXNEO3VCQUNyQzRDLE1BQWYsRUFBdUI1QyxLQUF2QixFQUE4QnVNLFVBQVVELE1BQU14UyxFQUFFa0csS0FBRixDQUFOLEVBQWdCQSxLQUFoQixDQUFWLEdBQW1DbEcsRUFBRWtHLEtBQUYsQ0FBakU7OztXQUdHcEUsTUFBUCxHQUFnQm9FLEtBQWhCO1dBQ080QyxNQUFQOztDQXhCSjs7QUNUQSxJQUFJeEcsWUFBVTVELE9BQWQ7QUFDQSxJQUFJeVQsbUJBQWlCelQsZUFBckI7OztBQUdBNEQsVUFBUUEsVUFBUWpELENBQVIsR0FBWWlELFVBQVFLLENBQVIsR0FBWWpFLE9BQW9CLFlBQVk7V0FDckRpRSxDQUFULEdBQWE7U0FDTixFQUFFK0csTUFBTWtKLEVBQU4sQ0FBU25ULElBQVQsQ0FBY2tELENBQWQsYUFBNEJBLENBQTlCLENBQVA7Q0FGOEIsQ0FBaEMsRUFHSSxPQUhKLEVBR2E7O01BRVAsU0FBU2lRLEVBQVQsZ0JBQTJCO1FBQ3pCMU0sUUFBUSxDQUFaO1FBQ0lxTSxPQUFPclEsVUFBVUosTUFBckI7UUFDSWdILFNBQVMsS0FBSyxPQUFPLElBQVAsSUFBZSxVQUFmLEdBQTRCLElBQTVCLEdBQW1DWSxLQUF4QyxFQUErQzZJLElBQS9DLENBQWI7V0FDT0EsT0FBT3JNLEtBQWQ7dUJBQW9DNEMsTUFBZixFQUF1QjVDLEtBQXZCLEVBQThCaEUsVUFBVWdFLE9BQVYsQ0FBOUI7S0FDckI0QyxPQUFPaEgsTUFBUCxHQUFnQnlRLElBQWhCO1dBQ096SixNQUFQOztDQVhKOztBQ0xBLElBQUlySyxhQUFXQyxTQUFmO0FBQ0EsSUFBSWlMLFlBQVVqTCxRQUFkO0FBQ0EsSUFBSW1VLFVBQVVuVSxLQUFrQixTQUFsQixDQUFkOztBQUVBWCw0QkFBQSxHQUFpQixVQUFVK1UsUUFBVixFQUFvQjtNQUMvQlIsQ0FBSjtNQUNJM0ksVUFBUW1KLFFBQVIsQ0FBSixFQUF1QjtRQUNqQkEsU0FBU3BELFdBQWI7O1FBRUksT0FBTzRDLENBQVAsSUFBWSxVQUFaLEtBQTJCQSxNQUFNNUksS0FBTixJQUFlQyxVQUFRMkksRUFBRTNRLFNBQVYsQ0FBMUMsQ0FBSixFQUFxRTJRLElBQUl4UixTQUFKO1FBQ2pFckMsV0FBUzZULENBQVQsQ0FBSixFQUFpQjtVQUNYQSxFQUFFTyxPQUFGLENBQUo7VUFDSVAsTUFBTSxJQUFWLEVBQWdCQSxJQUFJeFIsU0FBSjs7R0FFbEIsT0FBT3dSLE1BQU14UixTQUFOLEdBQWtCNEksS0FBbEIsR0FBMEI0SSxDQUFqQztDQVZKOztBQ0pBO0FBQ0EsSUFBSVMscUJBQXFCclUsd0JBQXpCOztBQUVBWCx1QkFBQSxHQUFpQixVQUFVK1UsUUFBVixFQUFvQmhSLE1BQXBCLEVBQTRCO1NBQ3BDLEtBQUtpUixtQkFBbUJELFFBQW5CLENBQUwsRUFBbUNoUixNQUFuQyxDQUFQO0NBREY7O0FDSEE7Ozs7Ozs7QUFPQSxJQUFJTSxRQUFNMUQsSUFBVjtBQUNBLElBQUl3SixZQUFVeEosUUFBZDtBQUNBLElBQUk4USxhQUFXOVEsU0FBZjtBQUNBLElBQUltSCxhQUFXbkgsU0FBZjtBQUNBLElBQUlzVSxNQUFNdFUsbUJBQVY7QUFDQVgsaUJBQUEsR0FBaUIsVUFBVXlHLElBQVYsRUFBZ0JrSixPQUFoQixFQUF5QjtNQUNwQ3VGLFNBQVN6TyxRQUFRLENBQXJCO01BQ0kwTyxZQUFZMU8sUUFBUSxDQUF4QjtNQUNJMk8sVUFBVTNPLFFBQVEsQ0FBdEI7TUFDSTRPLFdBQVc1TyxRQUFRLENBQXZCO01BQ0k2TyxnQkFBZ0I3TyxRQUFRLENBQTVCO01BQ0k4TyxXQUFXOU8sUUFBUSxDQUFSLElBQWE2TyxhQUE1QjtNQUNJcE0sU0FBU3lHLFdBQVdzRixHQUF4QjtTQUNPLFVBQVV6SyxLQUFWLEVBQWlCZ0wsVUFBakIsRUFBNkIxUixJQUE3QixFQUFtQztRQUNwQzdCLElBQUl3UCxXQUFTakgsS0FBVCxDQUFSO1FBQ0lySyxPQUFPZ0ssVUFBUWxJLENBQVIsQ0FBWDtRQUNJUSxJQUFJNEIsTUFBSW1SLFVBQUosRUFBZ0IxUixJQUFoQixFQUFzQixDQUF0QixDQUFSO1FBQ0lDLFNBQVMrRCxXQUFTM0gsS0FBSzRELE1BQWQsQ0FBYjtRQUNJb0UsUUFBUSxDQUFaO1FBQ0k0QyxTQUFTbUssU0FBU2hNLE9BQU9zQixLQUFQLEVBQWN6RyxNQUFkLENBQVQsR0FBaUNvUixZQUFZak0sT0FBT3NCLEtBQVAsRUFBYyxDQUFkLENBQVosR0FBK0J6SCxTQUE3RTtRQUNJdkIsR0FBSixFQUFTaVUsR0FBVDtXQUNNMVIsU0FBU29FLEtBQWYsRUFBc0JBLE9BQXRCO1VBQW1Db04sWUFBWXBOLFNBQVNoSSxJQUF6QixFQUErQjtjQUN0REEsS0FBS2dJLEtBQUwsQ0FBTjtjQUNNMUYsRUFBRWpCLEdBQUYsRUFBTzJHLEtBQVAsRUFBY2xHLENBQWQsQ0FBTjtZQUNJd0UsSUFBSixFQUFVO2NBQ0p5TyxNQUFKLEVBQVluSyxPQUFPNUMsS0FBUCxJQUFnQnNOLEdBQWhCLENBQVo7ZUFDSyxJQUFJQSxHQUFKLEVBQVMsUUFBUWhQLElBQVI7bUJBQ1AsQ0FBTDt1QkFBZSxJQUFQLENBREk7bUJBRVAsQ0FBTDt1QkFBZWpGLEdBQVAsQ0FGSTttQkFHUCxDQUFMO3VCQUFlMkcsS0FBUCxDQUhJO21CQUlQLENBQUw7dUJBQWU2QyxJQUFQLENBQVl4SixHQUFaLEVBSkk7YUFBVCxNQUtFLElBQUk2VCxRQUFKLEVBQWMsT0FBTyxLQUFQLENBUGI7OztLQVVaLE9BQU9DLGdCQUFnQixDQUFDLENBQWpCLEdBQXFCRixXQUFXQyxRQUFYLEdBQXNCQSxRQUF0QixHQUFpQ3RLLE1BQTdEO0dBckJGO0NBUkY7O0FDWkE7QUFDQSxJQUFJMkssY0FBYy9VLEtBQWtCLGFBQWxCLENBQWxCO0FBQ0EsSUFBSWdULGVBQWFoSSxNQUFNL0gsU0FBdkI7QUFDQSxJQUFJK1AsYUFBVytCLFdBQVgsS0FBMkIzUyxTQUEvQixFQUEwQ3BDLE1BQW1CZ1QsWUFBbkIsRUFBK0IrQixXQUEvQixFQUE0QyxFQUE1QztBQUMxQzFWLHFCQUFBLEdBQWlCLFVBQVV3QyxHQUFWLEVBQWU7ZUFDbkJrVCxXQUFYLEVBQXdCbFQsR0FBeEIsSUFBK0IsSUFBL0I7Q0FERjs7OztBQ0ZBLElBQUkrQixZQUFVNUQsT0FBZDtBQUNBLElBQUlnVixRQUFRaFYsY0FBNEIsQ0FBNUIsQ0FBWjtBQUNBLElBQUl5RixRQUFNLE1BQVY7QUFDQSxJQUFJd1AsU0FBUyxJQUFiOztBQUVBLElBQUl4UCxTQUFPLEVBQVgsRUFBZXVGLE1BQU0sQ0FBTixFQUFTdkYsS0FBVCxFQUFjLFlBQVk7V0FBVyxLQUFUO0NBQTVCO0FBQ2Y3QixVQUFRQSxVQUFRckMsQ0FBUixHQUFZcUMsVUFBUUssQ0FBUixHQUFZZ1IsTUFBaEMsRUFBd0MsT0FBeEMsRUFBaUQ7UUFDekMsU0FBU0MsSUFBVCxDQUFjTCxVQUFkLDJCQUFtRDtXQUNoREcsTUFBTSxJQUFOLEVBQVlILFVBQVosRUFBd0JyUixVQUFVSixNQUFWLEdBQW1CLENBQW5CLEdBQXVCSSxVQUFVLENBQVYsQ0FBdkIsR0FBc0NwQixTQUE5RCxDQUFQOztDQUZKO0FBS0FwQyxrQkFBaUN5RixLQUFqQzs7OztBQ1hBLElBQUk3QixZQUFVNUQsT0FBZDtBQUNBLElBQUlnVixVQUFRaFYsY0FBNEIsQ0FBNUIsQ0FBWjtBQUNBLElBQUl5RixRQUFNLFdBQVY7QUFDQSxJQUFJd1AsV0FBUyxJQUFiOztBQUVBLElBQUl4UCxTQUFPLEVBQVgsRUFBZXVGLE1BQU0sQ0FBTixFQUFTdkYsS0FBVCxFQUFjLFlBQVk7YUFBVyxLQUFUO0NBQTVCO0FBQ2Y3QixVQUFRQSxVQUFRckMsQ0FBUixHQUFZcUMsVUFBUUssQ0FBUixHQUFZZ1IsUUFBaEMsRUFBd0MsT0FBeEMsRUFBaUQ7YUFDcEMsU0FBU0UsU0FBVCxDQUFtQk4sVUFBbkIsMkJBQXdEO1dBQzFERyxRQUFNLElBQU4sRUFBWUgsVUFBWixFQUF3QnJSLFVBQVVKLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJJLFVBQVUsQ0FBVixDQUF2QixHQUFzQ3BCLFNBQTlELENBQVA7O0NBRko7QUFLQXBDLGtCQUFpQ3lGLEtBQWpDOzs7O0FDWEEsSUFBSWlGLFlBQVUxSyxXQUFkO0FBQ0EsSUFBSTJLLFNBQU8zSyxXQUFYO0FBQ0EsSUFBSTRLLFFBQU01SyxVQUFWO0FBQ0EsSUFBSThRLGFBQVc5USxTQUFmO0FBQ0EsSUFBSXdKLFlBQVV4SixRQUFkO0FBQ0EsSUFBSW9WLFVBQVVoVixPQUFPaVYsTUFBckI7OztBQUdBaFcsaUJBQUEsR0FBaUIsQ0FBQytWLE9BQUQsSUFBWXBWLE9BQW9CLFlBQVk7TUFDdkRzVixJQUFJLEVBQVI7TUFDSS9RLElBQUksRUFBUjs7TUFFSTVELElBQUkrRixRQUFSO01BQ0k2TyxJQUFJLHNCQUFSO0lBQ0U1VSxDQUFGLElBQU8sQ0FBUDtJQUNFZ0MsS0FBRixDQUFRLEVBQVIsRUFBWTZTLE9BQVosQ0FBb0IsVUFBVTVGLENBQVYsRUFBYTtNQUFJQSxDQUFGLElBQU9BLENBQVA7R0FBbkM7U0FDT3dGLFFBQVEsRUFBUixFQUFZRSxDQUFaLEVBQWUzVSxDQUFmLEtBQXFCLENBQXJCLElBQTBCUCxPQUFPb0ssSUFBUCxDQUFZNEssUUFBUSxFQUFSLEVBQVk3USxDQUFaLENBQVosRUFBNEJ4QixJQUE1QixDQUFpQyxFQUFqQyxLQUF3Q3dTLENBQXpFO0NBUjJCLENBQVosR0FTWixTQUFTRixNQUFULENBQWdCN1EsTUFBaEIsRUFBd0JULE1BQXhCLEVBQWdDOztNQUMvQm9NLElBQUlXLFdBQVN0TSxNQUFULENBQVI7TUFDSXFQLE9BQU9yUSxVQUFVSixNQUFyQjtNQUNJb0UsUUFBUSxDQUFaO01BQ0lxRCxhQUFhRixPQUFLN0ksQ0FBdEI7TUFDSWlKLFNBQVNILE1BQUk5SSxDQUFqQjtTQUNPK1IsT0FBT3JNLEtBQWQsRUFBcUI7UUFDZjdHLElBQUk2SSxVQUFRaEcsVUFBVWdFLE9BQVYsQ0FBUixDQUFSO1FBQ0lnRCxPQUFPSyxhQUFhSCxVQUFRL0osQ0FBUixFQUFXd0IsTUFBWCxDQUFrQjBJLFdBQVdsSyxDQUFYLENBQWxCLENBQWIsR0FBZ0QrSixVQUFRL0osQ0FBUixDQUEzRDtRQUNJeUMsU0FBU29ILEtBQUtwSCxNQUFsQjtRQUNJc00sSUFBSSxDQUFSO1FBQ0k3TixHQUFKO1dBQ091QixTQUFTc00sQ0FBaEI7VUFBdUIzRSxPQUFPaEssSUFBUCxDQUFZSixDQUFaLEVBQWVrQixNQUFNMkksS0FBS2tGLEdBQUwsQ0FBckIsQ0FBSixFQUFxQ1MsRUFBRXRPLEdBQUYsSUFBU2xCLEVBQUVrQixHQUFGLENBQVQ7O0dBQ3hELE9BQU9zTyxDQUFQO0NBdEJhLEdBdUJiaUYsT0F2Qko7O0FDVkE7QUFDQSxJQUFJeFIsYUFBVTVELE9BQWQ7O0FBRUE0RCxXQUFRQSxXQUFRakQsQ0FBUixHQUFZaUQsV0FBUUssQ0FBNUIsRUFBK0IsUUFBL0IsRUFBeUMsRUFBRW9SLFFBQVFyVixhQUFWLEVBQXpDOztBQ0hBO0FBQ0FYLGNBQUEsR0FBaUJlLE9BQU9LLEVBQVAsSUFBYSxTQUFTQSxFQUFULENBQVlnVixDQUFaLEVBQWVDLENBQWYsRUFBa0I7O1NBRXZDRCxNQUFNQyxDQUFOLEdBQVVELE1BQU0sQ0FBTixJQUFXLElBQUlBLENBQUosS0FBVSxJQUFJQyxDQUFuQyxHQUF1Q0QsS0FBS0EsQ0FBTCxJQUFVQyxLQUFLQSxDQUE3RDtDQUZGOztBQ0RBO0FBQ0EsSUFBSTlSLGFBQVU1RCxPQUFkO0FBQ0E0RCxXQUFRQSxXQUFRakQsQ0FBaEIsRUFBbUIsUUFBbkIsRUFBNkIsRUFBRUYsSUFBSVQsVUFBTixFQUE3Qjs7QUNGQTs7QUFFQSxDQUFDLFVBQVUyVixZQUFWLEVBQXdCO0tBQ3BCLE9BQU9BLGFBQWFDLE9BQXBCLEtBQWdDLFVBQXBDLEVBQWdEO2VBQ2xDQSxPQUFiLEdBQXVCRCxhQUFhRSxpQkFBYixJQUFrQ0YsYUFBYUcsa0JBQS9DLElBQXFFSCxhQUFhSSxxQkFBbEYsSUFBMkcsU0FBU0gsT0FBVCxDQUFpQkksUUFBakIsRUFBMkI7T0FDeEpDLFVBQVUsSUFBZDtPQUNJQyxXQUFXLENBQUNELFFBQVF6VixRQUFSLElBQW9CeVYsUUFBUUUsYUFBN0IsRUFBNENDLGdCQUE1QyxDQUE2REosUUFBN0QsQ0FBZjtPQUNJeE8sUUFBUSxDQUFaOztVQUVPME8sU0FBUzFPLEtBQVQsS0FBbUIwTyxTQUFTMU8sS0FBVCxNQUFvQnlPLE9BQTlDLEVBQXVEO01BQ3BEek8sS0FBRjs7O1VBR002TyxRQUFRSCxTQUFTMU8sS0FBVCxDQUFSLENBQVA7R0FURDs7O0tBYUcsT0FBT21PLGFBQWFXLE9BQXBCLEtBQWdDLFVBQXBDLEVBQWdEO2VBQ2xDQSxPQUFiLEdBQXVCLFNBQVNBLE9BQVQsQ0FBaUJOLFFBQWpCLEVBQTJCO09BQzdDQyxVQUFVLElBQWQ7O1VBRU9BLFdBQVdBLFFBQVFNLFFBQVIsS0FBcUIsQ0FBdkMsRUFBMEM7UUFDckNOLFFBQVFMLE9BQVIsQ0FBZ0JJLFFBQWhCLENBQUosRUFBK0I7WUFDdkJDLE9BQVA7OztjQUdTQSxRQUFRTyxVQUFsQjs7O1VBR00sSUFBUDtHQVhEOztDQWhCRixFQThCR2xYLE9BQU9tWCxPQUFQLENBQWV4VCxTQTlCbEI7O0FDYUE7QUFDQSxJQUFJLENBQUN3VCxRQUFReFQsU0FBUixDQUFrQjJTLE9BQXZCLEVBQWdDO1lBQ3BCM1MsU0FBUixDQUFrQjJTLE9BQWxCLEdBQ0lhLFFBQVF4VCxTQUFSLENBQWtCeVQsZUFBbEIsSUFDQUQsUUFBUXhULFNBQVIsQ0FBa0I2UyxrQkFEbEIsSUFFQVcsUUFBUXhULFNBQVIsQ0FBa0I0UyxpQkFGbEIsSUFHQVksUUFBUXhULFNBQVIsQ0FBa0IwVCxnQkFIbEIsSUFJQUYsUUFBUXhULFNBQVIsQ0FBa0I4UyxxQkFKbEIsSUFLQSxVQUFTdkYsQ0FBVCxFQUFZO1lBQ0pvRixVQUFVLENBQUMsS0FBS3BWLFFBQUwsSUFBaUIsS0FBSzJWLGFBQXZCLEVBQXNDQyxnQkFBdEMsQ0FBdUQ1RixDQUF2RCxDQUFkO1lBQ0loSSxJQUFJb04sUUFBUXhTLE1BRGhCO2VBRU8sRUFBRW9GLENBQUYsSUFBTyxDQUFQLElBQVlvTixRQUFRZ0IsSUFBUixDQUFhcE8sQ0FBYixNQUFvQixJQUF2QyxFQUE2QztlQUN0Q0EsSUFBSSxDQUFDLENBQVo7S0FWUjs7Ozs7QUFnQkosSUFBSWxKLE9BQU9tWCxPQUFQLElBQWtCLENBQUNBLFFBQVF4VCxTQUFSLENBQWtCcVQsT0FBekMsRUFBa0Q7WUFDdENyVCxTQUFSLENBQWtCcVQsT0FBbEIsR0FDQSxVQUFTOUYsQ0FBVCxFQUFZO1lBQ0pvRixVQUFVLENBQUMsS0FBS3BWLFFBQUwsSUFBaUIsS0FBSzJWLGFBQXZCLEVBQXNDQyxnQkFBdEMsQ0FBdUQ1RixDQUF2RCxDQUFkO1lBQ0loSSxDQURKO1lBRUlzQixLQUFLLElBRlQ7V0FHRztnQkFDSzhMLFFBQVF4UyxNQUFaO21CQUNPLEVBQUVvRixDQUFGLElBQU8sQ0FBUCxJQUFZb04sUUFBUWdCLElBQVIsQ0FBYXBPLENBQWIsTUFBb0JzQixFQUF2QyxFQUEyQztTQUYvQyxRQUdVdEIsSUFBSSxDQUFMLEtBQVlzQixLQUFLQSxHQUFHK00sYUFBcEIsQ0FIVDtlQUlPL00sRUFBUDtLQVRKOzs7SUNsQ2lCZ047b0JBQ0xoVCxJQUFaLEVBQWtCOzs7YUFDVEEsSUFBTCxHQUFZQSxJQUFaO2FBQ0tpVCxTQUFMLEdBQWlCLEVBQWpCOzs7OztxQ0FHU2pULE1BQUtrVCxNQUFNOzs7Z0JBR2hCQyxRQUFRLEVBQUVDLFFBQU8sS0FBS3BULElBQWQsRUFBb0JBLE1BQUtBLElBQXpCLEVBQStCa1QsTUFBS0EsSUFBcEMsRUFBMENuVCxNQUFLLFVBQS9DLEVBQVo7aUJBQ0trVCxTQUFMLENBQWUxTSxJQUFmLENBQW9CNE0sS0FBcEI7MEJBQ2M1TSxJQUFkLENBQW1CNE0sS0FBbkI7MkJBQ2VFLGFBQWYsR0FBK0I1SixLQUFLRSxTQUFMLENBQWUwSixhQUFmLENBQS9COzs7O2tDQUdhclQsTUFBTTtnQkFDZmdULE9BQU9NLFNBQVAsQ0FBaUJ0VCxJQUFqQixNQUEyQjFCLFNBQS9CLEVBQTBDO29CQUNsQ2lWLGlCQUFpQlAsT0FBT1EsTUFBUCxDQUFjeFQsSUFBZCxLQUF1QmdULE9BQU9TLE9BQW5EO3VCQUNPSCxTQUFQLENBQWlCdFQsSUFBakIsSUFBeUIsSUFBSXVULGNBQUosQ0FBbUJ2VCxJQUFuQixDQUF6Qjs7bUJBRUdnVCxPQUFPTSxTQUFQLENBQWlCdFQsSUFBakIsQ0FBUDs7Ozs7O0FBSVJnVCxPQUFPUyxPQUFQOzs7Ozs7Ozs7RUFBNkNULE1BQTdDOztBQUlBQSxPQUFPUSxNQUFQLEdBQWdCLEVBQWhCO0FBQ0FSLE9BQU9NLFNBQVAsR0FBbUIsRUFBbkI7O0FBRUEsSUFBSUQsZ0JBQWdCNUosS0FBS2lLLEtBQUwsQ0FBV0MsZUFBZU4sYUFBZixJQUFnQyxJQUEzQyxDQUFwQjs7QUMvQkE7QUFDQSxJQUFJdFYsTUFBTTZWLFNBQVNDLFFBQW5COztBQUVBLEFBQU8sSUFBSUMsc0JBQXNCckssS0FBS2lLLEtBQUwsQ0FBV0ssYUFBYUQsbUJBQWIsSUFBb0MsSUFBL0MsQ0FBMUI7QUFDUCxBQUFPLElBQUlFLG1CQUFtQkYsb0JBQW9CL1YsR0FBcEIsQ0FBdkI7O0FBRVAsSUFBSSxDQUFDaVcsZ0JBQUwsRUFBdUI7dUJBQ0FGLG9CQUFvQi9WLEdBQXBCLElBQTJCLEVBQTlDOzs7QUFHSixBQUFPOztBQU9QLEFBQU87Ozs7Ozs7Ozs7O0FDakJQLElBQUlrVyxhQUFhLEVBQWpCO0FBQ0EsSUFBSUMsa0JBQWtCLEVBQXRCO0FBQ0EsSUFBSUMsVUFBVSxFQUFkOztBQUVBLElBQUlDLGFBQWEsQ0FBakI7QUFDQSxJQUFJQyxTQUFKOztBQUVBLElBQU1DLGVBQWUxUixPQUFPLFVBQVAsQ0FBckI7QUFDQSxJQUFNMlIsY0FBYyxFQUFFLG9CQUFtQixJQUFyQixFQUEyQixtQkFBa0IsSUFBN0MsRUFBbURDLFVBQVUsSUFBN0QsRUFBcEI7O0FBRUEsSUFBTUMsVUFBVSxZQUFoQjs7QUFFQSxJQUFJQyx1QkFBdUI7Y0FBQTtjQUFBO2tCQUFBO2tCQUFBOzBCQUFBO2tDQUFBO29DQUFBO1dBUWhCLEtBUmdCO2NBU2IsSUFBSUMsT0FBSixDQUFZLFVBQVNDLE9BQVQsRUFBaUJDLE1BQWpCLEVBQXlCO29CQUMvQixxQkFBTTtpQ0FDT0MsS0FBckIsR0FBNkIsSUFBN0I7O1NBREo7O0tBRE07Q0FUZDs7QUFrQkEsU0FBU0MsTUFBVCxDQUFnQjdQLEdBQWhCLEVBQXFCO1FBQ2IsQ0FBRWlQLFFBQVFqUCxHQUFSLENBQU4sRUFBb0JpUCxRQUFRalAsR0FBUixJQUFlLElBQUk4UCxPQUFKLEVBQWY7V0FDYmIsUUFBUWpQLEdBQVIsQ0FBUDs7O0FBR0osU0FBUzFJLEtBQVQsQ0FBYTBCLEVBQWIsRUFBbUM7UUFBbEJnSCxHQUFrQix1RUFBWixVQUFZOztXQUN4QjZQLE9BQU83UCxHQUFQLEVBQVloSCxFQUFaLENBQVA7OztBQUdKLFNBQVN3TixLQUFULENBQWF4TixFQUFiLEVBQWlCOEgsRUFBakIsRUFBdUM7UUFBbEJkLEdBQWtCLHVFQUFaLFVBQVk7O1dBQzVCQSxHQUFQLEVBQVloSCxFQUFaLElBQWtCOEgsRUFBbEI7OztBQUdKLFNBQVNpUCxNQUFULENBQWdCL1AsR0FBaEIsRUFBcUJnSSxXQUFyQixFQUFrQztRQUMxQixPQUFPaEksR0FBUCxLQUFlLFFBQW5CLEVBQTZCO21CQUNkQSxHQUFYLElBQWtCZ0ksV0FBbEI7WUFDSXdILHFCQUFxQkksS0FBekIsRUFBZ0M7a0JBQ3RCeEYsSUFBTixDQUFXNVMsU0FBUzRWLGdCQUFULENBQTBCLFVBQTFCLENBQVgsRUFBa0RaLE9BQWxELENBQTBELG9CQUFZO29CQUM5RHdELFNBQVNaLFlBQVQsQ0FBSixFQUE0QlksU0FBU2hRLEdBQVQsSUFBZ0JnSSxXQUFoQjthQURoQzs7S0FIUixNQU9PLElBQUksT0FBT2hJLEdBQVAsS0FBZSxVQUFuQixFQUErQjt3QkFDbEJxQixJQUFoQixDQUFxQixDQUFDckIsR0FBRCxFQUFNZ0ksV0FBTixDQUFyQjs7Ozs7QUFLUixTQUFTaUksY0FBVCxDQUF3Qm5QLEVBQXhCLEVBQTRCa0gsV0FBNUIsRUFBeUNnSSxRQUF6QyxFQUFxRjtRQUFsQ0UsWUFBa0MsdUVBQW5CLGlCQUFtQjs7UUFDM0VuSCxRQUFRZixZQUFZL04sU0FBMUI7UUFDTWtXLFdBQVdwSCxNQUFNbUgsWUFBTixDQUFqQjtRQUNNWixXQUFXdkcsTUFBTXVHLFFBQXZCOztXQUVPaE0sbUJBQVAsQ0FBMkJ5RixLQUEzQixFQUFrQ3lELE9BQWxDLENBQTBDLGFBQUs7WUFDdkMsQ0FBRTZDLFlBQVllLENBQVosQ0FBTixFQUFzQjtnQkFDWkMsUUFBUWpaLE9BQU91TSx3QkFBUCxDQUFnQ29GLEtBQWhDLEVBQXVDcUgsQ0FBdkMsQ0FBZDtnQkFDSUMsTUFBTS9ZLEdBQU4sSUFBYStZLE1BQU03SixHQUF2QixFQUE0QnBQLE9BQU9DLGNBQVAsQ0FBc0J5SixFQUF0QixFQUEwQnNQLENBQTFCLEVBQTZCQyxLQUE3QixFQUE1QixLQUNLdlAsR0FBR3NQLENBQUgsSUFBUXJILE1BQU1xSCxDQUFOLENBQVI7O0tBSmI7O09BUUdFLE1BQUgsR0FBWXRJLFdBQVo7UUFDSW1JLFFBQUosRUFBY0EsU0FBU3BZLElBQVQsQ0FBYytJLEVBQWQsRUFBa0JrUCxRQUFsQjs7O1FBR1ZWLFFBQUosRUFBYztZQUNKdFcsS0FBS3NXLFNBQVN2WCxJQUFULENBQWMrSSxFQUFkLEVBQWtCa1AsUUFBbEIsQ0FBWDs7WUFFSSxDQUFDaFgsRUFBTCxFQUFTOztTQUhDOzs7WUFNTkEsTUFBTUEsR0FBR3VYLElBQWIsRUFBbUI7ZUFDWkEsSUFBSCxDQUFRQyxVQUFSO2NBQ0V0QixVQUFGO1NBRkosTUFHTzttQkFDSWxXLEVBQVA7Ozs7YUFJQ3dYLFVBQVQsQ0FBb0J4WCxFQUFwQixFQUF3QjtlQUNiQSxFQUFQO1lBQ0ksRUFBRWtXLFVBQUYsS0FBaUIsQ0FBckIsRUFBd0JDOzs7YUFHbkJzQixNQUFULENBQWdCelgsRUFBaEIsRUFBb0I7ZUFDVDhILEdBQUc0UCxTQUFWLEVBQXFCMVgsRUFBckIsSUFBMkI4SCxFQUEzQjtXQUNHeU8sT0FBSCxJQUFjdlcsRUFBZDs7OztBQUlSLFNBQVMyWCxlQUFULENBQXlCN1AsRUFBekIsRUFBNkJrSCxXQUE3QixFQUEwQ2dJLFFBQTFDLEVBQXVGO1FBQW5DRSxZQUFtQyx1RUFBcEIsa0JBQW9COztRQUM3RUMsV0FBV25JLFlBQVkvTixTQUFaLENBQXNCaVcsWUFBdEIsQ0FBakI7O1FBRUlDLFFBQUosRUFBY0EsU0FBU3BZLElBQVQsQ0FBYytJLEVBQWQsRUFBa0JrUCxRQUFsQjs7O0FBR2xCLFNBQVNZLFVBQVQsR0FBd0U7UUFBcERDLEdBQW9ELHVFQUE5Q3JaLFFBQThDO1FBQXBDc1osUUFBb0MsdUVBQXpCLHVCQUF5Qjs7VUFDOUQxRyxJQUFOLENBQVd5RyxJQUFJekQsZ0JBQUosQ0FBcUIwRCxRQUFyQixDQUFYLEVBQTJDdEUsT0FBM0MsQ0FBbUQsb0JBQVk7O2FBRXZELElBQUl4TSxHQUFSLElBQWUrTyxVQUFmLEVBQTJCO2dCQUNuQi9PLElBQUkrUSxPQUFKLENBQVksVUFBWixNQUE0QixDQUE1QixJQUFpQ2YsU0FBU3BELE9BQVQsQ0FBaUI1TSxHQUFqQixDQUFyQyxFQUE0RDsrQkFDekNnUSxRQUFmLEVBQXlCakIsV0FBVy9PLEdBQVgsQ0FBekIsRUFBMENnUSxRQUExQzs7OzttQ0FJQWhRLElBUm1EO2FBU3REZ1EsU0FBU2dCLE9BQVQsSUFBb0JoQixRQUFyQixFQUErQjVDLGdCQUEvQixDQUFnRHBOLElBQWhELEVBQXFEd00sT0FBckQsQ0FBNkQ7dUJBQU15RCxlQUFlblAsRUFBZixFQUFtQmlPLFdBQVcvTyxJQUFYLENBQW5CLEVBQW9DZ1EsUUFBcEMsQ0FBTjthQUE3RDs7O2FBREEsSUFBSWhRLElBQVIsSUFBZStPLFVBQWYsRUFBMkI7a0JBQW5CL08sSUFBbUI7O3dCQUdYd00sT0FBaEIsQ0FBd0Isb0JBQVk7Z0JBQ3pCeUUsTUFEeUIsR0FDRkMsUUFERTtnQkFDakJsSixXQURpQixHQUNGa0osUUFERTs7Z0JBRTFCQyxNQUFNRixPQUFPakIsUUFBUCxDQUFaO2dCQUNJeEQsT0FBSixDQUFZO3VCQUFNeUQsZUFBZW5QLEVBQWYsRUFBbUJrSCxXQUFuQixFQUFnQ2dJLFFBQWhDLENBQU47YUFBWjtTQUhKOzthQU1JLElBQUloUSxLQUFSLElBQWUrTyxVQUFmLEVBQTJCO2dCQUNuQi9PLE1BQUkrUSxPQUFKLENBQVksVUFBWixNQUE0QixDQUE1QixJQUFpQ2YsU0FBU3BELE9BQVQsQ0FBaUI1TSxLQUFqQixDQUFyQyxFQUE0RDtnQ0FDeENnUSxRQUFoQixFQUEwQmpCLFdBQVcvTyxLQUFYLENBQTFCLEVBQTJDZ1EsUUFBM0M7Ozs7aUJBSUNaLFlBQVQsSUFBeUIsSUFBekI7S0F2Qko7O1FBMEJJeUIsUUFBUXJaLFFBQVosRUFBc0I7WUFDZCxFQUFFMFgsVUFBRixLQUFpQixDQUFyQixFQUF3QkM7O0NBSWhDOztBQ3hJTyxTQUFTaUMsV0FBVCxDQUFxQkMsS0FBckIsRUFBNEU7UUFBaERDLE1BQWdELHVFQUF2Q0MsYUFBdUM7UUFBeEJDLE1BQXdCLHVFQUFmQyxhQUFlOztRQUMzRUMsUUFBUSxFQUFaOzs7U0FHSyxJQUFJbFMsSUFBSSxDQUFSLEVBQVdtUyxJQUFoQixFQUF1QkEsT0FBT04sTUFBTTdSLENBQU4sQ0FBOUIsRUFBeUNBLEdBQXpDLEVBQThDO1lBQ3BDMUUsT0FBT3dXLE9BQU9LLEtBQUs3VyxJQUFaLENBQWI7WUFDSUEsSUFBSixFQUFVO2tCQUNBQSxJQUFOLElBQWMwVyxPQUFPMVcsSUFBUCxFQUFhNlcsS0FBS2xaLEtBQWxCLENBQWQ7Ozs7V0FJRGlaLEtBQVA7OztBQUdKLEFBQU8sU0FBU0QsYUFBVCxDQUF1QjNXLElBQXZCLEVBQTRCckMsS0FBNUIsRUFBbUM7V0FDL0JBLEtBQVA7OztBQUdKLEFBQU8sU0FBUzhZLGFBQVQsQ0FBdUJ6VyxJQUF2QixFQUE2QjtXQUN6QkEsU0FBUyxVQUFULEdBQXNCQSxJQUF0QixHQUE2QixJQUFwQzs7O0FDcEJKOzs7Ozs7OztBQVFBLEFBRUE7OztBQUdBLEFBQU8sU0FBUzhXLGVBQVQsQ0FBeUJDLFFBQXpCLEVBQW1IO1FBQWhGQyxPQUFnRix1RUFBeEUsSUFBd0U7UUFBbEVULEtBQWtFLHVFQUE1RCxFQUE0RDtRQUF4RFUsSUFBd0QsdUVBQWpELEVBQUVULFFBQVEsSUFBVixFQUFnQkUsUUFBUSxJQUF4QixFQUE4QlEsV0FBVyxJQUF6QyxFQUFpRDs7UUFDaEhWLFNBQVNTLEtBQUtULE1BQUwsSUFBZUMsYUFBOUI7UUFDTUMsU0FBU08sS0FBS1AsTUFBTCxJQUFlQyxhQUE5QjtRQUNNTyxZQUFZLEVBQWxCO1FBQ01DLE9BQU8sQ0FBQ0gsT0FBRCwyQkFBZUUsU0FBZixFQUE2QlosWUFBWUMsS0FBWixFQUFtQkMsTUFBbkIsRUFBMkJFLE1BQTNCLENBQTdCLEVBQWI7OztpQkFHYVMsSUFBYixFQUFtQkosU0FBU0ssVUFBNUIsRUFBd0NaLE1BQXhDLEVBQWdERSxNQUFoRCxFQUF3RFcsUUFBeEQ7O2FBRVNBLFFBQVQsQ0FBa0JDLElBQWxCLEVBQXdCO2VBQ1pBLEtBQUs3RSxRQUFMLEtBQWtCLENBQXpCOzs7V0FHRTBFLElBQVA7OztBQUdKLEFBQU8sU0FBU0ksY0FBVCxDQUF3QnZSLEVBQXhCLEVBQW9GO1FBQXhEaVIsSUFBd0QsdUVBQWpELEVBQUVULFFBQVEsSUFBVixFQUFnQkUsUUFBUSxJQUF4QixFQUE4QlEsV0FBVyxJQUF6QyxFQUFpRDs7UUFDakZWLFNBQVNTLEtBQUtULE1BQUwsSUFBZUMsYUFBOUI7UUFDTUMsU0FBU08sS0FBS1AsTUFBTCxJQUFlQyxhQUE5QjtRQUNNTyxZQUFZLEVBQWxCO1FBQ01DLE9BQU8sQ0FBQ25SLEdBQUc0UCxTQUFKLDJCQUFvQnNCLFNBQXBCLEVBQWtDWixZQUFZdFEsR0FBR3dSLFVBQWYsRUFBMkJoQixNQUEzQixFQUFtQ0UsTUFBbkMsRUFBMkMxUSxHQUFHd1AsTUFBSCxJQUFheFAsR0FBR2tILFdBQTNELEVBQXdFbEgsR0FBRzRQLFNBQTNFLENBQWxDLEVBQWI7OztpQkFHYXVCLElBQWIsRUFBbUJuUixHQUFHb1IsVUFBdEIsRUFBa0NaLE1BQWxDLEVBQTBDRSxNQUExQyxFQUFrRGUsa0JBQWxEOztXQUVPTixJQUFQOzs7QUFHSixTQUFTTSxrQkFBVCxDQUE0QkgsSUFBNUIsRUFBa0M7V0FDdkIsSUFBUDs7O0FBSUosU0FBU0ksWUFBVCxDQUFzQkMsTUFBdEIsRUFBOEJQLFVBQTlCLEVBQTBDWixNQUExQyxFQUFrREUsTUFBbEQsRUFBdUY7UUFBN0JrQixNQUE2Qix1RUFBcEJILGtCQUFvQjs7U0FDL0UsSUFBSS9TLElBQUUsQ0FBTixFQUFTbEYsQ0FBYixFQUFnQkEsSUFBSTRYLFdBQVcxUyxDQUFYLENBQXBCLEVBQW1DLEVBQUVBLENBQXJDLEVBQXdDOztZQUVoQyxDQUFFa1QsT0FBT3BZLENBQVAsQ0FBTixFQUFpQjs7Z0JBRVZBLEVBQUVpVCxRQUFUO2lCQUNTLENBQUw7b0JBQ1FvRixPQUFPLENBQUNyWSxFQUFFb1csU0FBSCxFQUFjVSxZQUFZOVcsRUFBRWdZLFVBQWQsRUFBMEJoQixNQUExQixFQUFrQ0UsTUFBbEMsRUFBMENsWCxFQUFFZ1csTUFBRixJQUFZaFcsRUFBRTBOLFdBQXhELEVBQXFFMU4sRUFBRW9XLFNBQXZFLENBQWQsQ0FBWDt1QkFDT3JQLElBQVAsQ0FBWXNSLElBQVo7NkJBQ2FBLElBQWIsRUFBbUJyWSxFQUFFNFgsVUFBckIsRUFBaUNaLE1BQWpDLEVBQXlDRSxNQUF6QyxFQUFpRGUsa0JBQWpEOztpQkFFQyxDQUFMO3VCQUNXbFIsSUFBUCxDQUFZL0csRUFBRXNZLFNBQWQ7Ozs7Ozs7SUN4REtDOzs7Ozs7OzBDQUVDOztpQkFFVEMsS0FBTCxHQUFhLEtBQUtDLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBYjs7Z0JBRUksS0FBS0QsS0FBTCxJQUFjLEtBQUs5WixFQUF2QixFQUEyQjsyQkFDWixLQUFLZ1ksT0FBTCxJQUFnQixJQUEzQjs7Ozs7OzJDQXVCVztnQkFDWCxLQUFLOEIsS0FBTCxJQUFjLEtBQUs5WixFQUF2QixFQUEyQjsyQkFDWixLQUFLZ1ksT0FBTCxJQUFnQixJQUEzQjs7aUJBRUNnQyxVQUFMLEdBQWtCaFIsTUFBTW9JLElBQU4sQ0FBVyxDQUFDLEtBQUs0RyxPQUFMLElBQWdCLElBQWpCLEVBQXVCNUQsZ0JBQXZCLENBQXdDLFlBQXhDLENBQVgsQ0FBbEI7Ozs7cUNBR1M2RixPQUFPO21CQUNULEtBQUtDLE1BQVosQ0FEZ0I7Ozs7bUNBSVQ7Z0JBQ0hsYSxLQUFLLEtBQUtBLEVBQUwsSUFBVyxLQUFLK1osWUFBTCxDQUFrQixZQUFsQixDQUFwQjtpQkFDS0ksZUFBTCxDQUFxQixJQUFyQjttQkFDT25hLEVBQVAsQ0FITzs7Ozs0QkE3QkU7O2dCQUVIb2EsWUFBWSxtQkFBbEI7Z0JBQ01wQixZQUFZLEVBQUVvQixXQUFXQSxTQUFiLEVBQWxCOztxQkFFUzlCLE1BQVQsQ0FBZ0J4VyxJQUFoQixFQUFzQjtvQkFDZEEsU0FBUyxPQUFiLEVBQXNCLE9BQU8sV0FBUDt1QkFDZkEsSUFBUDs7cUJBRUswVyxNQUFULENBQWdCMVcsSUFBaEIsRUFBc0JyQyxLQUF0QixFQUE2QjtvQkFDckJxQyxTQUFTLFdBQWIsRUFBMEIsT0FBT3JDLFFBQVEsR0FBUixHQUFjMmEsU0FBckI7dUJBQ25CM2EsS0FBUDs7bUJBRUcsS0FBSzRhLE9BQUwsR0FDRCxLQUFLQSxPQURKLEdBRUEsS0FBS0EsT0FBTCxHQUFlekIsZ0JBQWdCLEtBQUtaLE9BQUwsSUFBZ0IsSUFBaEMsRUFBc0Msb0JBQXRDLEVBQTRELEtBQUtzQixVQUFqRSxFQUE2RSxFQUFFaEIsY0FBRixFQUFVRSxjQUFWLEVBQWtCUSxvQkFBbEIsRUFBN0UsQ0FGdEI7Ozs7OztBQXVCUixTQUFTc0IsVUFBVCxDQUFvQkMsSUFBcEIsRUFBMEI7OztVQUdabkosSUFBTixDQUFXbUosS0FBS25HLGdCQUFMLENBQXNCLEdBQXRCLENBQVgsRUFBdUNaLE9BQXZDLENBQStDLGlCQUFTO1lBQ2hEd0IsT0FBT3dGLE1BQU1DLFdBQU4sQ0FBa0IxVyxPQUFsQixDQUEwQixLQUExQixFQUFnQyxFQUFoQyxDQUFYO1lBQ0ksQ0FBQ2lSLElBQUQsSUFBUzBGLGVBQWVGLE1BQU1HLFFBQXJCLENBQWIsRUFBNkM7Z0JBQ3JDSCxNQUFNOUMsU0FBTixLQUFvQixHQUF4QixFQUE2QjtzQkFDbkJsRCxVQUFOLENBQWlCb0csV0FBakIsQ0FBNkJKLEtBQTdCOzs7S0FKWjs7OzthQVdTRSxjQUFULENBQXdCQyxRQUF4QixFQUFrQzthQUMxQixJQUFJblUsSUFBRSxDQUFOLEVBQVF1RyxJQUFFNE4sU0FBU3ZaLE1BQXZCLEVBQStCb0YsSUFBRXVHLENBQWpDLEVBQW9DLEVBQUV2RyxDQUF0QyxFQUF5QztvQkFDOUJtVSxTQUFTblUsQ0FBVCxFQUFZa1IsU0FBbkI7cUJBQ1MsS0FBTDtxQkFDSyxJQUFMOzs7MkJBR1csS0FBUCxDQUxSOzs7ZUFRRyxJQUFQOzs7O0FDMUVaOzs7Ozs7Ozs7O0lBVXFCbUQ7Ozs7Ozs7d0NBTUQ3RCxVQUFVO2lCQUNqQjhELFNBQUwsQ0FBZUMsR0FBZixDQUFtQixXQUFuQjs7Ozs7Ozs7QUFQYUYsVUFFVkcsc0JBQXNCLENBQUMsbUJBQUQ7QUFGWkgsVUFHVkksc0JBQXNCLENBQUMsbUJBQUQ7QUFIWkosVUFJVkssU0FBUyxFQUFFQyxjQUFjLEdBQWhCLEVBQXFCQyxlQUFlLEVBQXBDLEdBU3BCOztBQ3ZCQTs7Ozs7Ozs7OztBQWFBLEFBQU8sU0FBU0MsSUFBVCxDQUFlQyxHQUFmLEVBQW9COzthQUtkQyxXQUFULENBQXFCbkUsQ0FBckIsRUFBdUI1SSxDQUF2QixFQUEwQjs7WUFHbEJnTixLQUFPcEUsS0FBRzVJLENBQUwsR0FBWTRJLE1BQUssS0FBRzVJLENBQTdCOztlQUdPZ04sRUFBUDs7O2FBUUtDLE9BQVQsQ0FBaUI1YyxHQUFqQixFQUFzQjs7WUFHZDZjLE1BQUksRUFBUjs7WUFHSWxWLENBQUo7O1lBR0ltVixFQUFKOztZQUdJQyxFQUFKOzthQUtLcFYsSUFBRSxDQUFQLEVBQVVBLEtBQUcsQ0FBYixFQUFnQkEsS0FBRyxDQUFuQixFQUF1Qjs7aUJBR2IzSCxRQUFPMkgsSUFBRSxDQUFGLEdBQUksQ0FBWixHQUFnQixJQUFyQjs7aUJBR00zSCxRQUFPMkgsSUFBRSxDQUFWLEdBQWMsSUFBbkI7O21CQUdPbVYsR0FBRzdjLFFBQUgsQ0FBWSxFQUFaLElBQWtCOGMsR0FBRzljLFFBQUgsQ0FBWSxFQUFaLENBQXpCOzs7ZUFNRzRjLEdBQVA7OzthQVFLRyxPQUFULENBQWlCaGQsR0FBakIsRUFBc0I7O1lBR2Q2YyxNQUFJLEVBQVI7O1lBR0lsVixDQUFKOztZQUdJc1YsQ0FBSjs7YUFLS3RWLElBQUUsQ0FBUCxFQUFVQSxLQUFHLENBQWIsRUFBZ0JBLEdBQWhCLEVBQXNCOztnQkFHYjNILFFBQU8ySCxJQUFFLENBQVYsR0FBYyxJQUFsQjs7bUJBR09zVixFQUFFaGQsUUFBRixDQUFXLEVBQVgsQ0FBUDs7O2VBTUc0YyxHQUFQOzs7YUFVS0ssVUFBVCxDQUFvQmxZLE1BQXBCLEVBQTRCOztpQkFHZkEsT0FBT0UsT0FBUCxDQUFlLE9BQWYsRUFBdUIsSUFBdkIsQ0FBVDs7WUFHSWlZLFVBQVUsRUFBZDs7YUFLSyxJQUFJNUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdlQsT0FBT3pDLE1BQTNCLEVBQW1DZ1csR0FBbkMsRUFBd0M7O2dCQUtoQzlWLElBQUl1QyxPQUFPNEssVUFBUCxDQUFrQjJJLENBQWxCLENBQVI7O2dCQUtJOVYsSUFBSSxHQUFSLEVBQWE7OzJCQUdFTixPQUFPaWIsWUFBUCxDQUFvQjNhLENBQXBCLENBQVg7YUFISixNQVNLLElBQUlBLElBQUksR0FBTCxJQUFjQSxJQUFJLElBQXJCLEVBQTRCOzsyQkFHbEJOLE9BQU9pYixZQUFQLENBQXFCM2EsS0FBSyxDQUFOLEdBQVcsR0FBL0IsQ0FBWDs7MkJBR1dOLE9BQU9pYixZQUFQLENBQXFCM2EsSUFBSSxFQUFMLEdBQVcsR0FBL0IsQ0FBWDthQU5DLE1BWUE7OzJCQUdVTixPQUFPaWIsWUFBUCxDQUFxQjNhLEtBQUssRUFBTixHQUFZLEdBQWhDLENBQVg7OzJCQUdXTixPQUFPaWIsWUFBUCxDQUFzQjNhLEtBQUssQ0FBTixHQUFXLEVBQVosR0FBa0IsR0FBdEMsQ0FBWDs7MkJBR1dOLE9BQU9pYixZQUFQLENBQXFCM2EsSUFBSSxFQUFMLEdBQVcsR0FBL0IsQ0FBWDs7OztlQWFEMGEsT0FBUDs7O1FBUUFFLFVBQUo7O1FBR0kxVixDQUFKLEVBQU9rSCxDQUFQOztRQUdJNUssSUFBSSxJQUFJa0csS0FBSixDQUFVLEVBQVYsQ0FBUjs7UUFHSW1ULEtBQUssVUFBVDs7UUFHSUMsS0FBSyxVQUFUOztRQUdJQyxLQUFLLFVBQVQ7O1FBR0lDLEtBQUssVUFBVDs7UUFHSUMsS0FBSyxVQUFUOztRQUdJakosQ0FBSixFQUFPL1EsQ0FBUCxFQUFVcVAsQ0FBVixFQUFhdkYsQ0FBYixFQUFnQmEsQ0FBaEI7O1FBR0lzUCxJQUFKOztVQUtNVCxXQUFXVCxHQUFYLENBQU47O1FBS0ltQixVQUFVbkIsSUFBSWxhLE1BQWxCOztRQUtJc2IsYUFBYSxJQUFJMVQsS0FBSixFQUFqQjs7U0FHS3hDLElBQUUsQ0FBUCxFQUFVQSxJQUFFaVcsVUFBUSxDQUFwQixFQUF1QmpXLEtBQUcsQ0FBMUIsRUFBOEI7O1lBR3RCOFUsSUFBSTdNLFVBQUosQ0FBZWpJLENBQWYsS0FBbUIsRUFBbkIsR0FBd0I4VSxJQUFJN00sVUFBSixDQUFlakksSUFBRSxDQUFqQixLQUFxQixFQUE3QyxHQUdKOFUsSUFBSTdNLFVBQUosQ0FBZWpJLElBQUUsQ0FBakIsS0FBcUIsQ0FIakIsR0FHcUI4VSxJQUFJN00sVUFBSixDQUFlakksSUFBRSxDQUFqQixDQUh6Qjs7bUJBTVc2QixJQUFYLENBQWlCcUYsQ0FBakI7OztZQVFJK08sVUFBVSxDQUFsQjs7YUFHUyxDQUFMOztnQkFHUSxXQUFKOzs7O2FBTUMsQ0FBTDs7Z0JBR1FuQixJQUFJN00sVUFBSixDQUFlZ08sVUFBUSxDQUF2QixLQUEyQixFQUEzQixHQUFnQyxTQUFwQzs7OzthQVFDLENBQUw7O2dCQUdRbkIsSUFBSTdNLFVBQUosQ0FBZWdPLFVBQVEsQ0FBdkIsS0FBMkIsRUFBM0IsR0FBZ0NuQixJQUFJN00sVUFBSixDQUFlZ08sVUFBUSxDQUF2QixLQUEyQixFQUEzRCxHQUFnRSxPQUFwRTs7OzthQVFDLENBQUw7O2dCQUdRbkIsSUFBSTdNLFVBQUosQ0FBZWdPLFVBQVEsQ0FBdkIsS0FBMkIsRUFBM0IsR0FBZ0NuQixJQUFJN00sVUFBSixDQUFlZ08sVUFBUSxDQUF2QixLQUEyQixFQUEzRCxHQUFnRW5CLElBQUk3TSxVQUFKLENBQWVnTyxVQUFRLENBQXZCLEtBQTJCLENBQTNGLEdBQWtHLElBQXRHOzs7Ozs7ZUFXR3BVLElBQVgsQ0FBaUI3QixDQUFqQjs7V0FLUWtXLFdBQVd0YixNQUFYLEdBQW9CLEVBQXJCLElBQTRCLEVBQW5DO21CQUFtRGlILElBQVgsQ0FBaUIsQ0FBakI7S0FLeENxVSxXQUFXclUsSUFBWCxDQUFpQm9VLFlBQVUsRUFBM0I7O2VBR1dwVSxJQUFYLENBQWtCb1UsV0FBUyxDQUFWLEdBQWEsV0FBOUI7O1NBT01QLGFBQVcsQ0FBakIsRUFBb0JBLGFBQVdRLFdBQVd0YixNQUExQyxFQUFrRDhhLGNBQVksRUFBOUQsRUFBbUU7O2FBSzFEMVYsSUFBRSxDQUFQLEVBQVVBLElBQUUsRUFBWixFQUFnQkEsR0FBaEI7Y0FBd0JBLENBQUYsSUFBT2tXLFdBQVdSLGFBQVcxVixDQUF0QixDQUFQO1NBR3RCLEtBQUtBLElBQUUsRUFBUCxFQUFXQSxLQUFHLEVBQWQsRUFBa0JBLEdBQWxCO2NBQTBCQSxDQUFGLElBQU8rVSxZQUFZelksRUFBRTBELElBQUUsQ0FBSixJQUFTMUQsRUFBRTBELElBQUUsQ0FBSixDQUFULEdBQWtCMUQsRUFBRTBELElBQUUsRUFBSixDQUFsQixHQUE0QjFELEVBQUUwRCxJQUFFLEVBQUosQ0FBeEMsRUFBaUQsQ0FBakQsQ0FBUDtTQUt4QjhNLElBQUk2SSxFQUFKOztZQUdJQyxFQUFKOztZQUdJQyxFQUFKOztZQUdJQyxFQUFKOztZQUdJQyxFQUFKOzthQUtLL1YsSUFBRyxDQUFSLEVBQVdBLEtBQUcsRUFBZCxFQUFrQkEsR0FBbEIsRUFBd0I7O21CQUdaK1UsWUFBWWpJLENBQVosRUFBYyxDQUFkLEtBQXFCL1EsSUFBRXFQLENBQUgsR0FBUyxDQUFDclAsQ0FBRCxHQUFHOEosQ0FBaEMsSUFBc0NhLENBQXRDLEdBQTBDcEssRUFBRTBELENBQUYsQ0FBMUMsR0FBaUQsVUFBbEQsR0FBZ0UsV0FBdkU7O2dCQUdJNkYsQ0FBSjs7Z0JBR0l1RixDQUFKOztnQkFHSTJKLFlBQVloWixDQUFaLEVBQWMsRUFBZCxDQUFKOztnQkFHSStRLENBQUo7O2dCQUdJa0osSUFBSjs7O2FBUUNoVyxJQUFFLEVBQVAsRUFBV0EsS0FBRyxFQUFkLEVBQWtCQSxHQUFsQixFQUF3Qjs7bUJBR1orVSxZQUFZakksQ0FBWixFQUFjLENBQWQsS0FBb0IvUSxJQUFJcVAsQ0FBSixHQUFRdkYsQ0FBNUIsSUFBaUNhLENBQWpDLEdBQXFDcEssRUFBRTBELENBQUYsQ0FBckMsR0FBNEMsVUFBN0MsR0FBMkQsV0FBbEU7O2dCQUdJNkYsQ0FBSjs7Z0JBR0l1RixDQUFKOztnQkFHSTJKLFlBQVloWixDQUFaLEVBQWMsRUFBZCxDQUFKOztnQkFHSStRLENBQUo7O2dCQUdJa0osSUFBSjs7O2FBUUNoVyxJQUFFLEVBQVAsRUFBV0EsS0FBRyxFQUFkLEVBQWtCQSxHQUFsQixFQUF3Qjs7bUJBR1orVSxZQUFZakksQ0FBWixFQUFjLENBQWQsS0FBcUIvUSxJQUFFcVAsQ0FBSCxHQUFTclAsSUFBRThKLENBQVgsR0FBaUJ1RixJQUFFdkYsQ0FBdkMsSUFBNkNhLENBQTdDLEdBQWlEcEssRUFBRTBELENBQUYsQ0FBakQsR0FBd0QsVUFBekQsR0FBdUUsV0FBOUU7O2dCQUdJNkYsQ0FBSjs7Z0JBR0l1RixDQUFKOztnQkFHSTJKLFlBQVloWixDQUFaLEVBQWMsRUFBZCxDQUFKOztnQkFHSStRLENBQUo7O2dCQUdJa0osSUFBSjs7O2FBUUNoVyxJQUFFLEVBQVAsRUFBV0EsS0FBRyxFQUFkLEVBQWtCQSxHQUFsQixFQUF3Qjs7bUJBR1orVSxZQUFZakksQ0FBWixFQUFjLENBQWQsS0FBb0IvUSxJQUFJcVAsQ0FBSixHQUFRdkYsQ0FBNUIsSUFBaUNhLENBQWpDLEdBQXFDcEssRUFBRTBELENBQUYsQ0FBckMsR0FBNEMsVUFBN0MsR0FBMkQsV0FBbEU7O2dCQUdJNkYsQ0FBSjs7Z0JBR0l1RixDQUFKOztnQkFHSTJKLFlBQVloWixDQUFaLEVBQWMsRUFBZCxDQUFKOztnQkFHSStRLENBQUo7O2dCQUdJa0osSUFBSjs7O2FBUUVMLEtBQUs3SSxDQUFOLEdBQVcsV0FBaEI7O2FBR004SSxLQUFLN1osQ0FBTixHQUFXLFdBQWhCOzthQUdNOFosS0FBS3pLLENBQU4sR0FBVyxXQUFoQjs7YUFHTTBLLEtBQUtqUSxDQUFOLEdBQVcsV0FBaEI7O2FBR01rUSxLQUFLclAsQ0FBTixHQUFXLFdBQWhCOzs7UUFVQXNQLE9BQU9YLFFBQVFNLEVBQVIsSUFBY04sUUFBUU8sRUFBUixDQUFkLEdBQTRCUCxRQUFRUSxFQUFSLENBQTVCLEdBQTBDUixRQUFRUyxFQUFSLENBQTFDLEdBQXdEVCxRQUFRVSxFQUFSLENBQW5FOztXQUtPQyxLQUFLRyxXQUFMLEVBQVA7OztBQ3ZkRyxTQUFTQyxTQUFULENBQW1CQyxNQUFuQixFQUEyQjtRQUN4QkMsU0FBUzlULE1BQU1vSSxJQUFOLENBQVd5TCxPQUFPekksZ0JBQVAsQ0FBd0JoVyxPQUFPb0ssSUFBUCxDQUFZdVUsTUFBWixFQUFvQmhjLElBQXBCLENBQXlCLEdBQXpCLENBQXhCLENBQVgsQ0FBZjs7V0FFT3lTLE9BQVAsQ0FBZSxpQkFBUztZQUNoQixDQUFDd0osTUFBTWxiLElBQVgsRUFBaUI7a0JBQ1BtYixZQUFOLENBQW1CLE1BQW5CLEVBQTBCQyxnQkFBMUI7O0tBRlI7V0FLT0osTUFBUDs7O0FBR0osSUFBSUssYUFBYSxDQUFqQjs7QUFFQSxTQUFTRCxjQUFULEdBQTBCO1dBQ2ZDLFlBQVA7OztBQUlKLEFBQU8sSUFBTUosU0FBUzthQUNULEVBRFM7O2NBS1IsRUFMUTs7Z0JBU047Q0FUVDs7QUNsQlA7QUFDQSxBQUVBLEFBRUEsQUFFQSxBQUVBOzs7QUFHQSxTQUFTSyxjQUFULENBQXdCbkQsS0FBeEIsRUFBK0I7OztXQUdwQixrQkFBVTs7O1lBR1QsT0FBT29ELE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0MsT0FBT0EsT0FBT3paLElBQVAsRUFBUDs7O1lBRzVCbVosT0FBUU0sT0FBTyxDQUFQLENBQVIsQ0FBSixFQUF5QjtnQkFDZnZiLE9BQU91YixPQUFPLENBQVAsRUFBVXZiLElBQXZCO2dCQUNJQSxRQUFRbVksS0FBWixFQUFtQixPQUFPQSxNQUFNblksSUFBTixDQUFQOztnQkFFYndiLFVBQVVELE9BQU9FLEdBQVAsQ0FBV0MsU0FBWCxFQUFzQjlELE1BQXRCLENBQTZCO3VCQUFTekUsS0FBVDthQUE3QixDQUFoQjs7O29CQUdRd0ksY0FBUixHQUF5QixJQUF6QjttQkFDT0gsT0FBUDs7Ozs7OztlQU9HRCxNQUFQO0tBckJKOzthQXdCU0csU0FBVCxDQUFtQnZJLEtBQW5CLEVBQTBCOztZQUVsQixPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCLE9BQU9BLE1BQU1sUixPQUFOLENBQWMsSUFBZCxFQUFtQixFQUFuQixFQUF1QkgsSUFBdkIsRUFBUDtlQUN4QnFSLEtBQVA7Ozs7QUFJUixTQUFTeUksdUJBQVQsQ0FBaUNDLElBQWpDLEVBQXVDO1FBQy9CLE9BQU9BLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEIsT0FBT0EsSUFBUDs7V0FFdkIsTUFBTUEsS0FBSyxDQUFMLEVBQVE3YixJQUFyQjs7O0lBR2lCOGI7Ozs7Ozs7d0NBQ0Q1RyxVQUFVOzs7Z0JBQ2xCLENBQUMsS0FBSzZHLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBTCxFQUFpQyxLQUFLWixZQUFMLENBQWtCLE9BQWxCLEVBQTBCakcsU0FBUzhDLEtBQW5DO2lCQUM1QnRGLFVBQUwsQ0FBZ0JvRyxXQUFoQixDQUE0QixJQUE1Qjs7Z0JBRUk1RCxTQUFTOEcsT0FBVCxJQUFvQjFkLFNBQXhCLEVBQW1DNFcsU0FBUzhHLE9BQVQsR0FBbUIsRUFBbkI7cUJBQzFCQSxPQUFULENBQWlCelYsSUFBakIsQ0FBc0IsSUFBdEI7O2lCQUVLMFYsVUFBTCxHQUFrQixFQUFsQjtnQkFDTWpCLFNBQVMsRUFBZjtzQkFDVSxJQUFWLEVBQWdCdEosT0FBaEIsQ0FBd0IsaUJBQVM7c0JBQ3hCdUssVUFBTCxDQUFnQjFWLElBQWhCLENBQXFCMlUsTUFBTWxiLElBQTNCO3VCQUNPa2IsTUFBTWxiLElBQWIsSUFBcUJrYixLQUFyQjtzQkFDS0YsTUFBTCxHQUFjQSxNQUFkOztvQkFFTWtCLGdCQUFnQixNQUFLLGFBQWFoQixNQUFNdEYsU0FBeEIsQ0FBdEI7b0JBQ0lzRyxhQUFKLEVBQW1CQSxjQUFjamYsSUFBZCxRQUF5QmllLEtBQXpCO2FBTnZCOzs7Ozs7aUJBYUtpQixTQUFMLEdBQWlCNUUsZUFBZSxJQUFmLEVBQXFCL1UsS0FBckIsQ0FBMkIsQ0FBM0IsQ0FBakI7aUJBQ0s0WixnQkFBTCxHQUF3QixLQUFLRCxTQUFMLENBQWVWLEdBQWYsQ0FBbUJHLHVCQUFuQixDQUF4QjtpQkFDS1EsZ0JBQUwsQ0FBc0JDLE1BQXRCLEdBQStCLFVBQVNsRSxLQUFULEVBQWdCO3VCQUNwQyxLQUFLc0QsR0FBTCxDQUFTOzJCQUFRSSxLQUFLclcsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBbkIsR0FBeUIyUyxNQUFNMEQsS0FBS1MsU0FBTCxDQUFlLENBQWYsQ0FBTixDQUF6QixHQUFvRFQsSUFBNUQ7aUJBQVQsRUFBMkU1YyxJQUEzRSxDQUFnRixFQUFoRixDQUFQO2FBREo7OzthQUtKO3NDQUFpQnNkLFFBQVE7b0JBQ2RBLE9BQU90RSxZQUFQLENBQW9CLE1BQXBCLENBQVA7cUJBQ1MsVUFBTDs7O3dCQUdVdUUsY0FBYzlmLFNBQVNFLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBcEI7Z0NBQ1krYixXQUFaLEdBQTBCLEVBQTFCO2dDQUNZaGIsS0FBWixHQUFvQixFQUFwQjsyQkFDTzhlLFlBQVAsQ0FBb0JELFdBQXBCLEVBQWlDRCxPQUFPRyxpQkFBeEM7MkJBQ08vZSxLQUFQLEdBQWUsRUFBZjs7Ozs7Ozs7OytDQU1Xd2EsT0FBTztnQkFDdEJqQyxVQUFVLEtBQUtpRyxTQUFMLENBQWVWLEdBQWYsQ0FBbUJILGVBQWVuRCxLQUFmLENBQW5CLEVBQTBDUCxNQUExQyxDQUFpRCxVQUFDaUUsSUFBRDt1QkFBVUEsSUFBVjthQUFqRCxDQUFkO2lCQUNJLElBQUluWCxJQUFJLENBQVIsRUFBV3lPLEtBQWYsRUFBc0JBLFFBQVErQyxRQUFReFIsQ0FBUixDQUE5QixFQUEwQyxFQUFFQSxDQUE1QyxFQUErQztvQkFDdkN5TyxNQUFNd0ksY0FBVixFQUEwQjs7b0JBRXRCZ0IsWUFBUixHQUF1QmpZLENBQXZCO21CQUNPd1IsT0FBUDs7OztpQ0FHS2hCLFVBQVU7Z0JBQ1RoWCxLQUFLLEtBQUsrWixZQUFMLENBQWtCLElBQWxCLENBQVg7Z0JBQ0kvWixFQUFKLEVBQVEsT0FBT2dYLFNBQVMwSCxVQUFULEdBQXNCLEdBQXRCLEdBQTRCMWUsRUFBbkMsQ0FBUixLQUNLOzs7dUJBR01xYixLQUFLLEtBQUtzRCxTQUFMLEdBQWlCLEtBQUs1RSxZQUFMLENBQWtCLE1BQWxCLENBQXRCLEVBQWlELFNBQWpELENBQVA7Ozs7O3VDQUlPNkUsZUFBZUMsT0FBTzs7Z0JBRTNCQyxTQUFTLEtBQUtiLFNBQUwsQ0FBZVYsR0FBZixDQUFtQndCLGNBQWNILGFBQWQsRUFBNkJDLEtBQTdCLENBQW5CLEVBQXdEbkYsTUFBeEQsQ0FBK0QsVUFBQ2lFLElBQUQ7dUJBQVVBLElBQVY7YUFBL0QsQ0FBZjs7OztnQkFJTXFCLGdCQUFnQixLQUFLakYsWUFBTCxDQUFrQixNQUFsQixNQUE4QixTQUE5QixHQUEwQzswQkFDbEQsS0FBSzJFO2FBREcsR0FFbEIsS0FGSjs7bUJBSU87NEJBQ1MsS0FBS0EsVUFEZDtzQkFFRyxLQUFLYixZQUFMLENBQWtCLE1BQWxCLENBRkg7c0JBR0csS0FBSzlELFlBQUwsQ0FBa0IsTUFBbEIsQ0FISDs2QkFJVSxLQUFLQSxZQUFMLENBQWtCLE9BQWxCLENBSlY7dUJBS0ksS0FBS0EsWUFBTCxDQUFrQixPQUFsQixLQUE4QjZFLGFBQTlCLEdBQTZDQSxjQUFjOUUsS0FBM0QsR0FBaUUsRUFMckU7NENBQUE7OEJBQUE7c0JBUUc4RSxjQUFjSyxTQUFkLEtBQTRCSixNQUFNSCxVQVJyQztzQkFTRyxLQUFLUSxTQVRSOzswQkFXTyxrQkFBQ0MsS0FBRCxFQUFXOzRCQUNUQyxJQUFSLENBQWEsT0FBYixFQUFzQkQsS0FBdEI7aUJBWkQ7NkJBY1UscUJBQUNBLEtBQUQsRUFBVzs0QkFDWkMsSUFBUixDQUFhLFFBQWIsRUFBdUJELEtBQXZCOzthQWZSOzs7Ozs7QUFxQlIsU0FBU0osYUFBVCxDQUF1QnJHLEtBQXZCLEVBQThCdUIsS0FBOUIsRUFBcUM7V0FDMUIsVUFBQ29GLEtBQUQsRUFBVzs7WUFFVixPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCLE9BQU83QixVQUFVNkIsS0FBVixDQUFQOzs7WUFHM0J0QyxPQUFRc0MsTUFBTSxDQUFOLENBQVIsQ0FBSixFQUF3QjtnQkFDZHZkLE9BQU91ZCxNQUFNLENBQU4sRUFBU3ZkLElBQXRCOzttQkFFTzt1QkFDSW1ZLE1BQU1uWSxJQUFOLENBREo7cUJBRUV1ZCxNQUFNLENBQU4sQ0FGRjswQkFBQTt1QkFJSUEsTUFBTSxDQUFOLENBSko7MEJBS09BLE1BQU0vYSxLQUFOLENBQVksQ0FBWixFQUFjLEdBQWQsRUFBbUJpWixHQUFuQixDQUF1QkMsU0FBdkIsRUFBa0M5RCxNQUFsQyxDQUF5QzsyQkFBUzJGLEtBQVQ7aUJBQXpDO2FBTGQ7OztlQVNHQSxLQUFQO0tBakJKOzthQW9CUzdCLFNBQVQsQ0FBbUJ2SSxLQUFuQixFQUEwQjs7WUFFbEIsT0FBT0EsS0FBUCxLQUFpQixRQUFyQixFQUErQixPQUFPQSxNQUFNbFIsT0FBTixDQUFjLElBQWQsRUFBbUIsRUFBbkIsRUFBdUJILElBQXZCLEVBQVA7ZUFDeEJxUixLQUFQOzs7O0FDM0tSOzs7QUFHQSxJQUFJcUssVUFBUSxRQUFaO0FBQ0EsSUFBSUMsWUFBWSxvRkFBaEI7O0FBRUEsSUFBSUMsWUFBWSxDQUFDLEVBQUUsT0FBT2xpQixNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPa0IsUUFBMUMsQ0FBakI7OztBQUdBLElBQUl5SyxZQUFVRCxNQUFNQyxPQUFwQjtBQUNBLFNBQVN3VyxtQkFBVCxDQUE2QkMsQ0FBN0IsRUFBZ0M7V0FDckIsQ0FBQ0MsWUFBWUQsRUFBRXplLFNBQWQsQ0FBRCxJQUE2QixDQUFDMGUsWUFBWUQsRUFBRXplLFNBQUYsQ0FBWWtkLE1BQXhCLENBQXJDOztBQUVKLFNBQVN5QixnQkFBVCxDQUEwQkYsQ0FBMUIsRUFBNkI7UUFDckI3ZCxjQUFjNmQsQ0FBZCxxREFBY0EsQ0FBZCxDQUFKO1dBQ083ZCxTQUFTLFFBQVQsSUFBcUJBLFNBQVMsUUFBckM7O0FBRUosU0FBU2dlLGFBQVQsQ0FBdUJILENBQXZCLEVBQTBCO1dBQ2ZDLFlBQVlELENBQVosS0FBa0JJLE9BQU9KLENBQVAsQ0FBekI7O0FBRUosU0FBU0ssU0FBVCxDQUFtQkwsQ0FBbkIsRUFBc0I7V0FDWEksT0FBT0osQ0FBUCxLQUFhQSxNQUFNLEtBQW5CLElBQTRCTSxPQUFPTixDQUFQLENBQTVCLElBQXlDQyxZQUFZRCxDQUFaLENBQWhEOztBQUVKLFNBQVM1ZSxVQUFULENBQW9CNGUsQ0FBcEIsRUFBdUI7V0FDWixPQUFPQSxDQUFQLEtBQWEsVUFBcEI7O0FBRUosU0FBU08sUUFBVCxDQUFrQlAsQ0FBbEIsRUFBcUI7V0FDVixPQUFPQSxDQUFQLEtBQWEsUUFBcEI7O0FBRUosU0FBU1EsUUFBVCxDQUFrQlIsQ0FBbEIsRUFBcUI7V0FDVixPQUFPQSxDQUFQLEtBQWEsUUFBcEI7O0FBRUosU0FBU0ksTUFBVCxDQUFnQkosQ0FBaEIsRUFBbUI7V0FDUkEsTUFBTSxJQUFiOztBQUVKLFNBQVNNLE1BQVQsQ0FBZ0JOLENBQWhCLEVBQW1CO1dBQ1JBLE1BQU0sSUFBYjs7QUFFSixTQUFTQyxXQUFULENBQXFCRCxDQUFyQixFQUF3QjtXQUNiQSxNQUFNLEtBQUssQ0FBbEI7O0FBRUosU0FBUzNoQixVQUFULENBQWtCMmhCLENBQWxCLEVBQXFCO1dBQ1YsUUFBT0EsQ0FBUCxxREFBT0EsQ0FBUCxPQUFhLFFBQXBCOztBQUVKLFNBQVNTLFVBQVQsQ0FBb0JDLE9BQXBCLEVBQTZCO1FBQ3JCLENBQUNBLE9BQUwsRUFBYztrQkFDQWIsU0FBVjs7VUFFRSxJQUFJYyxLQUFKLENBQVcsb0JBQW9CRCxPQUEvQixDQUFOOztBQUVKLFNBQVNFLE9BQVQsQ0FBaUJGLE9BQWpCLEVBQTBCOztZQUVkRyxJQUFSLENBQWFILE9BQWI7O0FBRUosU0FBU0ksV0FBVCxDQUFxQkMsS0FBckIsRUFBNEJDLE1BQTVCLEVBQW9DO1FBQzVCL2QsTUFBTSxFQUFWO1FBQ0k4ZCxLQUFKLEVBQVc7YUFDRixJQUFJNWdCLEdBQVQsSUFBZ0I0Z0IsS0FBaEIsRUFBdUI7Z0JBQ2Y1Z0IsR0FBSixJQUFXNGdCLE1BQU01Z0IsR0FBTixDQUFYOzs7UUFHSjZnQixNQUFKLEVBQVk7YUFDSCxJQUFJQyxLQUFULElBQWtCRCxNQUFsQixFQUEwQjtnQkFDbEJDLEtBQUosSUFBYUQsT0FBT0MsS0FBUCxDQUFiOzs7V0FHRGhlLEdBQVA7O0FBRUosU0FBU2llLFNBQVQsR0FBcUI7U0FDWkMsU0FBTCxHQUFpQixFQUFqQjs7QUFFSkQsVUFBVTNmLFNBQVYsQ0FBb0I2ZixXQUFwQixHQUFrQyxTQUFTQSxXQUFULENBQXFCM0osUUFBckIsRUFBK0I7U0FDeEQwSixTQUFMLENBQWV4WSxJQUFmLENBQW9COE8sUUFBcEI7Q0FESjtBQUdBeUosVUFBVTNmLFNBQVYsQ0FBb0I4ZixPQUFwQixHQUE4QixTQUFTQSxPQUFULEdBQW1CO1FBQ3pDRixZQUFZLEtBQUtBLFNBQXJCO1FBQ0lHLFFBQUo7O1dBRVFBLFdBQVdILFVBQVVJLEtBQVYsRUFBbkIsRUFBdUM7OztDQUozQzs7Ozs7QUFZQSxJQUFJQyxVQUFVO2dCQUNFLElBREY7aUJBRUcsSUFGSDtpQkFHRyxJQUhIO2tCQUlJLElBSko7bUJBS0ssSUFMTDtpQkFNRyxJQU5IO3dCQU9VLEtBUFY7c0JBUVEsS0FSUjtXQVNIO0NBVFg7Ozs7O0FBZUEsSUFBSUMsVUFBVSw4QkFBZDtBQUNBLElBQUlDLFFBQVEsc0NBQVo7QUFDQSxJQUFJQyxRQUFRLDRCQUFaO0FBQ0EsSUFBSUMsY0FBYyxJQUFJQyxHQUFKLEVBQWxCO0FBQ0FELFlBQVl2RyxHQUFaLENBQWdCLFFBQWhCO0FBQ0F1RyxZQUFZdkcsR0FBWixDQUFnQixnQkFBaEI7QUFDQSxJQUFJeUcsZUFBZSxJQUFJRCxHQUFKLEVBQW5CO0FBQ0FDLGFBQWF6RyxHQUFiLENBQWlCLE9BQWpCO0FBQ0F5RyxhQUFhekcsR0FBYixDQUFpQixRQUFqQjtBQUNBeUcsYUFBYXpHLEdBQWIsQ0FBaUIsTUFBakI7QUFDQXlHLGFBQWF6RyxHQUFiLENBQWlCLE1BQWpCO0FBQ0F5RyxhQUFhekcsR0FBYixDQUFpQixTQUFqQjtBQUNBeUcsYUFBYXpHLEdBQWIsQ0FBaUIsU0FBakI7QUFDQXlHLGFBQWF6RyxHQUFiLENBQWlCLFNBQWpCO0FBQ0F5RyxhQUFhekcsR0FBYixDQUFpQixVQUFqQjtBQUNBeUcsYUFBYXpHLEdBQWIsQ0FBaUIsVUFBakI7QUFDQXlHLGFBQWF6RyxHQUFiLENBQWlCLFVBQWpCO0FBQ0F5RyxhQUFhekcsR0FBYixDQUFpQixVQUFqQjtBQUNBeUcsYUFBYXpHLEdBQWIsQ0FBaUIsVUFBakI7QUFDQXlHLGFBQWF6RyxHQUFiLENBQWlCLFVBQWpCO0FBQ0F5RyxhQUFhekcsR0FBYixDQUFpQixVQUFqQjtBQUNBeUcsYUFBYXpHLEdBQWIsQ0FBaUIsaUJBQWpCO0FBQ0F5RyxhQUFhekcsR0FBYixDQUFpQixZQUFqQjtBQUNBeUcsYUFBYXpHLEdBQWIsQ0FBaUIsUUFBakI7QUFDQXlHLGFBQWF6RyxHQUFiLENBQWlCLFdBQWpCO0FBQ0F5RyxhQUFhekcsR0FBYixDQUFpQixVQUFqQjtBQUNBeUcsYUFBYXpHLEdBQWIsQ0FBaUIsZUFBakI7QUFDQSxJQUFJMEcsYUFBYSxJQUFJQyxHQUFKLEVBQWpCO0FBQ0FELFdBQVdqVSxHQUFYLENBQWUsWUFBZixFQUE2QjJULE9BQTdCO0FBQ0FNLFdBQVdqVSxHQUFYLENBQWUsZUFBZixFQUFnQzJULE9BQWhDO0FBQ0FNLFdBQVdqVSxHQUFYLENBQWUsZUFBZixFQUFnQzJULE9BQWhDO0FBQ0FNLFdBQVdqVSxHQUFYLENBQWUsWUFBZixFQUE2QjJULE9BQTdCO0FBQ0FNLFdBQVdqVSxHQUFYLENBQWUsWUFBZixFQUE2QjJULE9BQTdCO0FBQ0FNLFdBQVdqVSxHQUFYLENBQWUsYUFBZixFQUE4QjJULE9BQTlCO0FBQ0FNLFdBQVdqVSxHQUFYLENBQWUsWUFBZixFQUE2QjJULE9BQTdCO0FBQ0FNLFdBQVdqVSxHQUFYLENBQWUsVUFBZixFQUEyQjRULEtBQTNCO0FBQ0FLLFdBQVdqVSxHQUFYLENBQWUsVUFBZixFQUEyQjRULEtBQTNCO0FBQ0FLLFdBQVdqVSxHQUFYLENBQWUsV0FBZixFQUE0QjRULEtBQTVCO0FBQ0EsSUFBSU8sbUJBQW1CLElBQUlKLEdBQUosRUFBdkI7QUFDQUksaUJBQWlCNUcsR0FBakIsQ0FBcUIseUJBQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixtQkFBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLGtCQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsa0JBQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixTQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsY0FBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLGlCQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsYUFBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLE1BQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixVQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsY0FBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLFlBQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixjQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsV0FBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLFNBQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixZQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsWUFBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLFdBQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixZQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsU0FBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLE9BQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixTQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsU0FBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLFFBQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixRQUFyQjtBQUNBNEcsaUJBQWlCNUcsR0FBakIsQ0FBcUIsTUFBckI7QUFDQTRHLGlCQUFpQjVHLEdBQWpCLENBQXFCLGFBQXJCO0FBQ0E0RyxpQkFBaUI1RyxHQUFqQixDQUFxQixjQUFyQjtBQUNB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
